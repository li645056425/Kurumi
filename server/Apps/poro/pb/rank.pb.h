// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rank.proto

#ifndef PROTOBUF_rank_2eproto__INCLUDED
#define PROTOBUF_rank_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace rank {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rank_2eproto();
void protobuf_AssignDesc_rank_2eproto();
void protobuf_ShutdownFile_rank_2eproto();

class RankInfo;
class iconinfo;

// ===================================================================

class RankInfo : public ::google::protobuf::Message {
 public:
  RankInfo();
  virtual ~RankInfo();
  
  RankInfo(const RankInfo& from);
  
  inline RankInfo& operator=(const RankInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RankInfo& default_instance();
  
  void Swap(RankInfo* other);
  
  // implements Message ----------------------------------------------
  
  RankInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RankInfo& from);
  void MergeFrom(const RankInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rankid = 1;
  inline bool has_rankid() const;
  inline void clear_rankid();
  static const int kRankidFieldNumber = 1;
  inline ::google::protobuf::int32 rankid() const;
  inline void set_rankid(::google::protobuf::int32 value);
  
  // optional int32 myrank = 2;
  inline bool has_myrank() const;
  inline void clear_myrank();
  static const int kMyrankFieldNumber = 2;
  inline ::google::protobuf::int32 myrank() const;
  inline void set_myrank(::google::protobuf::int32 value);
  
  // optional int64 mypoint = 3;
  inline bool has_mypoint() const;
  inline void clear_mypoint();
  static const int kMypointFieldNumber = 3;
  inline ::google::protobuf::int64 mypoint() const;
  inline void set_mypoint(::google::protobuf::int64 value);
  
  // optional int64 mypower = 5;
  inline bool has_mypower() const;
  inline void clear_mypower();
  static const int kMypowerFieldNumber = 5;
  inline ::google::protobuf::int64 mypower() const;
  inline void set_mypower(::google::protobuf::int64 value);
  
  // optional string myserver = 6;
  inline bool has_myserver() const;
  inline void clear_myserver();
  static const int kMyserverFieldNumber = 6;
  inline const ::std::string& myserver() const;
  inline void set_myserver(const ::std::string& value);
  inline void set_myserver(const char* value);
  inline void set_myserver(const char* value, size_t size);
  inline ::std::string* mutable_myserver();
  inline ::std::string* release_myserver();
  
  // repeated .protobuf.rank.iconinfo ranks = 4;
  inline int ranks_size() const;
  inline void clear_ranks();
  static const int kRanksFieldNumber = 4;
  inline const ::protobuf::rank::iconinfo& ranks(int index) const;
  inline ::protobuf::rank::iconinfo* mutable_ranks(int index);
  inline ::protobuf::rank::iconinfo* add_ranks();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::rank::iconinfo >&
      ranks() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::rank::iconinfo >*
      mutable_ranks();
  
  // @@protoc_insertion_point(class_scope:protobuf.rank.RankInfo)
 private:
  inline void set_has_rankid();
  inline void clear_has_rankid();
  inline void set_has_myrank();
  inline void clear_has_myrank();
  inline void set_has_mypoint();
  inline void clear_has_mypoint();
  inline void set_has_mypower();
  inline void clear_has_mypower();
  inline void set_has_myserver();
  inline void clear_has_myserver();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 rankid_;
  ::google::protobuf::int32 myrank_;
  ::google::protobuf::int64 mypoint_;
  ::google::protobuf::int64 mypower_;
  ::std::string* myserver_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::rank::iconinfo > ranks_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_rank_2eproto();
  friend void protobuf_AssignDesc_rank_2eproto();
  friend void protobuf_ShutdownFile_rank_2eproto();
  
  void InitAsDefaultInstance();
  static RankInfo* default_instance_;
};
// -------------------------------------------------------------------

class iconinfo : public ::google::protobuf::Message {
 public:
  iconinfo();
  virtual ~iconinfo();
  
  iconinfo(const iconinfo& from);
  
  inline iconinfo& operator=(const iconinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const iconinfo& default_instance();
  
  void Swap(iconinfo* other);
  
  // implements Message ----------------------------------------------
  
  iconinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const iconinfo& from);
  void MergeFrom(const iconinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string head = 3;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 3;
  inline const ::std::string& head() const;
  inline void set_head(const ::std::string& value);
  inline void set_head(const char* value);
  inline void set_head(const char* value, size_t size);
  inline ::std::string* mutable_head();
  inline ::std::string* release_head();
  
  // optional string serverName = 4;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 4;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  
  // optional int32 rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // optional int64 rankPoints = 6;
  inline bool has_rankpoints() const;
  inline void clear_rankpoints();
  static const int kRankPointsFieldNumber = 6;
  inline ::google::protobuf::int64 rankpoints() const;
  inline void set_rankpoints(::google::protobuf::int64 value);
  
  // optional int32 power = 7;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 7;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);
  
  // optional string id = 8;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 8;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 headFrame = 9;
  inline bool has_headframe() const;
  inline void clear_headframe();
  static const int kHeadFrameFieldNumber = 9;
  inline ::google::protobuf::int32 headframe() const;
  inline void set_headframe(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.rank.iconinfo)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_rankpoints();
  inline void clear_has_rankpoints();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_headframe();
  inline void clear_has_headframe();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* head_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 rank_;
  ::std::string* servername_;
  ::google::protobuf::int64 rankpoints_;
  ::std::string* id_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 headframe_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_rank_2eproto();
  friend void protobuf_AssignDesc_rank_2eproto();
  friend void protobuf_ShutdownFile_rank_2eproto();
  
  void InitAsDefaultInstance();
  static iconinfo* default_instance_;
};
// ===================================================================


// ===================================================================

// RankInfo

// required int32 rankid = 1;
inline bool RankInfo::has_rankid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankInfo::set_has_rankid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankInfo::clear_has_rankid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankInfo::clear_rankid() {
  rankid_ = 0;
  clear_has_rankid();
}
inline ::google::protobuf::int32 RankInfo::rankid() const {
  return rankid_;
}
inline void RankInfo::set_rankid(::google::protobuf::int32 value) {
  set_has_rankid();
  rankid_ = value;
}

// optional int32 myrank = 2;
inline bool RankInfo::has_myrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankInfo::set_has_myrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankInfo::clear_has_myrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankInfo::clear_myrank() {
  myrank_ = 0;
  clear_has_myrank();
}
inline ::google::protobuf::int32 RankInfo::myrank() const {
  return myrank_;
}
inline void RankInfo::set_myrank(::google::protobuf::int32 value) {
  set_has_myrank();
  myrank_ = value;
}

// optional int64 mypoint = 3;
inline bool RankInfo::has_mypoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankInfo::set_has_mypoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankInfo::clear_has_mypoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankInfo::clear_mypoint() {
  mypoint_ = GOOGLE_LONGLONG(0);
  clear_has_mypoint();
}
inline ::google::protobuf::int64 RankInfo::mypoint() const {
  return mypoint_;
}
inline void RankInfo::set_mypoint(::google::protobuf::int64 value) {
  set_has_mypoint();
  mypoint_ = value;
}

// optional int64 mypower = 5;
inline bool RankInfo::has_mypower() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RankInfo::set_has_mypower() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RankInfo::clear_has_mypower() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RankInfo::clear_mypower() {
  mypower_ = GOOGLE_LONGLONG(0);
  clear_has_mypower();
}
inline ::google::protobuf::int64 RankInfo::mypower() const {
  return mypower_;
}
inline void RankInfo::set_mypower(::google::protobuf::int64 value) {
  set_has_mypower();
  mypower_ = value;
}

// optional string myserver = 6;
inline bool RankInfo::has_myserver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RankInfo::set_has_myserver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RankInfo::clear_has_myserver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RankInfo::clear_myserver() {
  if (myserver_ != &::google::protobuf::internal::kEmptyString) {
    myserver_->clear();
  }
  clear_has_myserver();
}
inline const ::std::string& RankInfo::myserver() const {
  return *myserver_;
}
inline void RankInfo::set_myserver(const ::std::string& value) {
  set_has_myserver();
  if (myserver_ == &::google::protobuf::internal::kEmptyString) {
    myserver_ = new ::std::string;
  }
  myserver_->assign(value);
}
inline void RankInfo::set_myserver(const char* value) {
  set_has_myserver();
  if (myserver_ == &::google::protobuf::internal::kEmptyString) {
    myserver_ = new ::std::string;
  }
  myserver_->assign(value);
}
inline void RankInfo::set_myserver(const char* value, size_t size) {
  set_has_myserver();
  if (myserver_ == &::google::protobuf::internal::kEmptyString) {
    myserver_ = new ::std::string;
  }
  myserver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankInfo::mutable_myserver() {
  set_has_myserver();
  if (myserver_ == &::google::protobuf::internal::kEmptyString) {
    myserver_ = new ::std::string;
  }
  return myserver_;
}
inline ::std::string* RankInfo::release_myserver() {
  clear_has_myserver();
  if (myserver_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = myserver_;
    myserver_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .protobuf.rank.iconinfo ranks = 4;
inline int RankInfo::ranks_size() const {
  return ranks_.size();
}
inline void RankInfo::clear_ranks() {
  ranks_.Clear();
}
inline const ::protobuf::rank::iconinfo& RankInfo::ranks(int index) const {
  return ranks_.Get(index);
}
inline ::protobuf::rank::iconinfo* RankInfo::mutable_ranks(int index) {
  return ranks_.Mutable(index);
}
inline ::protobuf::rank::iconinfo* RankInfo::add_ranks() {
  return ranks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::rank::iconinfo >&
RankInfo::ranks() const {
  return ranks_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::rank::iconinfo >*
RankInfo::mutable_ranks() {
  return &ranks_;
}

// -------------------------------------------------------------------

// iconinfo

// required int32 level = 1;
inline bool iconinfo::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iconinfo::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iconinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iconinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 iconinfo::level() const {
  return level_;
}
inline void iconinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string name = 2;
inline bool iconinfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iconinfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iconinfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iconinfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& iconinfo::name() const {
  return *name_;
}
inline void iconinfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* iconinfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string head = 3;
inline bool iconinfo::has_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iconinfo::set_has_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iconinfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iconinfo::clear_head() {
  if (head_ != &::google::protobuf::internal::kEmptyString) {
    head_->clear();
  }
  clear_has_head();
}
inline const ::std::string& iconinfo::head() const {
  return *head_;
}
inline void iconinfo::set_head(const ::std::string& value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value, size_t size) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_head() {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  return head_;
}
inline ::std::string* iconinfo::release_head() {
  clear_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_;
    head_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string serverName = 4;
inline bool iconinfo::has_servername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iconinfo::set_has_servername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void iconinfo::clear_has_servername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void iconinfo::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& iconinfo::servername() const {
  return *servername_;
}
inline void iconinfo::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void iconinfo::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void iconinfo::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* iconinfo::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rank = 5;
inline bool iconinfo::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void iconinfo::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void iconinfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void iconinfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 iconinfo::rank() const {
  return rank_;
}
inline void iconinfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int64 rankPoints = 6;
inline bool iconinfo::has_rankpoints() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void iconinfo::set_has_rankpoints() {
  _has_bits_[0] |= 0x00000020u;
}
inline void iconinfo::clear_has_rankpoints() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void iconinfo::clear_rankpoints() {
  rankpoints_ = GOOGLE_LONGLONG(0);
  clear_has_rankpoints();
}
inline ::google::protobuf::int64 iconinfo::rankpoints() const {
  return rankpoints_;
}
inline void iconinfo::set_rankpoints(::google::protobuf::int64 value) {
  set_has_rankpoints();
  rankpoints_ = value;
}

// optional int32 power = 7;
inline bool iconinfo::has_power() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void iconinfo::set_has_power() {
  _has_bits_[0] |= 0x00000040u;
}
inline void iconinfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void iconinfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 iconinfo::power() const {
  return power_;
}
inline void iconinfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional string id = 8;
inline bool iconinfo::has_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void iconinfo::set_has_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void iconinfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void iconinfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& iconinfo::id() const {
  return *id_;
}
inline void iconinfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void iconinfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void iconinfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* iconinfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 headFrame = 9;
inline bool iconinfo::has_headframe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void iconinfo::set_has_headframe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void iconinfo::clear_has_headframe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void iconinfo::clear_headframe() {
  headframe_ = 0;
  clear_has_headframe();
}
inline ::google::protobuf::int32 iconinfo::headframe() const {
  return headframe_;
}
inline void iconinfo::set_headframe(::google::protobuf::int32 value) {
  set_has_headframe();
  headframe_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rank
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rank_2eproto__INCLUDED
