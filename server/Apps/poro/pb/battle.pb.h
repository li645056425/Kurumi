// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: battle.proto

#ifndef PROTOBUF_battle_2eproto__INCLUDED
#define PROTOBUF_battle_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace battle {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_battle_2eproto();
void protobuf_AssignDesc_battle_2eproto();
void protobuf_ShutdownFile_battle_2eproto();

class FreshReplyInfo;
class iconinfo;
class SetLineupTemplate;
class BattleRequest;
class BattleInfo;
class BattleStart;
class BattleEnd;

// ===================================================================

class FreshReplyInfo : public ::google::protobuf::Message {
 public:
  FreshReplyInfo();
  virtual ~FreshReplyInfo();
  
  FreshReplyInfo(const FreshReplyInfo& from);
  
  inline FreshReplyInfo& operator=(const FreshReplyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreshReplyInfo& default_instance();
  
  void Swap(FreshReplyInfo* other);
  
  // implements Message ----------------------------------------------
  
  FreshReplyInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FreshReplyInfo& from);
  void MergeFrom(const FreshReplyInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // repeated .protobuf.common.KVint3232 carbonDayCnt = 2;
  inline int carbondaycnt_size() const;
  inline void clear_carbondaycnt();
  static const int kCarbonDayCntFieldNumber = 2;
  inline const ::protobuf::common::KVint3232& carbondaycnt(int index) const;
  inline ::protobuf::common::KVint3232* mutable_carbondaycnt(int index);
  inline ::protobuf::common::KVint3232* add_carbondaycnt();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
      carbondaycnt() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
      mutable_carbondaycnt();
  
  // repeated .protobuf.common.Id32 carbonPass = 5;
  inline int carbonpass_size() const;
  inline void clear_carbonpass();
  static const int kCarbonPassFieldNumber = 5;
  inline const ::protobuf::common::Id32& carbonpass(int index) const;
  inline ::protobuf::common::Id32* mutable_carbonpass(int index);
  inline ::protobuf::common::Id32* add_carbonpass();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Id32 >&
      carbonpass() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Id32 >*
      mutable_carbonpass();
  
  // optional bool isOpenBrave = 3;
  inline bool has_isopenbrave() const;
  inline void clear_isopenbrave();
  static const int kIsOpenBraveFieldNumber = 3;
  inline bool isopenbrave() const;
  inline void set_isopenbrave(bool value);
  
  // optional int64 nextFreshTime = 4;
  inline bool has_nextfreshtime() const;
  inline void clear_nextfreshtime();
  static const int kNextFreshTimeFieldNumber = 4;
  inline ::google::protobuf::int64 nextfreshtime() const;
  inline void set_nextfreshtime(::google::protobuf::int64 value);
  
  // optional int32 upId = 6;
  inline bool has_upid() const;
  inline void clear_upid();
  static const int kUpIdFieldNumber = 6;
  inline ::google::protobuf::int32 upid() const;
  inline void set_upid(::google::protobuf::int32 value);
  
  // optional int32 braveSelectType = 7;
  inline bool has_braveselecttype() const;
  inline void clear_braveselecttype();
  static const int kBraveSelectTypeFieldNumber = 7;
  inline ::google::protobuf::int32 braveselecttype() const;
  inline void set_braveselecttype(::google::protobuf::int32 value);
  
  // optional int32 bravePassType = 8;
  inline bool has_bravepasstype() const;
  inline void clear_bravepasstype();
  static const int kBravePassTypeFieldNumber = 8;
  inline ::google::protobuf::int32 bravepasstype() const;
  inline void set_bravepasstype(::google::protobuf::int32 value);
  
  // optional int32 bravePhase = 9;
  inline bool has_bravephase() const;
  inline void clear_bravephase();
  static const int kBravePhaseFieldNumber = 9;
  inline ::google::protobuf::int32 bravephase() const;
  inline void set_bravephase(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.battle.FreshReplyInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_isopenbrave();
  inline void clear_has_isopenbrave();
  inline void set_has_nextfreshtime();
  inline void clear_has_nextfreshtime();
  inline void set_has_upid();
  inline void clear_has_upid();
  inline void set_has_braveselecttype();
  inline void clear_has_braveselecttype();
  inline void set_has_bravepasstype();
  inline void clear_has_bravepasstype();
  inline void set_has_bravephase();
  inline void clear_has_bravephase();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 > carbondaycnt_;
  ::google::protobuf::int32 type_;
  bool isopenbrave_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::Id32 > carbonpass_;
  ::google::protobuf::int64 nextfreshtime_;
  ::google::protobuf::int32 upid_;
  ::google::protobuf::int32 braveselecttype_;
  ::google::protobuf::int32 bravepasstype_;
  ::google::protobuf::int32 bravephase_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_battle_2eproto();
  friend void protobuf_AssignDesc_battle_2eproto();
  friend void protobuf_ShutdownFile_battle_2eproto();
  
  void InitAsDefaultInstance();
  static FreshReplyInfo* default_instance_;
};
// -------------------------------------------------------------------

class iconinfo : public ::google::protobuf::Message {
 public:
  iconinfo();
  virtual ~iconinfo();
  
  iconinfo(const iconinfo& from);
  
  inline iconinfo& operator=(const iconinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const iconinfo& default_instance();
  
  void Swap(iconinfo* other);
  
  // implements Message ----------------------------------------------
  
  iconinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const iconinfo& from);
  void MergeFrom(const iconinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string head = 3;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 3;
  inline const ::std::string& head() const;
  inline void set_head(const ::std::string& value);
  inline void set_head(const char* value);
  inline void set_head(const char* value, size_t size);
  inline ::std::string* mutable_head();
  inline ::std::string* release_head();
  
  // optional string guildName = 4;
  inline bool has_guildname() const;
  inline void clear_guildname();
  static const int kGuildNameFieldNumber = 4;
  inline const ::std::string& guildname() const;
  inline void set_guildname(const ::std::string& value);
  inline void set_guildname(const char* value);
  inline void set_guildname(const char* value, size_t size);
  inline ::std::string* mutable_guildname();
  inline ::std::string* release_guildname();
  
  // optional string serverName = 5;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 5;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  
  // optional string playerid = 6;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 6;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 power = 7;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 7;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);
  
  // optional int32 headFrame = 8;
  inline bool has_headframe() const;
  inline void clear_headframe();
  static const int kHeadFrameFieldNumber = 8;
  inline ::google::protobuf::int32 headframe() const;
  inline void set_headframe(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.battle.iconinfo)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_guildname();
  inline void clear_has_guildname();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_headframe();
  inline void clear_has_headframe();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* head_;
  ::std::string* guildname_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 power_;
  ::std::string* servername_;
  ::std::string* playerid_;
  ::google::protobuf::int32 headframe_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_battle_2eproto();
  friend void protobuf_AssignDesc_battle_2eproto();
  friend void protobuf_ShutdownFile_battle_2eproto();
  
  void InitAsDefaultInstance();
  static iconinfo* default_instance_;
};
// -------------------------------------------------------------------

class SetLineupTemplate : public ::google::protobuf::Message {
 public:
  SetLineupTemplate();
  virtual ~SetLineupTemplate();
  
  SetLineupTemplate(const SetLineupTemplate& from);
  
  inline SetLineupTemplate& operator=(const SetLineupTemplate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLineupTemplate& default_instance();
  
  void Swap(SetLineupTemplate* other);
  
  // implements Message ----------------------------------------------
  
  SetLineupTemplate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetLineupTemplate& from);
  void MergeFrom(const SetLineupTemplate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.common.LineupTemplate lineup = 1;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 1;
  inline const ::protobuf::common::LineupTemplate& lineup(int index) const;
  inline ::protobuf::common::LineupTemplate* mutable_lineup(int index);
  inline ::protobuf::common::LineupTemplate* add_lineup();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
      lineup() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
      mutable_lineup();
  
  // @@protoc_insertion_point(class_scope:protobuf.battle.SetLineupTemplate)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate > lineup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_battle_2eproto();
  friend void protobuf_AssignDesc_battle_2eproto();
  friend void protobuf_ShutdownFile_battle_2eproto();
  
  void InitAsDefaultInstance();
  static SetLineupTemplate* default_instance_;
};
// -------------------------------------------------------------------

class BattleRequest : public ::google::protobuf::Message {
 public:
  BattleRequest();
  virtual ~BattleRequest();
  
  BattleRequest(const BattleRequest& from);
  
  inline BattleRequest& operator=(const BattleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleRequest& default_instance();
  
  void Swap(BattleRequest* other);
  
  // implements Message ----------------------------------------------
  
  BattleRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleRequest& from);
  void MergeFrom(const BattleRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string beAttackId = 2;
  inline bool has_beattackid() const;
  inline void clear_beattackid();
  static const int kBeAttackIdFieldNumber = 2;
  inline const ::std::string& beattackid() const;
  inline void set_beattackid(const ::std::string& value);
  inline void set_beattackid(const char* value);
  inline void set_beattackid(const char* value, size_t size);
  inline ::std::string* mutable_beattackid();
  inline ::std::string* release_beattackid();
  
  // optional bool needLineup = 3;
  inline bool has_needlineup() const;
  inline void clear_needlineup();
  static const int kNeedLineupFieldNumber = 3;
  inline bool needlineup() const;
  inline void set_needlineup(bool value);
  
  // @@protoc_insertion_point(class_scope:protobuf.battle.BattleRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_beattackid();
  inline void clear_has_beattackid();
  inline void set_has_needlineup();
  inline void clear_has_needlineup();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* beattackid_;
  ::google::protobuf::int32 type_;
  bool needlineup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_battle_2eproto();
  friend void protobuf_AssignDesc_battle_2eproto();
  friend void protobuf_ShutdownFile_battle_2eproto();
  
  void InitAsDefaultInstance();
  static BattleRequest* default_instance_;
};
// -------------------------------------------------------------------

class BattleInfo : public ::google::protobuf::Message {
 public:
  BattleInfo();
  virtual ~BattleInfo();
  
  BattleInfo(const BattleInfo& from);
  
  inline BattleInfo& operator=(const BattleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleInfo& default_instance();
  
  void Swap(BattleInfo* other);
  
  // implements Message ----------------------------------------------
  
  BattleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleInfo& from);
  void MergeFrom(const BattleInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int64 randseed = 2;
  inline bool has_randseed() const;
  inline void clear_randseed();
  static const int kRandseedFieldNumber = 2;
  inline ::google::protobuf::int64 randseed() const;
  inline void set_randseed(::google::protobuf::int64 value);
  
  // optional string enemyid = 3;
  inline bool has_enemyid() const;
  inline void clear_enemyid();
  static const int kEnemyidFieldNumber = 3;
  inline const ::std::string& enemyid() const;
  inline void set_enemyid(const ::std::string& value);
  inline void set_enemyid(const char* value);
  inline void set_enemyid(const char* value, size_t size);
  inline ::std::string* mutable_enemyid();
  inline ::std::string* release_enemyid();
  
  // optional string teamName = 4;
  inline bool has_teamname() const;
  inline void clear_teamname();
  static const int kTeamNameFieldNumber = 4;
  inline const ::std::string& teamname() const;
  inline void set_teamname(const ::std::string& value);
  inline void set_teamname(const char* value);
  inline void set_teamname(const char* value, size_t size);
  inline ::std::string* mutable_teamname();
  inline ::std::string* release_teamname();
  
  // repeated .protobuf.common.LineupDetail enemylinup = 5;
  inline int enemylinup_size() const;
  inline void clear_enemylinup();
  static const int kEnemylinupFieldNumber = 5;
  inline const ::protobuf::common::LineupDetail& enemylinup(int index) const;
  inline ::protobuf::common::LineupDetail* mutable_enemylinup(int index);
  inline ::protobuf::common::LineupDetail* add_enemylinup();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupDetail >&
      enemylinup() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupDetail >*
      mutable_enemylinup();
  
  // repeated .protobuf.battle.iconinfo showinfo = 6;
  inline int showinfo_size() const;
  inline void clear_showinfo();
  static const int kShowinfoFieldNumber = 6;
  inline const ::protobuf::battle::iconinfo& showinfo(int index) const;
  inline ::protobuf::battle::iconinfo* mutable_showinfo(int index);
  inline ::protobuf::battle::iconinfo* add_showinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::battle::iconinfo >&
      showinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::battle::iconinfo >*
      mutable_showinfo();
  
  // repeated .protobuf.common.KVint3264 enemyblood = 7;
  inline int enemyblood_size() const;
  inline void clear_enemyblood();
  static const int kEnemybloodFieldNumber = 7;
  inline const ::protobuf::common::KVint3264& enemyblood(int index) const;
  inline ::protobuf::common::KVint3264* mutable_enemyblood(int index);
  inline ::protobuf::common::KVint3264* add_enemyblood();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
      enemyblood() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
      mutable_enemyblood();
  
  // repeated .protobuf.common.KVint3264 herohps = 8;
  inline int herohps_size() const;
  inline void clear_herohps();
  static const int kHerohpsFieldNumber = 8;
  inline const ::protobuf::common::KVint3264& herohps(int index) const;
  inline ::protobuf::common::KVint3264* mutable_herohps(int index);
  inline ::protobuf::common::KVint3264* add_herohps();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
      herohps() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
      mutable_herohps();
  
  // @@protoc_insertion_point(class_scope:protobuf.battle.BattleInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_randseed();
  inline void clear_has_randseed();
  inline void set_has_enemyid();
  inline void clear_has_enemyid();
  inline void set_has_teamname();
  inline void clear_has_teamname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 randseed_;
  ::std::string* enemyid_;
  ::std::string* teamname_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupDetail > enemylinup_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::battle::iconinfo > showinfo_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 > enemyblood_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 > herohps_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_battle_2eproto();
  friend void protobuf_AssignDesc_battle_2eproto();
  friend void protobuf_ShutdownFile_battle_2eproto();
  
  void InitAsDefaultInstance();
  static BattleInfo* default_instance_;
};
// -------------------------------------------------------------------

class BattleStart : public ::google::protobuf::Message {
 public:
  BattleStart();
  virtual ~BattleStart();
  
  BattleStart(const BattleStart& from);
  
  inline BattleStart& operator=(const BattleStart& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleStart& default_instance();
  
  void Swap(BattleStart* other);
  
  // implements Message ----------------------------------------------
  
  BattleStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleStart& from);
  void MergeFrom(const BattleStart& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string enemyId = 2;
  inline bool has_enemyid() const;
  inline void clear_enemyid();
  static const int kEnemyIdFieldNumber = 2;
  inline const ::std::string& enemyid() const;
  inline void set_enemyid(const ::std::string& value);
  inline void set_enemyid(const char* value);
  inline void set_enemyid(const char* value, size_t size);
  inline ::std::string* mutable_enemyid();
  inline ::std::string* release_enemyid();
  
  // required bool result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline bool result() const;
  inline void set_result(bool value);
  
  // required string sign = 4;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 4;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  
  // repeated int64 damage = 5;
  inline int damage_size() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 5;
  inline ::google::protobuf::int64 damage(int index) const;
  inline void set_damage(int index, ::google::protobuf::int64 value);
  inline void add_damage(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      damage() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_damage();
  
  // repeated int64 maxhp = 6;
  inline int maxhp_size() const;
  inline void clear_maxhp();
  static const int kMaxhpFieldNumber = 6;
  inline ::google::protobuf::int64 maxhp(int index) const;
  inline void set_maxhp(int index, ::google::protobuf::int64 value);
  inline void add_maxhp(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      maxhp() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_maxhp();
  
  // optional int64 mydamage = 11;
  inline bool has_mydamage() const;
  inline void clear_mydamage();
  static const int kMydamageFieldNumber = 11;
  inline ::google::protobuf::int64 mydamage() const;
  inline void set_mydamage(::google::protobuf::int64 value);
  
  // optional int32 lineupindex = 7;
  inline bool has_lineupindex() const;
  inline void clear_lineupindex();
  static const int kLineupindexFieldNumber = 7;
  inline ::google::protobuf::int32 lineupindex() const;
  inline void set_lineupindex(::google::protobuf::int32 value);
  
  // repeated .protobuf.common.KVint3264 lineupblood = 8;
  inline int lineupblood_size() const;
  inline void clear_lineupblood();
  static const int kLineupbloodFieldNumber = 8;
  inline const ::protobuf::common::KVint3264& lineupblood(int index) const;
  inline ::protobuf::common::KVint3264* mutable_lineupblood(int index);
  inline ::protobuf::common::KVint3264* add_lineupblood();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
      lineupblood() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
      mutable_lineupblood();
  
  // optional int32 lineuppet = 9;
  inline bool has_lineuppet() const;
  inline void clear_lineuppet();
  static const int kLineuppetFieldNumber = 9;
  inline ::google::protobuf::int32 lineuppet() const;
  inline void set_lineuppet(::google::protobuf::int32 value);
  
  // optional int32 attackCnt = 10;
  inline bool has_attackcnt() const;
  inline void clear_attackcnt();
  static const int kAttackCntFieldNumber = 10;
  inline ::google::protobuf::int32 attackcnt() const;
  inline void set_attackcnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.battle.BattleStart)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enemyid();
  inline void clear_has_enemyid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_mydamage();
  inline void clear_has_mydamage();
  inline void set_has_lineupindex();
  inline void clear_has_lineupindex();
  inline void set_has_lineuppet();
  inline void clear_has_lineuppet();
  inline void set_has_attackcnt();
  inline void clear_has_attackcnt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* enemyid_;
  ::google::protobuf::int32 type_;
  bool result_;
  ::std::string* sign_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > damage_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > maxhp_;
  ::google::protobuf::int64 mydamage_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 > lineupblood_;
  ::google::protobuf::int32 lineupindex_;
  ::google::protobuf::int32 lineuppet_;
  ::google::protobuf::int32 attackcnt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_battle_2eproto();
  friend void protobuf_AssignDesc_battle_2eproto();
  friend void protobuf_ShutdownFile_battle_2eproto();
  
  void InitAsDefaultInstance();
  static BattleStart* default_instance_;
};
// -------------------------------------------------------------------

class BattleEnd : public ::google::protobuf::Message {
 public:
  BattleEnd();
  virtual ~BattleEnd();
  
  BattleEnd(const BattleEnd& from);
  
  inline BattleEnd& operator=(const BattleEnd& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleEnd& default_instance();
  
  void Swap(BattleEnd* other);
  
  // implements Message ----------------------------------------------
  
  BattleEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleEnd& from);
  void MergeFrom(const BattleEnd& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string enemyId = 2;
  inline bool has_enemyid() const;
  inline void clear_enemyid();
  static const int kEnemyIdFieldNumber = 2;
  inline const ::std::string& enemyid() const;
  inline void set_enemyid(const ::std::string& value);
  inline void set_enemyid(const char* value);
  inline void set_enemyid(const char* value, size_t size);
  inline ::std::string* mutable_enemyid();
  inline ::std::string* release_enemyid();
  
  // repeated .protobuf.common.KVint3232 rewards = 3;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 3;
  inline const ::protobuf::common::KVint3232& rewards(int index) const;
  inline ::protobuf::common::KVint3232* mutable_rewards(int index);
  inline ::protobuf::common::KVint3232* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
      mutable_rewards();
  
  // repeated string points = 4;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 4;
  inline const ::std::string& points(int index) const;
  inline ::std::string* mutable_points(int index);
  inline void set_points(int index, const ::std::string& value);
  inline void set_points(int index, const char* value);
  inline void set_points(int index, const char* value, size_t size);
  inline ::std::string* add_points();
  inline void add_points(const ::std::string& value);
  inline void add_points(const char* value);
  inline void add_points(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& points() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_points();
  
  // @@protoc_insertion_point(class_scope:protobuf.battle.BattleEnd)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enemyid();
  inline void clear_has_enemyid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* enemyid_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 > rewards_;
  ::google::protobuf::RepeatedPtrField< ::std::string> points_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_battle_2eproto();
  friend void protobuf_AssignDesc_battle_2eproto();
  friend void protobuf_ShutdownFile_battle_2eproto();
  
  void InitAsDefaultInstance();
  static BattleEnd* default_instance_;
};
// ===================================================================


// ===================================================================

// FreshReplyInfo

// required int32 type = 1;
inline bool FreshReplyInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FreshReplyInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FreshReplyInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FreshReplyInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FreshReplyInfo::type() const {
  return type_;
}
inline void FreshReplyInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .protobuf.common.KVint3232 carbonDayCnt = 2;
inline int FreshReplyInfo::carbondaycnt_size() const {
  return carbondaycnt_.size();
}
inline void FreshReplyInfo::clear_carbondaycnt() {
  carbondaycnt_.Clear();
}
inline const ::protobuf::common::KVint3232& FreshReplyInfo::carbondaycnt(int index) const {
  return carbondaycnt_.Get(index);
}
inline ::protobuf::common::KVint3232* FreshReplyInfo::mutable_carbondaycnt(int index) {
  return carbondaycnt_.Mutable(index);
}
inline ::protobuf::common::KVint3232* FreshReplyInfo::add_carbondaycnt() {
  return carbondaycnt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
FreshReplyInfo::carbondaycnt() const {
  return carbondaycnt_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
FreshReplyInfo::mutable_carbondaycnt() {
  return &carbondaycnt_;
}

// repeated .protobuf.common.Id32 carbonPass = 5;
inline int FreshReplyInfo::carbonpass_size() const {
  return carbonpass_.size();
}
inline void FreshReplyInfo::clear_carbonpass() {
  carbonpass_.Clear();
}
inline const ::protobuf::common::Id32& FreshReplyInfo::carbonpass(int index) const {
  return carbonpass_.Get(index);
}
inline ::protobuf::common::Id32* FreshReplyInfo::mutable_carbonpass(int index) {
  return carbonpass_.Mutable(index);
}
inline ::protobuf::common::Id32* FreshReplyInfo::add_carbonpass() {
  return carbonpass_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Id32 >&
FreshReplyInfo::carbonpass() const {
  return carbonpass_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Id32 >*
FreshReplyInfo::mutable_carbonpass() {
  return &carbonpass_;
}

// optional bool isOpenBrave = 3;
inline bool FreshReplyInfo::has_isopenbrave() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FreshReplyInfo::set_has_isopenbrave() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FreshReplyInfo::clear_has_isopenbrave() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FreshReplyInfo::clear_isopenbrave() {
  isopenbrave_ = false;
  clear_has_isopenbrave();
}
inline bool FreshReplyInfo::isopenbrave() const {
  return isopenbrave_;
}
inline void FreshReplyInfo::set_isopenbrave(bool value) {
  set_has_isopenbrave();
  isopenbrave_ = value;
}

// optional int64 nextFreshTime = 4;
inline bool FreshReplyInfo::has_nextfreshtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FreshReplyInfo::set_has_nextfreshtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FreshReplyInfo::clear_has_nextfreshtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FreshReplyInfo::clear_nextfreshtime() {
  nextfreshtime_ = GOOGLE_LONGLONG(0);
  clear_has_nextfreshtime();
}
inline ::google::protobuf::int64 FreshReplyInfo::nextfreshtime() const {
  return nextfreshtime_;
}
inline void FreshReplyInfo::set_nextfreshtime(::google::protobuf::int64 value) {
  set_has_nextfreshtime();
  nextfreshtime_ = value;
}

// optional int32 upId = 6;
inline bool FreshReplyInfo::has_upid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FreshReplyInfo::set_has_upid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FreshReplyInfo::clear_has_upid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FreshReplyInfo::clear_upid() {
  upid_ = 0;
  clear_has_upid();
}
inline ::google::protobuf::int32 FreshReplyInfo::upid() const {
  return upid_;
}
inline void FreshReplyInfo::set_upid(::google::protobuf::int32 value) {
  set_has_upid();
  upid_ = value;
}

// optional int32 braveSelectType = 7;
inline bool FreshReplyInfo::has_braveselecttype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FreshReplyInfo::set_has_braveselecttype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FreshReplyInfo::clear_has_braveselecttype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FreshReplyInfo::clear_braveselecttype() {
  braveselecttype_ = 0;
  clear_has_braveselecttype();
}
inline ::google::protobuf::int32 FreshReplyInfo::braveselecttype() const {
  return braveselecttype_;
}
inline void FreshReplyInfo::set_braveselecttype(::google::protobuf::int32 value) {
  set_has_braveselecttype();
  braveselecttype_ = value;
}

// optional int32 bravePassType = 8;
inline bool FreshReplyInfo::has_bravepasstype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FreshReplyInfo::set_has_bravepasstype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FreshReplyInfo::clear_has_bravepasstype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FreshReplyInfo::clear_bravepasstype() {
  bravepasstype_ = 0;
  clear_has_bravepasstype();
}
inline ::google::protobuf::int32 FreshReplyInfo::bravepasstype() const {
  return bravepasstype_;
}
inline void FreshReplyInfo::set_bravepasstype(::google::protobuf::int32 value) {
  set_has_bravepasstype();
  bravepasstype_ = value;
}

// optional int32 bravePhase = 9;
inline bool FreshReplyInfo::has_bravephase() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FreshReplyInfo::set_has_bravephase() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FreshReplyInfo::clear_has_bravephase() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FreshReplyInfo::clear_bravephase() {
  bravephase_ = 0;
  clear_has_bravephase();
}
inline ::google::protobuf::int32 FreshReplyInfo::bravephase() const {
  return bravephase_;
}
inline void FreshReplyInfo::set_bravephase(::google::protobuf::int32 value) {
  set_has_bravephase();
  bravephase_ = value;
}

// -------------------------------------------------------------------

// iconinfo

// required int32 level = 1;
inline bool iconinfo::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iconinfo::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iconinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iconinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 iconinfo::level() const {
  return level_;
}
inline void iconinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string name = 2;
inline bool iconinfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iconinfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iconinfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iconinfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& iconinfo::name() const {
  return *name_;
}
inline void iconinfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* iconinfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string head = 3;
inline bool iconinfo::has_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iconinfo::set_has_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iconinfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iconinfo::clear_head() {
  if (head_ != &::google::protobuf::internal::kEmptyString) {
    head_->clear();
  }
  clear_has_head();
}
inline const ::std::string& iconinfo::head() const {
  return *head_;
}
inline void iconinfo::set_head(const ::std::string& value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value, size_t size) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_head() {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  return head_;
}
inline ::std::string* iconinfo::release_head() {
  clear_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_;
    head_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string guildName = 4;
inline bool iconinfo::has_guildname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iconinfo::set_has_guildname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void iconinfo::clear_has_guildname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void iconinfo::clear_guildname() {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    guildname_->clear();
  }
  clear_has_guildname();
}
inline const ::std::string& iconinfo::guildname() const {
  return *guildname_;
}
inline void iconinfo::set_guildname(const ::std::string& value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void iconinfo::set_guildname(const char* value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void iconinfo::set_guildname(const char* value, size_t size) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_guildname() {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  return guildname_;
}
inline ::std::string* iconinfo::release_guildname() {
  clear_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guildname_;
    guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string serverName = 5;
inline bool iconinfo::has_servername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void iconinfo::set_has_servername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void iconinfo::clear_has_servername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void iconinfo::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& iconinfo::servername() const {
  return *servername_;
}
inline void iconinfo::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void iconinfo::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void iconinfo::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* iconinfo::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string playerid = 6;
inline bool iconinfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void iconinfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void iconinfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void iconinfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& iconinfo::playerid() const {
  return *playerid_;
}
inline void iconinfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* iconinfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 power = 7;
inline bool iconinfo::has_power() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void iconinfo::set_has_power() {
  _has_bits_[0] |= 0x00000040u;
}
inline void iconinfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void iconinfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 iconinfo::power() const {
  return power_;
}
inline void iconinfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 headFrame = 8;
inline bool iconinfo::has_headframe() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void iconinfo::set_has_headframe() {
  _has_bits_[0] |= 0x00000080u;
}
inline void iconinfo::clear_has_headframe() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void iconinfo::clear_headframe() {
  headframe_ = 0;
  clear_has_headframe();
}
inline ::google::protobuf::int32 iconinfo::headframe() const {
  return headframe_;
}
inline void iconinfo::set_headframe(::google::protobuf::int32 value) {
  set_has_headframe();
  headframe_ = value;
}

// -------------------------------------------------------------------

// SetLineupTemplate

// repeated .protobuf.common.LineupTemplate lineup = 1;
inline int SetLineupTemplate::lineup_size() const {
  return lineup_.size();
}
inline void SetLineupTemplate::clear_lineup() {
  lineup_.Clear();
}
inline const ::protobuf::common::LineupTemplate& SetLineupTemplate::lineup(int index) const {
  return lineup_.Get(index);
}
inline ::protobuf::common::LineupTemplate* SetLineupTemplate::mutable_lineup(int index) {
  return lineup_.Mutable(index);
}
inline ::protobuf::common::LineupTemplate* SetLineupTemplate::add_lineup() {
  return lineup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
SetLineupTemplate::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
SetLineupTemplate::mutable_lineup() {
  return &lineup_;
}

// -------------------------------------------------------------------

// BattleRequest

// required int32 type = 1;
inline bool BattleRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleRequest::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BattleRequest::type() const {
  return type_;
}
inline void BattleRequest::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string beAttackId = 2;
inline bool BattleRequest::has_beattackid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleRequest::set_has_beattackid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleRequest::clear_has_beattackid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleRequest::clear_beattackid() {
  if (beattackid_ != &::google::protobuf::internal::kEmptyString) {
    beattackid_->clear();
  }
  clear_has_beattackid();
}
inline const ::std::string& BattleRequest::beattackid() const {
  return *beattackid_;
}
inline void BattleRequest::set_beattackid(const ::std::string& value) {
  set_has_beattackid();
  if (beattackid_ == &::google::protobuf::internal::kEmptyString) {
    beattackid_ = new ::std::string;
  }
  beattackid_->assign(value);
}
inline void BattleRequest::set_beattackid(const char* value) {
  set_has_beattackid();
  if (beattackid_ == &::google::protobuf::internal::kEmptyString) {
    beattackid_ = new ::std::string;
  }
  beattackid_->assign(value);
}
inline void BattleRequest::set_beattackid(const char* value, size_t size) {
  set_has_beattackid();
  if (beattackid_ == &::google::protobuf::internal::kEmptyString) {
    beattackid_ = new ::std::string;
  }
  beattackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleRequest::mutable_beattackid() {
  set_has_beattackid();
  if (beattackid_ == &::google::protobuf::internal::kEmptyString) {
    beattackid_ = new ::std::string;
  }
  return beattackid_;
}
inline ::std::string* BattleRequest::release_beattackid() {
  clear_has_beattackid();
  if (beattackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beattackid_;
    beattackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool needLineup = 3;
inline bool BattleRequest::has_needlineup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleRequest::set_has_needlineup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleRequest::clear_has_needlineup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleRequest::clear_needlineup() {
  needlineup_ = false;
  clear_has_needlineup();
}
inline bool BattleRequest::needlineup() const {
  return needlineup_;
}
inline void BattleRequest::set_needlineup(bool value) {
  set_has_needlineup();
  needlineup_ = value;
}

// -------------------------------------------------------------------

// BattleInfo

// required int32 type = 1;
inline bool BattleInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BattleInfo::type() const {
  return type_;
}
inline void BattleInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int64 randseed = 2;
inline bool BattleInfo::has_randseed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleInfo::set_has_randseed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleInfo::clear_has_randseed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleInfo::clear_randseed() {
  randseed_ = GOOGLE_LONGLONG(0);
  clear_has_randseed();
}
inline ::google::protobuf::int64 BattleInfo::randseed() const {
  return randseed_;
}
inline void BattleInfo::set_randseed(::google::protobuf::int64 value) {
  set_has_randseed();
  randseed_ = value;
}

// optional string enemyid = 3;
inline bool BattleInfo::has_enemyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleInfo::set_has_enemyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleInfo::clear_has_enemyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleInfo::clear_enemyid() {
  if (enemyid_ != &::google::protobuf::internal::kEmptyString) {
    enemyid_->clear();
  }
  clear_has_enemyid();
}
inline const ::std::string& BattleInfo::enemyid() const {
  return *enemyid_;
}
inline void BattleInfo::set_enemyid(const ::std::string& value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleInfo::set_enemyid(const char* value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleInfo::set_enemyid(const char* value, size_t size) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleInfo::mutable_enemyid() {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  return enemyid_;
}
inline ::std::string* BattleInfo::release_enemyid() {
  clear_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enemyid_;
    enemyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string teamName = 4;
inline bool BattleInfo::has_teamname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleInfo::set_has_teamname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleInfo::clear_has_teamname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleInfo::clear_teamname() {
  if (teamname_ != &::google::protobuf::internal::kEmptyString) {
    teamname_->clear();
  }
  clear_has_teamname();
}
inline const ::std::string& BattleInfo::teamname() const {
  return *teamname_;
}
inline void BattleInfo::set_teamname(const ::std::string& value) {
  set_has_teamname();
  if (teamname_ == &::google::protobuf::internal::kEmptyString) {
    teamname_ = new ::std::string;
  }
  teamname_->assign(value);
}
inline void BattleInfo::set_teamname(const char* value) {
  set_has_teamname();
  if (teamname_ == &::google::protobuf::internal::kEmptyString) {
    teamname_ = new ::std::string;
  }
  teamname_->assign(value);
}
inline void BattleInfo::set_teamname(const char* value, size_t size) {
  set_has_teamname();
  if (teamname_ == &::google::protobuf::internal::kEmptyString) {
    teamname_ = new ::std::string;
  }
  teamname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleInfo::mutable_teamname() {
  set_has_teamname();
  if (teamname_ == &::google::protobuf::internal::kEmptyString) {
    teamname_ = new ::std::string;
  }
  return teamname_;
}
inline ::std::string* BattleInfo::release_teamname() {
  clear_has_teamname();
  if (teamname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = teamname_;
    teamname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .protobuf.common.LineupDetail enemylinup = 5;
inline int BattleInfo::enemylinup_size() const {
  return enemylinup_.size();
}
inline void BattleInfo::clear_enemylinup() {
  enemylinup_.Clear();
}
inline const ::protobuf::common::LineupDetail& BattleInfo::enemylinup(int index) const {
  return enemylinup_.Get(index);
}
inline ::protobuf::common::LineupDetail* BattleInfo::mutable_enemylinup(int index) {
  return enemylinup_.Mutable(index);
}
inline ::protobuf::common::LineupDetail* BattleInfo::add_enemylinup() {
  return enemylinup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupDetail >&
BattleInfo::enemylinup() const {
  return enemylinup_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupDetail >*
BattleInfo::mutable_enemylinup() {
  return &enemylinup_;
}

// repeated .protobuf.battle.iconinfo showinfo = 6;
inline int BattleInfo::showinfo_size() const {
  return showinfo_.size();
}
inline void BattleInfo::clear_showinfo() {
  showinfo_.Clear();
}
inline const ::protobuf::battle::iconinfo& BattleInfo::showinfo(int index) const {
  return showinfo_.Get(index);
}
inline ::protobuf::battle::iconinfo* BattleInfo::mutable_showinfo(int index) {
  return showinfo_.Mutable(index);
}
inline ::protobuf::battle::iconinfo* BattleInfo::add_showinfo() {
  return showinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::battle::iconinfo >&
BattleInfo::showinfo() const {
  return showinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::battle::iconinfo >*
BattleInfo::mutable_showinfo() {
  return &showinfo_;
}

// repeated .protobuf.common.KVint3264 enemyblood = 7;
inline int BattleInfo::enemyblood_size() const {
  return enemyblood_.size();
}
inline void BattleInfo::clear_enemyblood() {
  enemyblood_.Clear();
}
inline const ::protobuf::common::KVint3264& BattleInfo::enemyblood(int index) const {
  return enemyblood_.Get(index);
}
inline ::protobuf::common::KVint3264* BattleInfo::mutable_enemyblood(int index) {
  return enemyblood_.Mutable(index);
}
inline ::protobuf::common::KVint3264* BattleInfo::add_enemyblood() {
  return enemyblood_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
BattleInfo::enemyblood() const {
  return enemyblood_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
BattleInfo::mutable_enemyblood() {
  return &enemyblood_;
}

// repeated .protobuf.common.KVint3264 herohps = 8;
inline int BattleInfo::herohps_size() const {
  return herohps_.size();
}
inline void BattleInfo::clear_herohps() {
  herohps_.Clear();
}
inline const ::protobuf::common::KVint3264& BattleInfo::herohps(int index) const {
  return herohps_.Get(index);
}
inline ::protobuf::common::KVint3264* BattleInfo::mutable_herohps(int index) {
  return herohps_.Mutable(index);
}
inline ::protobuf::common::KVint3264* BattleInfo::add_herohps() {
  return herohps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
BattleInfo::herohps() const {
  return herohps_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
BattleInfo::mutable_herohps() {
  return &herohps_;
}

// -------------------------------------------------------------------

// BattleStart

// required int32 type = 1;
inline bool BattleStart::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleStart::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleStart::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleStart::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BattleStart::type() const {
  return type_;
}
inline void BattleStart::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string enemyId = 2;
inline bool BattleStart::has_enemyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleStart::set_has_enemyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleStart::clear_has_enemyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleStart::clear_enemyid() {
  if (enemyid_ != &::google::protobuf::internal::kEmptyString) {
    enemyid_->clear();
  }
  clear_has_enemyid();
}
inline const ::std::string& BattleStart::enemyid() const {
  return *enemyid_;
}
inline void BattleStart::set_enemyid(const ::std::string& value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleStart::set_enemyid(const char* value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleStart::set_enemyid(const char* value, size_t size) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleStart::mutable_enemyid() {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  return enemyid_;
}
inline ::std::string* BattleStart::release_enemyid() {
  clear_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enemyid_;
    enemyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool result = 3;
inline bool BattleStart::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleStart::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleStart::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleStart::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool BattleStart::result() const {
  return result_;
}
inline void BattleStart::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// required string sign = 4;
inline bool BattleStart::has_sign() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleStart::set_has_sign() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleStart::clear_has_sign() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleStart::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& BattleStart::sign() const {
  return *sign_;
}
inline void BattleStart::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void BattleStart::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void BattleStart::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleStart::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* BattleStart::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int64 damage = 5;
inline int BattleStart::damage_size() const {
  return damage_.size();
}
inline void BattleStart::clear_damage() {
  damage_.Clear();
}
inline ::google::protobuf::int64 BattleStart::damage(int index) const {
  return damage_.Get(index);
}
inline void BattleStart::set_damage(int index, ::google::protobuf::int64 value) {
  damage_.Set(index, value);
}
inline void BattleStart::add_damage(::google::protobuf::int64 value) {
  damage_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
BattleStart::damage() const {
  return damage_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
BattleStart::mutable_damage() {
  return &damage_;
}

// repeated int64 maxhp = 6;
inline int BattleStart::maxhp_size() const {
  return maxhp_.size();
}
inline void BattleStart::clear_maxhp() {
  maxhp_.Clear();
}
inline ::google::protobuf::int64 BattleStart::maxhp(int index) const {
  return maxhp_.Get(index);
}
inline void BattleStart::set_maxhp(int index, ::google::protobuf::int64 value) {
  maxhp_.Set(index, value);
}
inline void BattleStart::add_maxhp(::google::protobuf::int64 value) {
  maxhp_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
BattleStart::maxhp() const {
  return maxhp_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
BattleStart::mutable_maxhp() {
  return &maxhp_;
}

// optional int64 mydamage = 11;
inline bool BattleStart::has_mydamage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleStart::set_has_mydamage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleStart::clear_has_mydamage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleStart::clear_mydamage() {
  mydamage_ = GOOGLE_LONGLONG(0);
  clear_has_mydamage();
}
inline ::google::protobuf::int64 BattleStart::mydamage() const {
  return mydamage_;
}
inline void BattleStart::set_mydamage(::google::protobuf::int64 value) {
  set_has_mydamage();
  mydamage_ = value;
}

// optional int32 lineupindex = 7;
inline bool BattleStart::has_lineupindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleStart::set_has_lineupindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleStart::clear_has_lineupindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleStart::clear_lineupindex() {
  lineupindex_ = 0;
  clear_has_lineupindex();
}
inline ::google::protobuf::int32 BattleStart::lineupindex() const {
  return lineupindex_;
}
inline void BattleStart::set_lineupindex(::google::protobuf::int32 value) {
  set_has_lineupindex();
  lineupindex_ = value;
}

// repeated .protobuf.common.KVint3264 lineupblood = 8;
inline int BattleStart::lineupblood_size() const {
  return lineupblood_.size();
}
inline void BattleStart::clear_lineupblood() {
  lineupblood_.Clear();
}
inline const ::protobuf::common::KVint3264& BattleStart::lineupblood(int index) const {
  return lineupblood_.Get(index);
}
inline ::protobuf::common::KVint3264* BattleStart::mutable_lineupblood(int index) {
  return lineupblood_.Mutable(index);
}
inline ::protobuf::common::KVint3264* BattleStart::add_lineupblood() {
  return lineupblood_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
BattleStart::lineupblood() const {
  return lineupblood_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
BattleStart::mutable_lineupblood() {
  return &lineupblood_;
}

// optional int32 lineuppet = 9;
inline bool BattleStart::has_lineuppet() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleStart::set_has_lineuppet() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleStart::clear_has_lineuppet() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleStart::clear_lineuppet() {
  lineuppet_ = 0;
  clear_has_lineuppet();
}
inline ::google::protobuf::int32 BattleStart::lineuppet() const {
  return lineuppet_;
}
inline void BattleStart::set_lineuppet(::google::protobuf::int32 value) {
  set_has_lineuppet();
  lineuppet_ = value;
}

// optional int32 attackCnt = 10;
inline bool BattleStart::has_attackcnt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleStart::set_has_attackcnt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleStart::clear_has_attackcnt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleStart::clear_attackcnt() {
  attackcnt_ = 0;
  clear_has_attackcnt();
}
inline ::google::protobuf::int32 BattleStart::attackcnt() const {
  return attackcnt_;
}
inline void BattleStart::set_attackcnt(::google::protobuf::int32 value) {
  set_has_attackcnt();
  attackcnt_ = value;
}

// -------------------------------------------------------------------

// BattleEnd

// required int32 type = 1;
inline bool BattleEnd::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleEnd::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleEnd::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleEnd::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BattleEnd::type() const {
  return type_;
}
inline void BattleEnd::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string enemyId = 2;
inline bool BattleEnd::has_enemyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleEnd::set_has_enemyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleEnd::clear_has_enemyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleEnd::clear_enemyid() {
  if (enemyid_ != &::google::protobuf::internal::kEmptyString) {
    enemyid_->clear();
  }
  clear_has_enemyid();
}
inline const ::std::string& BattleEnd::enemyid() const {
  return *enemyid_;
}
inline void BattleEnd::set_enemyid(const ::std::string& value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleEnd::set_enemyid(const char* value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleEnd::set_enemyid(const char* value, size_t size) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleEnd::mutable_enemyid() {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  return enemyid_;
}
inline ::std::string* BattleEnd::release_enemyid() {
  clear_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enemyid_;
    enemyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .protobuf.common.KVint3232 rewards = 3;
inline int BattleEnd::rewards_size() const {
  return rewards_.size();
}
inline void BattleEnd::clear_rewards() {
  rewards_.Clear();
}
inline const ::protobuf::common::KVint3232& BattleEnd::rewards(int index) const {
  return rewards_.Get(index);
}
inline ::protobuf::common::KVint3232* BattleEnd::mutable_rewards(int index) {
  return rewards_.Mutable(index);
}
inline ::protobuf::common::KVint3232* BattleEnd::add_rewards() {
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
BattleEnd::rewards() const {
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
BattleEnd::mutable_rewards() {
  return &rewards_;
}

// repeated string points = 4;
inline int BattleEnd::points_size() const {
  return points_.size();
}
inline void BattleEnd::clear_points() {
  points_.Clear();
}
inline const ::std::string& BattleEnd::points(int index) const {
  return points_.Get(index);
}
inline ::std::string* BattleEnd::mutable_points(int index) {
  return points_.Mutable(index);
}
inline void BattleEnd::set_points(int index, const ::std::string& value) {
  points_.Mutable(index)->assign(value);
}
inline void BattleEnd::set_points(int index, const char* value) {
  points_.Mutable(index)->assign(value);
}
inline void BattleEnd::set_points(int index, const char* value, size_t size) {
  points_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleEnd::add_points() {
  return points_.Add();
}
inline void BattleEnd::add_points(const ::std::string& value) {
  points_.Add()->assign(value);
}
inline void BattleEnd::add_points(const char* value) {
  points_.Add()->assign(value);
}
inline void BattleEnd::add_points(const char* value, size_t size) {
  points_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BattleEnd::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BattleEnd::mutable_points() {
  return &points_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace battle
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_battle_2eproto__INCLUDED
