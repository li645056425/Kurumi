// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: town.proto

#ifndef PROTOBUF_town_2eproto__INCLUDED
#define PROTOBUF_town_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace town {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_town_2eproto();
void protobuf_AssignDesc_town_2eproto();
void protobuf_ShutdownFile_town_2eproto();

class FreshReplyInfo;
class iconinfo;
class playerInfoList;
class BattleHistory;
class BattleHistoryList;
class NewBattleHistory;
class NewBattleHistoryList;

// ===================================================================

class FreshReplyInfo : public ::google::protobuf::Message {
 public:
  FreshReplyInfo();
  virtual ~FreshReplyInfo();
  
  FreshReplyInfo(const FreshReplyInfo& from);
  
  inline FreshReplyInfo& operator=(const FreshReplyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreshReplyInfo& default_instance();
  
  void Swap(FreshReplyInfo* other);
  
  // implements Message ----------------------------------------------
  
  FreshReplyInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FreshReplyInfo& from);
  void MergeFrom(const FreshReplyInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional int32 extid = 2;
  inline bool has_extid() const;
  inline void clear_extid();
  static const int kExtidFieldNumber = 2;
  inline ::google::protobuf::int32 extid() const;
  inline void set_extid(::google::protobuf::int32 value);
  
  // optional int32 carbonTowerh2ocount = 3;
  inline bool has_carbontowerh2ocount() const;
  inline void clear_carbontowerh2ocount();
  static const int kCarbonTowerh2OcountFieldNumber = 3;
  inline ::google::protobuf::int32 carbontowerh2ocount() const;
  inline void set_carbontowerh2ocount(::google::protobuf::int32 value);
  
  // optional int64 nextFreshTime = 4;
  inline bool has_nextfreshtime() const;
  inline void clear_nextfreshtime();
  static const int kNextFreshTimeFieldNumber = 4;
  inline ::google::protobuf::int64 nextfreshtime() const;
  inline void set_nextfreshtime(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.town.FreshReplyInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_extid();
  inline void clear_has_extid();
  inline void set_has_carbontowerh2ocount();
  inline void clear_has_carbontowerh2ocount();
  inline void set_has_nextfreshtime();
  inline void clear_has_nextfreshtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 extid_;
  ::google::protobuf::int64 nextfreshtime_;
  ::google::protobuf::int32 carbontowerh2ocount_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_town_2eproto();
  friend void protobuf_AssignDesc_town_2eproto();
  friend void protobuf_ShutdownFile_town_2eproto();
  
  void InitAsDefaultInstance();
  static FreshReplyInfo* default_instance_;
};
// -------------------------------------------------------------------

class iconinfo : public ::google::protobuf::Message {
 public:
  iconinfo();
  virtual ~iconinfo();
  
  iconinfo(const iconinfo& from);
  
  inline iconinfo& operator=(const iconinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const iconinfo& default_instance();
  
  void Swap(iconinfo* other);
  
  // implements Message ----------------------------------------------
  
  iconinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const iconinfo& from);
  void MergeFrom(const iconinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string head = 3;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 3;
  inline const ::std::string& head() const;
  inline void set_head(const ::std::string& value);
  inline void set_head(const char* value);
  inline void set_head(const char* value, size_t size);
  inline ::std::string* mutable_head();
  inline ::std::string* release_head();
  
  // optional string guildName = 4;
  inline bool has_guildname() const;
  inline void clear_guildname();
  static const int kGuildNameFieldNumber = 4;
  inline const ::std::string& guildname() const;
  inline void set_guildname(const ::std::string& value);
  inline void set_guildname(const char* value);
  inline void set_guildname(const char* value, size_t size);
  inline ::std::string* mutable_guildname();
  inline ::std::string* release_guildname();
  
  // optional int32 headFrame = 5;
  inline bool has_headframe() const;
  inline void clear_headframe();
  static const int kHeadFrameFieldNumber = 5;
  inline ::google::protobuf::int32 headframe() const;
  inline void set_headframe(::google::protobuf::int32 value);
  
  // optional string playerId = 6;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 6;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 serverId = 7;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 7;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.town.iconinfo)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_guildname();
  inline void clear_has_guildname();
  inline void set_has_headframe();
  inline void clear_has_headframe();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* head_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 headframe_;
  ::std::string* guildname_;
  ::std::string* playerid_;
  ::google::protobuf::int32 serverid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_town_2eproto();
  friend void protobuf_AssignDesc_town_2eproto();
  friend void protobuf_ShutdownFile_town_2eproto();
  
  void InitAsDefaultInstance();
  static iconinfo* default_instance_;
};
// -------------------------------------------------------------------

class playerInfoList : public ::google::protobuf::Message {
 public:
  playerInfoList();
  virtual ~playerInfoList();
  
  playerInfoList(const playerInfoList& from);
  
  inline playerInfoList& operator=(const playerInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const playerInfoList& default_instance();
  
  void Swap(playerInfoList* other);
  
  // implements Message ----------------------------------------------
  
  playerInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerInfoList& from);
  void MergeFrom(const playerInfoList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.town.iconinfo showinfo = 1;
  inline int showinfo_size() const;
  inline void clear_showinfo();
  static const int kShowinfoFieldNumber = 1;
  inline const ::protobuf::town::iconinfo& showinfo(int index) const;
  inline ::protobuf::town::iconinfo* mutable_showinfo(int index);
  inline ::protobuf::town::iconinfo* add_showinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::town::iconinfo >&
      showinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::town::iconinfo >*
      mutable_showinfo();
  
  // @@protoc_insertion_point(class_scope:protobuf.town.playerInfoList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::town::iconinfo > showinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_town_2eproto();
  friend void protobuf_AssignDesc_town_2eproto();
  friend void protobuf_ShutdownFile_town_2eproto();
  
  void InitAsDefaultInstance();
  static playerInfoList* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistory : public ::google::protobuf::Message {
 public:
  BattleHistory();
  virtual ~BattleHistory();
  
  BattleHistory(const BattleHistory& from);
  
  inline BattleHistory& operator=(const BattleHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleHistory& default_instance();
  
  void Swap(BattleHistory* other);
  
  // implements Message ----------------------------------------------
  
  BattleHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleHistory& from);
  void MergeFrom(const BattleHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string attackName = 1;
  inline bool has_attackname() const;
  inline void clear_attackname();
  static const int kAttackNameFieldNumber = 1;
  inline const ::std::string& attackname() const;
  inline void set_attackname(const ::std::string& value);
  inline void set_attackname(const char* value);
  inline void set_attackname(const char* value, size_t size);
  inline ::std::string* mutable_attackname();
  inline ::std::string* release_attackname();
  
  // required int32 attackLvl = 2;
  inline bool has_attacklvl() const;
  inline void clear_attacklvl();
  static const int kAttackLvlFieldNumber = 2;
  inline ::google::protobuf::int32 attacklvl() const;
  inline void set_attacklvl(::google::protobuf::int32 value);
  
  // required string attackHead = 3;
  inline bool has_attackhead() const;
  inline void clear_attackhead();
  static const int kAttackHeadFieldNumber = 3;
  inline const ::std::string& attackhead() const;
  inline void set_attackhead(const ::std::string& value);
  inline void set_attackhead(const char* value);
  inline void set_attackhead(const char* value, size_t size);
  inline ::std::string* mutable_attackhead();
  inline ::std::string* release_attackhead();
  
  // optional .protobuf.common.LineupDetail attacker = 4;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 4;
  inline const ::protobuf::common::LineupDetail& attacker() const;
  inline ::protobuf::common::LineupDetail* mutable_attacker();
  inline ::protobuf::common::LineupDetail* release_attacker();
  
  // required string attackId = 5;
  inline bool has_attackid() const;
  inline void clear_attackid();
  static const int kAttackIdFieldNumber = 5;
  inline const ::std::string& attackid() const;
  inline void set_attackid(const ::std::string& value);
  inline void set_attackid(const char* value);
  inline void set_attackid(const char* value, size_t size);
  inline ::std::string* mutable_attackid();
  inline ::std::string* release_attackid();
  
  // optional int32 defineid = 6;
  inline bool has_defineid() const;
  inline void clear_defineid();
  static const int kDefineidFieldNumber = 6;
  inline ::google::protobuf::int32 defineid() const;
  inline void set_defineid(::google::protobuf::int32 value);
  
  // required int64 seed = 7;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 7;
  inline ::google::protobuf::int64 seed() const;
  inline void set_seed(::google::protobuf::int64 value);
  
  // required int32 battletype = 8;
  inline bool has_battletype() const;
  inline void clear_battletype();
  static const int kBattletypeFieldNumber = 8;
  inline ::google::protobuf::int32 battletype() const;
  inline void set_battletype(::google::protobuf::int32 value);
  
  // required bool victory = 9;
  inline bool has_victory() const;
  inline void clear_victory();
  static const int kVictoryFieldNumber = 9;
  inline bool victory() const;
  inline void set_victory(bool value);
  
  // required int64 time = 10;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 10;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional int32 headFrame = 11;
  inline bool has_headframe() const;
  inline void clear_headframe();
  static const int kHeadFrameFieldNumber = 11;
  inline ::google::protobuf::int32 headframe() const;
  inline void set_headframe(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.town.BattleHistory)
 private:
  inline void set_has_attackname();
  inline void clear_has_attackname();
  inline void set_has_attacklvl();
  inline void clear_has_attacklvl();
  inline void set_has_attackhead();
  inline void clear_has_attackhead();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_attackid();
  inline void clear_has_attackid();
  inline void set_has_defineid();
  inline void clear_has_defineid();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_battletype();
  inline void clear_has_battletype();
  inline void set_has_victory();
  inline void clear_has_victory();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_headframe();
  inline void clear_has_headframe();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* attackname_;
  ::std::string* attackhead_;
  ::protobuf::common::LineupDetail* attacker_;
  ::google::protobuf::int32 attacklvl_;
  ::google::protobuf::int32 defineid_;
  ::std::string* attackid_;
  ::google::protobuf::int64 seed_;
  ::google::protobuf::int32 battletype_;
  bool victory_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 headframe_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_town_2eproto();
  friend void protobuf_AssignDesc_town_2eproto();
  friend void protobuf_ShutdownFile_town_2eproto();
  
  void InitAsDefaultInstance();
  static BattleHistory* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistoryList : public ::google::protobuf::Message {
 public:
  BattleHistoryList();
  virtual ~BattleHistoryList();
  
  BattleHistoryList(const BattleHistoryList& from);
  
  inline BattleHistoryList& operator=(const BattleHistoryList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleHistoryList& default_instance();
  
  void Swap(BattleHistoryList* other);
  
  // implements Message ----------------------------------------------
  
  BattleHistoryList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleHistoryList& from);
  void MergeFrom(const BattleHistoryList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.town.BattleHistory battles = 1;
  inline int battles_size() const;
  inline void clear_battles();
  static const int kBattlesFieldNumber = 1;
  inline const ::protobuf::town::BattleHistory& battles(int index) const;
  inline ::protobuf::town::BattleHistory* mutable_battles(int index);
  inline ::protobuf::town::BattleHistory* add_battles();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::town::BattleHistory >&
      battles() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::town::BattleHistory >*
      mutable_battles();
  
  // @@protoc_insertion_point(class_scope:protobuf.town.BattleHistoryList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::town::BattleHistory > battles_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_town_2eproto();
  friend void protobuf_AssignDesc_town_2eproto();
  friend void protobuf_ShutdownFile_town_2eproto();
  
  void InitAsDefaultInstance();
  static BattleHistoryList* default_instance_;
};
// -------------------------------------------------------------------

class NewBattleHistory : public ::google::protobuf::Message {
 public:
  NewBattleHistory();
  virtual ~NewBattleHistory();
  
  NewBattleHistory(const NewBattleHistory& from);
  
  inline NewBattleHistory& operator=(const NewBattleHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewBattleHistory& default_instance();
  
  void Swap(NewBattleHistory* other);
  
  // implements Message ----------------------------------------------
  
  NewBattleHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewBattleHistory& from);
  void MergeFrom(const NewBattleHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string attackName = 1;
  inline bool has_attackname() const;
  inline void clear_attackname();
  static const int kAttackNameFieldNumber = 1;
  inline const ::std::string& attackname() const;
  inline void set_attackname(const ::std::string& value);
  inline void set_attackname(const char* value);
  inline void set_attackname(const char* value, size_t size);
  inline ::std::string* mutable_attackname();
  inline ::std::string* release_attackname();
  
  // required int32 attackLvl = 2;
  inline bool has_attacklvl() const;
  inline void clear_attacklvl();
  static const int kAttackLvlFieldNumber = 2;
  inline ::google::protobuf::int32 attacklvl() const;
  inline void set_attacklvl(::google::protobuf::int32 value);
  
  // required string attackHead = 3;
  inline bool has_attackhead() const;
  inline void clear_attackhead();
  static const int kAttackHeadFieldNumber = 3;
  inline const ::std::string& attackhead() const;
  inline void set_attackhead(const ::std::string& value);
  inline void set_attackhead(const char* value);
  inline void set_attackhead(const char* value, size_t size);
  inline ::std::string* mutable_attackhead();
  inline ::std::string* release_attackhead();
  
  // required string id = 4;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 4;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string attackId = 5;
  inline bool has_attackid() const;
  inline void clear_attackid();
  static const int kAttackIdFieldNumber = 5;
  inline const ::std::string& attackid() const;
  inline void set_attackid(const ::std::string& value);
  inline void set_attackid(const char* value);
  inline void set_attackid(const char* value, size_t size);
  inline ::std::string* mutable_attackid();
  inline ::std::string* release_attackid();
  
  // required int32 battletype = 6;
  inline bool has_battletype() const;
  inline void clear_battletype();
  static const int kBattletypeFieldNumber = 6;
  inline ::google::protobuf::int32 battletype() const;
  inline void set_battletype(::google::protobuf::int32 value);
  
  // required bool victory = 7;
  inline bool has_victory() const;
  inline void clear_victory();
  static const int kVictoryFieldNumber = 7;
  inline bool victory() const;
  inline void set_victory(bool value);
  
  // required int64 time = 8;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 8;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // required int32 defineid = 9;
  inline bool has_defineid() const;
  inline void clear_defineid();
  static const int kDefineidFieldNumber = 9;
  inline ::google::protobuf::int32 defineid() const;
  inline void set_defineid(::google::protobuf::int32 value);
  
  // optional int32 headFrame = 10;
  inline bool has_headframe() const;
  inline void clear_headframe();
  static const int kHeadFrameFieldNumber = 10;
  inline ::google::protobuf::int32 headframe() const;
  inline void set_headframe(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.town.NewBattleHistory)
 private:
  inline void set_has_attackname();
  inline void clear_has_attackname();
  inline void set_has_attacklvl();
  inline void clear_has_attacklvl();
  inline void set_has_attackhead();
  inline void clear_has_attackhead();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_attackid();
  inline void clear_has_attackid();
  inline void set_has_battletype();
  inline void clear_has_battletype();
  inline void set_has_victory();
  inline void clear_has_victory();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_defineid();
  inline void clear_has_defineid();
  inline void set_has_headframe();
  inline void clear_has_headframe();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* attackname_;
  ::std::string* attackhead_;
  ::std::string* id_;
  ::google::protobuf::int32 attacklvl_;
  ::google::protobuf::int32 battletype_;
  ::std::string* attackid_;
  ::google::protobuf::int64 time_;
  bool victory_;
  ::google::protobuf::int32 defineid_;
  ::google::protobuf::int32 headframe_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_town_2eproto();
  friend void protobuf_AssignDesc_town_2eproto();
  friend void protobuf_ShutdownFile_town_2eproto();
  
  void InitAsDefaultInstance();
  static NewBattleHistory* default_instance_;
};
// -------------------------------------------------------------------

class NewBattleHistoryList : public ::google::protobuf::Message {
 public:
  NewBattleHistoryList();
  virtual ~NewBattleHistoryList();
  
  NewBattleHistoryList(const NewBattleHistoryList& from);
  
  inline NewBattleHistoryList& operator=(const NewBattleHistoryList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewBattleHistoryList& default_instance();
  
  void Swap(NewBattleHistoryList* other);
  
  // implements Message ----------------------------------------------
  
  NewBattleHistoryList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewBattleHistoryList& from);
  void MergeFrom(const NewBattleHistoryList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.town.NewBattleHistory battles = 1;
  inline int battles_size() const;
  inline void clear_battles();
  static const int kBattlesFieldNumber = 1;
  inline const ::protobuf::town::NewBattleHistory& battles(int index) const;
  inline ::protobuf::town::NewBattleHistory* mutable_battles(int index);
  inline ::protobuf::town::NewBattleHistory* add_battles();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::town::NewBattleHistory >&
      battles() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::town::NewBattleHistory >*
      mutable_battles();
  
  // @@protoc_insertion_point(class_scope:protobuf.town.NewBattleHistoryList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::town::NewBattleHistory > battles_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_town_2eproto();
  friend void protobuf_AssignDesc_town_2eproto();
  friend void protobuf_ShutdownFile_town_2eproto();
  
  void InitAsDefaultInstance();
  static NewBattleHistoryList* default_instance_;
};
// ===================================================================


// ===================================================================

// FreshReplyInfo

// required int32 type = 1;
inline bool FreshReplyInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FreshReplyInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FreshReplyInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FreshReplyInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FreshReplyInfo::type() const {
  return type_;
}
inline void FreshReplyInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 extid = 2;
inline bool FreshReplyInfo::has_extid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FreshReplyInfo::set_has_extid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FreshReplyInfo::clear_has_extid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FreshReplyInfo::clear_extid() {
  extid_ = 0;
  clear_has_extid();
}
inline ::google::protobuf::int32 FreshReplyInfo::extid() const {
  return extid_;
}
inline void FreshReplyInfo::set_extid(::google::protobuf::int32 value) {
  set_has_extid();
  extid_ = value;
}

// optional int32 carbonTowerh2ocount = 3;
inline bool FreshReplyInfo::has_carbontowerh2ocount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FreshReplyInfo::set_has_carbontowerh2ocount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FreshReplyInfo::clear_has_carbontowerh2ocount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FreshReplyInfo::clear_carbontowerh2ocount() {
  carbontowerh2ocount_ = 0;
  clear_has_carbontowerh2ocount();
}
inline ::google::protobuf::int32 FreshReplyInfo::carbontowerh2ocount() const {
  return carbontowerh2ocount_;
}
inline void FreshReplyInfo::set_carbontowerh2ocount(::google::protobuf::int32 value) {
  set_has_carbontowerh2ocount();
  carbontowerh2ocount_ = value;
}

// optional int64 nextFreshTime = 4;
inline bool FreshReplyInfo::has_nextfreshtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FreshReplyInfo::set_has_nextfreshtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FreshReplyInfo::clear_has_nextfreshtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FreshReplyInfo::clear_nextfreshtime() {
  nextfreshtime_ = GOOGLE_LONGLONG(0);
  clear_has_nextfreshtime();
}
inline ::google::protobuf::int64 FreshReplyInfo::nextfreshtime() const {
  return nextfreshtime_;
}
inline void FreshReplyInfo::set_nextfreshtime(::google::protobuf::int64 value) {
  set_has_nextfreshtime();
  nextfreshtime_ = value;
}

// -------------------------------------------------------------------

// iconinfo

// required int32 level = 1;
inline bool iconinfo::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iconinfo::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iconinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iconinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 iconinfo::level() const {
  return level_;
}
inline void iconinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string name = 2;
inline bool iconinfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iconinfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iconinfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iconinfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& iconinfo::name() const {
  return *name_;
}
inline void iconinfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* iconinfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string head = 3;
inline bool iconinfo::has_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iconinfo::set_has_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iconinfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iconinfo::clear_head() {
  if (head_ != &::google::protobuf::internal::kEmptyString) {
    head_->clear();
  }
  clear_has_head();
}
inline const ::std::string& iconinfo::head() const {
  return *head_;
}
inline void iconinfo::set_head(const ::std::string& value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value, size_t size) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_head() {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  return head_;
}
inline ::std::string* iconinfo::release_head() {
  clear_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_;
    head_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string guildName = 4;
inline bool iconinfo::has_guildname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iconinfo::set_has_guildname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void iconinfo::clear_has_guildname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void iconinfo::clear_guildname() {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    guildname_->clear();
  }
  clear_has_guildname();
}
inline const ::std::string& iconinfo::guildname() const {
  return *guildname_;
}
inline void iconinfo::set_guildname(const ::std::string& value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void iconinfo::set_guildname(const char* value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void iconinfo::set_guildname(const char* value, size_t size) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_guildname() {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  return guildname_;
}
inline ::std::string* iconinfo::release_guildname() {
  clear_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guildname_;
    guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 headFrame = 5;
inline bool iconinfo::has_headframe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void iconinfo::set_has_headframe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void iconinfo::clear_has_headframe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void iconinfo::clear_headframe() {
  headframe_ = 0;
  clear_has_headframe();
}
inline ::google::protobuf::int32 iconinfo::headframe() const {
  return headframe_;
}
inline void iconinfo::set_headframe(::google::protobuf::int32 value) {
  set_has_headframe();
  headframe_ = value;
}

// optional string playerId = 6;
inline bool iconinfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void iconinfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void iconinfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void iconinfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& iconinfo::playerid() const {
  return *playerid_;
}
inline void iconinfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* iconinfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 serverId = 7;
inline bool iconinfo::has_serverid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void iconinfo::set_has_serverid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void iconinfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void iconinfo::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 iconinfo::serverid() const {
  return serverid_;
}
inline void iconinfo::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}

// -------------------------------------------------------------------

// playerInfoList

// repeated .protobuf.town.iconinfo showinfo = 1;
inline int playerInfoList::showinfo_size() const {
  return showinfo_.size();
}
inline void playerInfoList::clear_showinfo() {
  showinfo_.Clear();
}
inline const ::protobuf::town::iconinfo& playerInfoList::showinfo(int index) const {
  return showinfo_.Get(index);
}
inline ::protobuf::town::iconinfo* playerInfoList::mutable_showinfo(int index) {
  return showinfo_.Mutable(index);
}
inline ::protobuf::town::iconinfo* playerInfoList::add_showinfo() {
  return showinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::town::iconinfo >&
playerInfoList::showinfo() const {
  return showinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::town::iconinfo >*
playerInfoList::mutable_showinfo() {
  return &showinfo_;
}

// -------------------------------------------------------------------

// BattleHistory

// required string attackName = 1;
inline bool BattleHistory::has_attackname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleHistory::set_has_attackname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleHistory::clear_has_attackname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleHistory::clear_attackname() {
  if (attackname_ != &::google::protobuf::internal::kEmptyString) {
    attackname_->clear();
  }
  clear_has_attackname();
}
inline const ::std::string& BattleHistory::attackname() const {
  return *attackname_;
}
inline void BattleHistory::set_attackname(const ::std::string& value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void BattleHistory::set_attackname(const char* value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void BattleHistory::set_attackname(const char* value, size_t size) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackname() {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  return attackname_;
}
inline ::std::string* BattleHistory::release_attackname() {
  clear_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackname_;
    attackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 attackLvl = 2;
inline bool BattleHistory::has_attacklvl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleHistory::set_has_attacklvl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleHistory::clear_has_attacklvl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleHistory::clear_attacklvl() {
  attacklvl_ = 0;
  clear_has_attacklvl();
}
inline ::google::protobuf::int32 BattleHistory::attacklvl() const {
  return attacklvl_;
}
inline void BattleHistory::set_attacklvl(::google::protobuf::int32 value) {
  set_has_attacklvl();
  attacklvl_ = value;
}

// required string attackHead = 3;
inline bool BattleHistory::has_attackhead() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleHistory::set_has_attackhead() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleHistory::clear_has_attackhead() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleHistory::clear_attackhead() {
  if (attackhead_ != &::google::protobuf::internal::kEmptyString) {
    attackhead_->clear();
  }
  clear_has_attackhead();
}
inline const ::std::string& BattleHistory::attackhead() const {
  return *attackhead_;
}
inline void BattleHistory::set_attackhead(const ::std::string& value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void BattleHistory::set_attackhead(const char* value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void BattleHistory::set_attackhead(const char* value, size_t size) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackhead() {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  return attackhead_;
}
inline ::std::string* BattleHistory::release_attackhead() {
  clear_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackhead_;
    attackhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .protobuf.common.LineupDetail attacker = 4;
inline bool BattleHistory::has_attacker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleHistory::set_has_attacker() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleHistory::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleHistory::clear_attacker() {
  if (attacker_ != NULL) attacker_->::protobuf::common::LineupDetail::Clear();
  clear_has_attacker();
}
inline const ::protobuf::common::LineupDetail& BattleHistory::attacker() const {
  return attacker_ != NULL ? *attacker_ : *default_instance_->attacker_;
}
inline ::protobuf::common::LineupDetail* BattleHistory::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == NULL) attacker_ = new ::protobuf::common::LineupDetail;
  return attacker_;
}
inline ::protobuf::common::LineupDetail* BattleHistory::release_attacker() {
  clear_has_attacker();
  ::protobuf::common::LineupDetail* temp = attacker_;
  attacker_ = NULL;
  return temp;
}

// required string attackId = 5;
inline bool BattleHistory::has_attackid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleHistory::set_has_attackid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleHistory::clear_has_attackid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleHistory::clear_attackid() {
  if (attackid_ != &::google::protobuf::internal::kEmptyString) {
    attackid_->clear();
  }
  clear_has_attackid();
}
inline const ::std::string& BattleHistory::attackid() const {
  return *attackid_;
}
inline void BattleHistory::set_attackid(const ::std::string& value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void BattleHistory::set_attackid(const char* value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void BattleHistory::set_attackid(const char* value, size_t size) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackid() {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  return attackid_;
}
inline ::std::string* BattleHistory::release_attackid() {
  clear_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackid_;
    attackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 defineid = 6;
inline bool BattleHistory::has_defineid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleHistory::set_has_defineid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleHistory::clear_has_defineid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleHistory::clear_defineid() {
  defineid_ = 0;
  clear_has_defineid();
}
inline ::google::protobuf::int32 BattleHistory::defineid() const {
  return defineid_;
}
inline void BattleHistory::set_defineid(::google::protobuf::int32 value) {
  set_has_defineid();
  defineid_ = value;
}

// required int64 seed = 7;
inline bool BattleHistory::has_seed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleHistory::set_has_seed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleHistory::clear_has_seed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleHistory::clear_seed() {
  seed_ = GOOGLE_LONGLONG(0);
  clear_has_seed();
}
inline ::google::protobuf::int64 BattleHistory::seed() const {
  return seed_;
}
inline void BattleHistory::set_seed(::google::protobuf::int64 value) {
  set_has_seed();
  seed_ = value;
}

// required int32 battletype = 8;
inline bool BattleHistory::has_battletype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleHistory::set_has_battletype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleHistory::clear_has_battletype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleHistory::clear_battletype() {
  battletype_ = 0;
  clear_has_battletype();
}
inline ::google::protobuf::int32 BattleHistory::battletype() const {
  return battletype_;
}
inline void BattleHistory::set_battletype(::google::protobuf::int32 value) {
  set_has_battletype();
  battletype_ = value;
}

// required bool victory = 9;
inline bool BattleHistory::has_victory() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleHistory::set_has_victory() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleHistory::clear_has_victory() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleHistory::clear_victory() {
  victory_ = false;
  clear_has_victory();
}
inline bool BattleHistory::victory() const {
  return victory_;
}
inline void BattleHistory::set_victory(bool value) {
  set_has_victory();
  victory_ = value;
}

// required int64 time = 10;
inline bool BattleHistory::has_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleHistory::set_has_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleHistory::clear_has_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleHistory::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 BattleHistory::time() const {
  return time_;
}
inline void BattleHistory::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional int32 headFrame = 11;
inline bool BattleHistory::has_headframe() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleHistory::set_has_headframe() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleHistory::clear_has_headframe() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleHistory::clear_headframe() {
  headframe_ = 0;
  clear_has_headframe();
}
inline ::google::protobuf::int32 BattleHistory::headframe() const {
  return headframe_;
}
inline void BattleHistory::set_headframe(::google::protobuf::int32 value) {
  set_has_headframe();
  headframe_ = value;
}

// -------------------------------------------------------------------

// BattleHistoryList

// repeated .protobuf.town.BattleHistory battles = 1;
inline int BattleHistoryList::battles_size() const {
  return battles_.size();
}
inline void BattleHistoryList::clear_battles() {
  battles_.Clear();
}
inline const ::protobuf::town::BattleHistory& BattleHistoryList::battles(int index) const {
  return battles_.Get(index);
}
inline ::protobuf::town::BattleHistory* BattleHistoryList::mutable_battles(int index) {
  return battles_.Mutable(index);
}
inline ::protobuf::town::BattleHistory* BattleHistoryList::add_battles() {
  return battles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::town::BattleHistory >&
BattleHistoryList::battles() const {
  return battles_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::town::BattleHistory >*
BattleHistoryList::mutable_battles() {
  return &battles_;
}

// -------------------------------------------------------------------

// NewBattleHistory

// required string attackName = 1;
inline bool NewBattleHistory::has_attackname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewBattleHistory::set_has_attackname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewBattleHistory::clear_has_attackname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewBattleHistory::clear_attackname() {
  if (attackname_ != &::google::protobuf::internal::kEmptyString) {
    attackname_->clear();
  }
  clear_has_attackname();
}
inline const ::std::string& NewBattleHistory::attackname() const {
  return *attackname_;
}
inline void NewBattleHistory::set_attackname(const ::std::string& value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void NewBattleHistory::set_attackname(const char* value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void NewBattleHistory::set_attackname(const char* value, size_t size) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewBattleHistory::mutable_attackname() {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  return attackname_;
}
inline ::std::string* NewBattleHistory::release_attackname() {
  clear_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackname_;
    attackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 attackLvl = 2;
inline bool NewBattleHistory::has_attacklvl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewBattleHistory::set_has_attacklvl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewBattleHistory::clear_has_attacklvl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewBattleHistory::clear_attacklvl() {
  attacklvl_ = 0;
  clear_has_attacklvl();
}
inline ::google::protobuf::int32 NewBattleHistory::attacklvl() const {
  return attacklvl_;
}
inline void NewBattleHistory::set_attacklvl(::google::protobuf::int32 value) {
  set_has_attacklvl();
  attacklvl_ = value;
}

// required string attackHead = 3;
inline bool NewBattleHistory::has_attackhead() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewBattleHistory::set_has_attackhead() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewBattleHistory::clear_has_attackhead() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewBattleHistory::clear_attackhead() {
  if (attackhead_ != &::google::protobuf::internal::kEmptyString) {
    attackhead_->clear();
  }
  clear_has_attackhead();
}
inline const ::std::string& NewBattleHistory::attackhead() const {
  return *attackhead_;
}
inline void NewBattleHistory::set_attackhead(const ::std::string& value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void NewBattleHistory::set_attackhead(const char* value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void NewBattleHistory::set_attackhead(const char* value, size_t size) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewBattleHistory::mutable_attackhead() {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  return attackhead_;
}
inline ::std::string* NewBattleHistory::release_attackhead() {
  clear_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackhead_;
    attackhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string id = 4;
inline bool NewBattleHistory::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewBattleHistory::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewBattleHistory::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewBattleHistory::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& NewBattleHistory::id() const {
  return *id_;
}
inline void NewBattleHistory::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NewBattleHistory::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void NewBattleHistory::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewBattleHistory::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* NewBattleHistory::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string attackId = 5;
inline bool NewBattleHistory::has_attackid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NewBattleHistory::set_has_attackid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NewBattleHistory::clear_has_attackid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NewBattleHistory::clear_attackid() {
  if (attackid_ != &::google::protobuf::internal::kEmptyString) {
    attackid_->clear();
  }
  clear_has_attackid();
}
inline const ::std::string& NewBattleHistory::attackid() const {
  return *attackid_;
}
inline void NewBattleHistory::set_attackid(const ::std::string& value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void NewBattleHistory::set_attackid(const char* value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void NewBattleHistory::set_attackid(const char* value, size_t size) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewBattleHistory::mutable_attackid() {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  return attackid_;
}
inline ::std::string* NewBattleHistory::release_attackid() {
  clear_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackid_;
    attackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 battletype = 6;
inline bool NewBattleHistory::has_battletype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewBattleHistory::set_has_battletype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewBattleHistory::clear_has_battletype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewBattleHistory::clear_battletype() {
  battletype_ = 0;
  clear_has_battletype();
}
inline ::google::protobuf::int32 NewBattleHistory::battletype() const {
  return battletype_;
}
inline void NewBattleHistory::set_battletype(::google::protobuf::int32 value) {
  set_has_battletype();
  battletype_ = value;
}

// required bool victory = 7;
inline bool NewBattleHistory::has_victory() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewBattleHistory::set_has_victory() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewBattleHistory::clear_has_victory() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewBattleHistory::clear_victory() {
  victory_ = false;
  clear_has_victory();
}
inline bool NewBattleHistory::victory() const {
  return victory_;
}
inline void NewBattleHistory::set_victory(bool value) {
  set_has_victory();
  victory_ = value;
}

// required int64 time = 8;
inline bool NewBattleHistory::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewBattleHistory::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewBattleHistory::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewBattleHistory::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 NewBattleHistory::time() const {
  return time_;
}
inline void NewBattleHistory::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required int32 defineid = 9;
inline bool NewBattleHistory::has_defineid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewBattleHistory::set_has_defineid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewBattleHistory::clear_has_defineid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewBattleHistory::clear_defineid() {
  defineid_ = 0;
  clear_has_defineid();
}
inline ::google::protobuf::int32 NewBattleHistory::defineid() const {
  return defineid_;
}
inline void NewBattleHistory::set_defineid(::google::protobuf::int32 value) {
  set_has_defineid();
  defineid_ = value;
}

// optional int32 headFrame = 10;
inline bool NewBattleHistory::has_headframe() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewBattleHistory::set_has_headframe() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewBattleHistory::clear_has_headframe() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewBattleHistory::clear_headframe() {
  headframe_ = 0;
  clear_has_headframe();
}
inline ::google::protobuf::int32 NewBattleHistory::headframe() const {
  return headframe_;
}
inline void NewBattleHistory::set_headframe(::google::protobuf::int32 value) {
  set_has_headframe();
  headframe_ = value;
}

// -------------------------------------------------------------------

// NewBattleHistoryList

// repeated .protobuf.town.NewBattleHistory battles = 1;
inline int NewBattleHistoryList::battles_size() const {
  return battles_.size();
}
inline void NewBattleHistoryList::clear_battles() {
  battles_.Clear();
}
inline const ::protobuf::town::NewBattleHistory& NewBattleHistoryList::battles(int index) const {
  return battles_.Get(index);
}
inline ::protobuf::town::NewBattleHistory* NewBattleHistoryList::mutable_battles(int index) {
  return battles_.Mutable(index);
}
inline ::protobuf::town::NewBattleHistory* NewBattleHistoryList::add_battles() {
  return battles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::town::NewBattleHistory >&
NewBattleHistoryList::battles() const {
  return battles_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::town::NewBattleHistory >*
NewBattleHistoryList::mutable_battles() {
  return &battles_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace town
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_town_2eproto__INCLUDED
