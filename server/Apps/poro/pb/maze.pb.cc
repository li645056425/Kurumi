// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "maze.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace maze {

namespace {

const ::google::protobuf::Descriptor* MazeInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeEnemy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeEnemy_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeHelpEnemy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeHelpEnemy_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeHero_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeHero_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeUpdate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeUpdate_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeNext_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeNext_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeMarket_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeMarket_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeShop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeShop_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeHelpHero_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeHelpHero_reflection_ = NULL;
const ::google::protobuf::Descriptor* MazeKVint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MazeKVint_reflection_ = NULL;
const ::google::protobuf::Descriptor* TopTimeInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TopTimeInfo_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_maze_2eproto() {
  protobuf_AddDesc_maze_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "maze.proto");
  GOOGLE_CHECK(file != NULL);
  MazeInfo_descriptor_ = file->message_type(0);
  static const int MazeInfo_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, isopen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, updatetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, sit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, nextsit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, buffpackage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, herohelppackeage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, heropackeage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, queue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, pathway_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, mazemarket_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, mapnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, havereceivesit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, sittype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, fognumber_),
  };
  MazeInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeInfo_descriptor_,
      MazeInfo::default_instance_,
      MazeInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeInfo));
  MazeEnemy_descriptor_ = file->message_type(1);
  static const int MazeEnemy_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeEnemy, enemysit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeEnemy, enemylineup_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeEnemy, awards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeEnemy, chagevalue_),
  };
  MazeEnemy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeEnemy_descriptor_,
      MazeEnemy::default_instance_,
      MazeEnemy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeEnemy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeEnemy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeEnemy));
  MazeHelpEnemy_descriptor_ = file->message_type(2);
  static const int MazeHelpEnemy_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpEnemy, enemyinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpEnemy, helpinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpEnemy, bossbuff_),
  };
  MazeHelpEnemy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeHelpEnemy_descriptor_,
      MazeHelpEnemy::default_instance_,
      MazeHelpEnemy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpEnemy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpEnemy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeHelpEnemy));
  MazeHero_descriptor_ = file->message_type(3);
  static const int MazeHero_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHero, heroid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHero, lasthp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHero, ishelphero_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHero, energy_),
  };
  MazeHero_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeHero_descriptor_,
      MazeHero::default_instance_,
      MazeHero_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHero, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHero, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeHero));
  MazeUpdate_descriptor_ = file->message_type(4);
  static const int MazeUpdate_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeUpdate, heropackeage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeUpdate, mapnumber_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeUpdate, herohelppackeage_),
  };
  MazeUpdate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeUpdate_descriptor_,
      MazeUpdate::default_instance_,
      MazeUpdate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeUpdate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeUpdate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeUpdate));
  MazeNext_descriptor_ = file->message_type(5);
  static const int MazeNext_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeNext, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeNext, awards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeNext, mazetype_),
  };
  MazeNext_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeNext_descriptor_,
      MazeNext::default_instance_,
      MazeNext_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeNext, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeNext, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeNext));
  MazeMarket_descriptor_ = file->message_type(6);
  static const int MazeMarket_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeMarket, sit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeMarket, market_),
  };
  MazeMarket_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeMarket_descriptor_,
      MazeMarket::default_instance_,
      MazeMarket_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeMarket, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeMarket, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeMarket));
  MazeShop_descriptor_ = file->message_type(7);
  static const int MazeShop_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeShop, marketid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeShop, isshop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeShop, itemid_),
  };
  MazeShop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeShop_descriptor_,
      MazeShop::default_instance_,
      MazeShop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeShop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeShop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeShop));
  MazeHelpHero_descriptor_ = file->message_type(8);
  static const int MazeHelpHero_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpHero, sit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpHero, hero_),
  };
  MazeHelpHero_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeHelpHero_descriptor_,
      MazeHelpHero::default_instance_,
      MazeHelpHero_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpHero, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeHelpHero, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeHelpHero));
  MazeKVint_descriptor_ = file->message_type(9);
  static const int MazeKVint_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeKVint, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeKVint, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeKVint, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeKVint, mapid_),
  };
  MazeKVint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MazeKVint_descriptor_,
      MazeKVint::default_instance_,
      MazeKVint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeKVint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MazeKVint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MazeKVint));
  TopTimeInfo_descriptor_ = file->message_type(10);
  static const int TopTimeInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopTimeInfo, openmap_),
  };
  TopTimeInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TopTimeInfo_descriptor_,
      TopTimeInfo::default_instance_,
      TopTimeInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopTimeInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TopTimeInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TopTimeInfo));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_maze_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeInfo_descriptor_, &MazeInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeEnemy_descriptor_, &MazeEnemy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeHelpEnemy_descriptor_, &MazeHelpEnemy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeHero_descriptor_, &MazeHero::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeUpdate_descriptor_, &MazeUpdate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeNext_descriptor_, &MazeNext::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeMarket_descriptor_, &MazeMarket::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeShop_descriptor_, &MazeShop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeHelpHero_descriptor_, &MazeHelpHero::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MazeKVint_descriptor_, &MazeKVint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TopTimeInfo_descriptor_, &TopTimeInfo::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_maze_2eproto() {
  delete MazeInfo::default_instance_;
  delete MazeInfo_reflection_;
  delete MazeEnemy::default_instance_;
  delete MazeEnemy_reflection_;
  delete MazeHelpEnemy::default_instance_;
  delete MazeHelpEnemy_reflection_;
  delete MazeHero::default_instance_;
  delete MazeHero_reflection_;
  delete MazeUpdate::default_instance_;
  delete MazeUpdate_reflection_;
  delete MazeNext::default_instance_;
  delete MazeNext_reflection_;
  delete MazeMarket::default_instance_;
  delete MazeMarket_reflection_;
  delete MazeShop::default_instance_;
  delete MazeShop_reflection_;
  delete MazeHelpHero::default_instance_;
  delete MazeHelpHero_reflection_;
  delete MazeKVint::default_instance_;
  delete MazeKVint_reflection_;
  delete TopTimeInfo::default_instance_;
  delete TopTimeInfo_reflection_;
}

void protobuf_AddDesc_maze_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf::common::protobuf_AddDesc_common_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\nmaze.proto\022\rprotobuf.maze\032\014common.prot"
    "o\"\246\003\n\010MazeInfo\022\r\n\005layer\030\001 \002(\005\022\016\n\006isOpen\030"
    "\002 \002(\010\022\022\n\nupdateTime\030\003 \001(\003\022\013\n\003sit\030\004 \001(\005\022\017"
    "\n\007nextSit\030\005 \001(\005\022\023\n\013buffPackage\030\006 \003(\005\022/\n\020"
    "heroHelpPackeage\030\007 \003(\0132\025.protobuf.common"
    ".Hero\022-\n\014heroPackeage\030\010 \003(\0132\027.protobuf.m"
    "aze.MazeHero\022\r\n\005queue\030\t \003(\005\022\017\n\007pathWay\030\n"
    " \003(\005\022-\n\nmazeMarket\030\013 \003(\0132\031.protobuf.maze"
    ".MazeMarket\022\021\n\tmapNumber\030\014 \001(\005\022\026\n\016haveRe"
    "ceiveSit\030\r \003(\005\022+\n\007sitType\030\016 \003(\0132\032.protob"
    "uf.common.KVint3232\022-\n\tfogNumber\030\017 \003(\0132\032"
    ".protobuf.common.KVint3232\"\221\001\n\tMazeEnemy"
    "\022\020\n\010enemySit\030\001 \001(\005\0222\n\013enemyLineup\030\002 \001(\0132"
    "\035.protobuf.common.LineupDetail\022*\n\006awards"
    "\030\003 \003(\0132\032.protobuf.common.KVint3264\022\022\n\nch"
    "ageValue\030\004 \001(\001\"\235\001\n\rMazeHelpEnemy\022+\n\tenem"
    "yInfo\030\001 \003(\0132\030.protobuf.maze.MazeEnemy\022-\n"
    "\010helpInfo\030\002 \003(\0132\033.protobuf.maze.MazeHelp"
    "Hero\0220\n\010bossBuff\030\003 \003(\0132\036.protobuf.common"
    ".KVint32List32\"N\n\010MazeHero\022\016\n\006heroId\030\001 \002"
    "(\005\022\016\n\006lastHp\030\002 \002(\005\022\022\n\nisHelpHero\030\003 \002(\010\022\016"
    "\n\006energy\030\004 \002(\005\"\177\n\nMazeUpdate\022-\n\014heroPack"
    "eage\030\001 \003(\0132\027.protobuf.maze.MazeHero\022\021\n\tm"
    "apNumber\030\002 \001(\005\022/\n\020heroHelpPackeage\030\003 \003(\013"
    "2\025.protobuf.common.Hero\"r\n\010MazeNext\022(\n\004i"
    "nfo\030\001 \001(\0132\032.protobuf.common.KVint3233\022*\n"
    "\006awards\030\002 \003(\0132\032.protobuf.common.KVint326"
    "4\022\020\n\010mazeType\030\004 \001(\005\"B\n\nMazeMarket\022\013\n\003sit"
    "\030\001 \001(\005\022\'\n\006market\030\002 \003(\0132\027.protobuf.maze.M"
    "azeShop\"<\n\010MazeShop\022\020\n\010marketId\030\001 \001(\005\022\016\n"
    "\006isShop\030\002 \001(\010\022\016\n\006itemId\030\003 \001(\005\"@\n\014MazeHel"
    "pHero\022\013\n\003sit\030\001 \001(\005\022#\n\004hero\030\002 \003(\0132\025.proto"
    "buf.common.Hero\"D\n\tMazeKVint\022\013\n\003key\030\001 \002("
    "\005\022\r\n\005value\030\002 \002(\005\022\014\n\004type\030\003 \002(\005\022\r\n\005mapId\030"
    "\004 \002(\005\">\n\013TopTimeInfo\022/\n\007openMap\030\001 \003(\0132\036."
    "protobuf.common.KVint32List32B \n\023xag.idg"
    "o.core.protoB\tMazeProto", 1463);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "maze.proto", &protobuf_RegisterTypes);
  MazeInfo::default_instance_ = new MazeInfo();
  MazeEnemy::default_instance_ = new MazeEnemy();
  MazeHelpEnemy::default_instance_ = new MazeHelpEnemy();
  MazeHero::default_instance_ = new MazeHero();
  MazeUpdate::default_instance_ = new MazeUpdate();
  MazeNext::default_instance_ = new MazeNext();
  MazeMarket::default_instance_ = new MazeMarket();
  MazeShop::default_instance_ = new MazeShop();
  MazeHelpHero::default_instance_ = new MazeHelpHero();
  MazeKVint::default_instance_ = new MazeKVint();
  TopTimeInfo::default_instance_ = new TopTimeInfo();
  MazeInfo::default_instance_->InitAsDefaultInstance();
  MazeEnemy::default_instance_->InitAsDefaultInstance();
  MazeHelpEnemy::default_instance_->InitAsDefaultInstance();
  MazeHero::default_instance_->InitAsDefaultInstance();
  MazeUpdate::default_instance_->InitAsDefaultInstance();
  MazeNext::default_instance_->InitAsDefaultInstance();
  MazeMarket::default_instance_->InitAsDefaultInstance();
  MazeShop::default_instance_->InitAsDefaultInstance();
  MazeHelpHero::default_instance_->InitAsDefaultInstance();
  MazeKVint::default_instance_->InitAsDefaultInstance();
  TopTimeInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_maze_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_maze_2eproto {
  StaticDescriptorInitializer_maze_2eproto() {
    protobuf_AddDesc_maze_2eproto();
  }
} static_descriptor_initializer_maze_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int MazeInfo::kLayerFieldNumber;
const int MazeInfo::kIsOpenFieldNumber;
const int MazeInfo::kUpdateTimeFieldNumber;
const int MazeInfo::kSitFieldNumber;
const int MazeInfo::kNextSitFieldNumber;
const int MazeInfo::kBuffPackageFieldNumber;
const int MazeInfo::kHeroHelpPackeageFieldNumber;
const int MazeInfo::kHeroPackeageFieldNumber;
const int MazeInfo::kQueueFieldNumber;
const int MazeInfo::kPathWayFieldNumber;
const int MazeInfo::kMazeMarketFieldNumber;
const int MazeInfo::kMapNumberFieldNumber;
const int MazeInfo::kHaveReceiveSitFieldNumber;
const int MazeInfo::kSitTypeFieldNumber;
const int MazeInfo::kFogNumberFieldNumber;
#endif  // !_MSC_VER

MazeInfo::MazeInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeInfo::InitAsDefaultInstance() {
}

MazeInfo::MazeInfo(const MazeInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeInfo::SharedCtor() {
  _cached_size_ = 0;
  layer_ = 0;
  isopen_ = false;
  updatetime_ = GOOGLE_LONGLONG(0);
  sit_ = 0;
  nextsit_ = 0;
  mapnumber_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeInfo::~MazeInfo() {
  SharedDtor();
}

void MazeInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeInfo_descriptor_;
}

const MazeInfo& MazeInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeInfo* MazeInfo::default_instance_ = NULL;

MazeInfo* MazeInfo::New() const {
  return new MazeInfo;
}

void MazeInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    layer_ = 0;
    isopen_ = false;
    updatetime_ = GOOGLE_LONGLONG(0);
    sit_ = 0;
    nextsit_ = 0;
  }
  if (_has_bits_[11 / 32] & (0xffu << (11 % 32))) {
    mapnumber_ = 0;
  }
  buffpackage_.Clear();
  herohelppackeage_.Clear();
  heropackeage_.Clear();
  queue_.Clear();
  pathway_.Clear();
  mazemarket_.Clear();
  havereceivesit_.Clear();
  sittype_.Clear();
  fognumber_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 layer = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_isOpen;
        break;
      }
      
      // required bool isOpen = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isOpen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isopen_)));
          set_has_isopen();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_updateTime;
        break;
      }
      
      // optional int64 updateTime = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_updateTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &updatetime_)));
          set_has_updatetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sit;
        break;
      }
      
      // optional int32 sit = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sit_)));
          set_has_sit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_nextSit;
        break;
      }
      
      // optional int32 nextSit = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_nextSit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nextsit_)));
          set_has_nextsit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_buffPackage;
        break;
      }
      
      // repeated int32 buffPackage = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_buffPackage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 48, input, this->mutable_buffpackage())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_buffpackage())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_buffPackage;
        if (input->ExpectTag(58)) goto parse_heroHelpPackeage;
        break;
      }
      
      // repeated .protobuf.common.Hero heroHelpPackeage = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heroHelpPackeage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_herohelppackeage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_heroHelpPackeage;
        if (input->ExpectTag(66)) goto parse_heroPackeage;
        break;
      }
      
      // repeated .protobuf.maze.MazeHero heroPackeage = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heroPackeage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_heropackeage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_heroPackeage;
        if (input->ExpectTag(72)) goto parse_queue;
        break;
      }
      
      // repeated int32 queue = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_queue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 72, input, this->mutable_queue())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_queue())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_queue;
        if (input->ExpectTag(80)) goto parse_pathWay;
        break;
      }
      
      // repeated int32 pathWay = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pathWay:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 80, input, this->mutable_pathway())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_pathway())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_pathWay;
        if (input->ExpectTag(90)) goto parse_mazeMarket;
        break;
      }
      
      // repeated .protobuf.maze.MazeMarket mazeMarket = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mazeMarket:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_mazemarket()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_mazeMarket;
        if (input->ExpectTag(96)) goto parse_mapNumber;
        break;
      }
      
      // optional int32 mapNumber = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapNumber:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapnumber_)));
          set_has_mapnumber();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_haveReceiveSit;
        break;
      }
      
      // repeated int32 haveReceiveSit = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_haveReceiveSit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 104, input, this->mutable_havereceivesit())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_havereceivesit())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(104)) goto parse_haveReceiveSit;
        if (input->ExpectTag(114)) goto parse_sitType;
        break;
      }
      
      // repeated .protobuf.common.KVint3232 sitType = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sitType:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sittype()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_sitType;
        if (input->ExpectTag(122)) goto parse_fogNumber;
        break;
      }
      
      // repeated .protobuf.common.KVint3232 fogNumber = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fogNumber:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_fognumber()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(122)) goto parse_fogNumber;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 layer = 1;
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->layer(), output);
  }
  
  // required bool isOpen = 2;
  if (has_isopen()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isopen(), output);
  }
  
  // optional int64 updateTime = 3;
  if (has_updatetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->updatetime(), output);
  }
  
  // optional int32 sit = 4;
  if (has_sit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->sit(), output);
  }
  
  // optional int32 nextSit = 5;
  if (has_nextsit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->nextsit(), output);
  }
  
  // repeated int32 buffPackage = 6;
  for (int i = 0; i < this->buffpackage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      6, this->buffpackage(i), output);
  }
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 7;
  for (int i = 0; i < this->herohelppackeage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->herohelppackeage(i), output);
  }
  
  // repeated .protobuf.maze.MazeHero heroPackeage = 8;
  for (int i = 0; i < this->heropackeage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->heropackeage(i), output);
  }
  
  // repeated int32 queue = 9;
  for (int i = 0; i < this->queue_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      9, this->queue(i), output);
  }
  
  // repeated int32 pathWay = 10;
  for (int i = 0; i < this->pathway_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      10, this->pathway(i), output);
  }
  
  // repeated .protobuf.maze.MazeMarket mazeMarket = 11;
  for (int i = 0; i < this->mazemarket_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->mazemarket(i), output);
  }
  
  // optional int32 mapNumber = 12;
  if (has_mapnumber()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->mapnumber(), output);
  }
  
  // repeated int32 haveReceiveSit = 13;
  for (int i = 0; i < this->havereceivesit_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      13, this->havereceivesit(i), output);
  }
  
  // repeated .protobuf.common.KVint3232 sitType = 14;
  for (int i = 0; i < this->sittype_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->sittype(i), output);
  }
  
  // repeated .protobuf.common.KVint3232 fogNumber = 15;
  for (int i = 0; i < this->fognumber_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->fognumber(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 layer = 1;
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->layer(), target);
  }
  
  // required bool isOpen = 2;
  if (has_isopen()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->isopen(), target);
  }
  
  // optional int64 updateTime = 3;
  if (has_updatetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->updatetime(), target);
  }
  
  // optional int32 sit = 4;
  if (has_sit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->sit(), target);
  }
  
  // optional int32 nextSit = 5;
  if (has_nextsit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->nextsit(), target);
  }
  
  // repeated int32 buffPackage = 6;
  for (int i = 0; i < this->buffpackage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(6, this->buffpackage(i), target);
  }
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 7;
  for (int i = 0; i < this->herohelppackeage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->herohelppackeage(i), target);
  }
  
  // repeated .protobuf.maze.MazeHero heroPackeage = 8;
  for (int i = 0; i < this->heropackeage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->heropackeage(i), target);
  }
  
  // repeated int32 queue = 9;
  for (int i = 0; i < this->queue_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(9, this->queue(i), target);
  }
  
  // repeated int32 pathWay = 10;
  for (int i = 0; i < this->pathway_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(10, this->pathway(i), target);
  }
  
  // repeated .protobuf.maze.MazeMarket mazeMarket = 11;
  for (int i = 0; i < this->mazemarket_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->mazemarket(i), target);
  }
  
  // optional int32 mapNumber = 12;
  if (has_mapnumber()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->mapnumber(), target);
  }
  
  // repeated int32 haveReceiveSit = 13;
  for (int i = 0; i < this->havereceivesit_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(13, this->havereceivesit(i), target);
  }
  
  // repeated .protobuf.common.KVint3232 sitType = 14;
  for (int i = 0; i < this->sittype_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->sittype(i), target);
  }
  
  // repeated .protobuf.common.KVint3232 fogNumber = 15;
  for (int i = 0; i < this->fognumber_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        15, this->fognumber(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeInfo::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 layer = 1;
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->layer());
    }
    
    // required bool isOpen = 2;
    if (has_isopen()) {
      total_size += 1 + 1;
    }
    
    // optional int64 updateTime = 3;
    if (has_updatetime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->updatetime());
    }
    
    // optional int32 sit = 4;
    if (has_sit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sit());
    }
    
    // optional int32 nextSit = 5;
    if (has_nextsit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nextsit());
    }
    
  }
  if (_has_bits_[11 / 32] & (0xffu << (11 % 32))) {
    // optional int32 mapNumber = 12;
    if (has_mapnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapnumber());
    }
    
  }
  // repeated int32 buffPackage = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->buffpackage_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->buffpackage(i));
    }
    total_size += 1 * this->buffpackage_size() + data_size;
  }
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 7;
  total_size += 1 * this->herohelppackeage_size();
  for (int i = 0; i < this->herohelppackeage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->herohelppackeage(i));
  }
  
  // repeated .protobuf.maze.MazeHero heroPackeage = 8;
  total_size += 1 * this->heropackeage_size();
  for (int i = 0; i < this->heropackeage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->heropackeage(i));
  }
  
  // repeated int32 queue = 9;
  {
    int data_size = 0;
    for (int i = 0; i < this->queue_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->queue(i));
    }
    total_size += 1 * this->queue_size() + data_size;
  }
  
  // repeated int32 pathWay = 10;
  {
    int data_size = 0;
    for (int i = 0; i < this->pathway_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->pathway(i));
    }
    total_size += 1 * this->pathway_size() + data_size;
  }
  
  // repeated .protobuf.maze.MazeMarket mazeMarket = 11;
  total_size += 1 * this->mazemarket_size();
  for (int i = 0; i < this->mazemarket_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mazemarket(i));
  }
  
  // repeated int32 haveReceiveSit = 13;
  {
    int data_size = 0;
    for (int i = 0; i < this->havereceivesit_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->havereceivesit(i));
    }
    total_size += 1 * this->havereceivesit_size() + data_size;
  }
  
  // repeated .protobuf.common.KVint3232 sitType = 14;
  total_size += 1 * this->sittype_size();
  for (int i = 0; i < this->sittype_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sittype(i));
  }
  
  // repeated .protobuf.common.KVint3232 fogNumber = 15;
  total_size += 1 * this->fognumber_size();
  for (int i = 0; i < this->fognumber_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->fognumber(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeInfo::MergeFrom(const MazeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  buffpackage_.MergeFrom(from.buffpackage_);
  herohelppackeage_.MergeFrom(from.herohelppackeage_);
  heropackeage_.MergeFrom(from.heropackeage_);
  queue_.MergeFrom(from.queue_);
  pathway_.MergeFrom(from.pathway_);
  mazemarket_.MergeFrom(from.mazemarket_);
  havereceivesit_.MergeFrom(from.havereceivesit_);
  sittype_.MergeFrom(from.sittype_);
  fognumber_.MergeFrom(from.fognumber_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layer()) {
      set_layer(from.layer());
    }
    if (from.has_isopen()) {
      set_isopen(from.isopen());
    }
    if (from.has_updatetime()) {
      set_updatetime(from.updatetime());
    }
    if (from.has_sit()) {
      set_sit(from.sit());
    }
    if (from.has_nextsit()) {
      set_nextsit(from.nextsit());
    }
  }
  if (from._has_bits_[11 / 32] & (0xffu << (11 % 32))) {
    if (from.has_mapnumber()) {
      set_mapnumber(from.mapnumber());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeInfo::CopyFrom(const MazeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  for (int i = 0; i < herohelppackeage_size(); i++) {
    if (!this->herohelppackeage(i).IsInitialized()) return false;
  }
  for (int i = 0; i < heropackeage_size(); i++) {
    if (!this->heropackeage(i).IsInitialized()) return false;
  }
  for (int i = 0; i < sittype_size(); i++) {
    if (!this->sittype(i).IsInitialized()) return false;
  }
  for (int i = 0; i < fognumber_size(); i++) {
    if (!this->fognumber(i).IsInitialized()) return false;
  }
  return true;
}

void MazeInfo::Swap(MazeInfo* other) {
  if (other != this) {
    std::swap(layer_, other->layer_);
    std::swap(isopen_, other->isopen_);
    std::swap(updatetime_, other->updatetime_);
    std::swap(sit_, other->sit_);
    std::swap(nextsit_, other->nextsit_);
    buffpackage_.Swap(&other->buffpackage_);
    herohelppackeage_.Swap(&other->herohelppackeage_);
    heropackeage_.Swap(&other->heropackeage_);
    queue_.Swap(&other->queue_);
    pathway_.Swap(&other->pathway_);
    mazemarket_.Swap(&other->mazemarket_);
    std::swap(mapnumber_, other->mapnumber_);
    havereceivesit_.Swap(&other->havereceivesit_);
    sittype_.Swap(&other->sittype_);
    fognumber_.Swap(&other->fognumber_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeInfo_descriptor_;
  metadata.reflection = MazeInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeEnemy::kEnemySitFieldNumber;
const int MazeEnemy::kEnemyLineupFieldNumber;
const int MazeEnemy::kAwardsFieldNumber;
const int MazeEnemy::kChageValueFieldNumber;
#endif  // !_MSC_VER

MazeEnemy::MazeEnemy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeEnemy::InitAsDefaultInstance() {
  enemylineup_ = const_cast< ::protobuf::common::LineupDetail*>(&::protobuf::common::LineupDetail::default_instance());
}

MazeEnemy::MazeEnemy(const MazeEnemy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeEnemy::SharedCtor() {
  _cached_size_ = 0;
  enemysit_ = 0;
  enemylineup_ = NULL;
  chagevalue_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeEnemy::~MazeEnemy() {
  SharedDtor();
}

void MazeEnemy::SharedDtor() {
  if (this != default_instance_) {
    delete enemylineup_;
  }
}

void MazeEnemy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeEnemy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeEnemy_descriptor_;
}

const MazeEnemy& MazeEnemy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeEnemy* MazeEnemy::default_instance_ = NULL;

MazeEnemy* MazeEnemy::New() const {
  return new MazeEnemy;
}

void MazeEnemy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    enemysit_ = 0;
    if (has_enemylineup()) {
      if (enemylineup_ != NULL) enemylineup_->::protobuf::common::LineupDetail::Clear();
    }
    chagevalue_ = 0;
  }
  awards_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeEnemy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 enemySit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &enemysit_)));
          set_has_enemysit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_enemyLineup;
        break;
      }
      
      // optional .protobuf.common.LineupDetail enemyLineup = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_enemyLineup:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_enemylineup()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_awards;
        break;
      }
      
      // repeated .protobuf.common.KVint3264 awards = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_awards:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_awards()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_awards;
        if (input->ExpectTag(33)) goto parse_chageValue;
        break;
      }
      
      // optional double chageValue = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_chageValue:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &chagevalue_)));
          set_has_chagevalue();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeEnemy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 enemySit = 1;
  if (has_enemysit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->enemysit(), output);
  }
  
  // optional .protobuf.common.LineupDetail enemyLineup = 2;
  if (has_enemylineup()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->enemylineup(), output);
  }
  
  // repeated .protobuf.common.KVint3264 awards = 3;
  for (int i = 0; i < this->awards_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->awards(i), output);
  }
  
  // optional double chageValue = 4;
  if (has_chagevalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->chagevalue(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeEnemy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 enemySit = 1;
  if (has_enemysit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->enemysit(), target);
  }
  
  // optional .protobuf.common.LineupDetail enemyLineup = 2;
  if (has_enemylineup()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->enemylineup(), target);
  }
  
  // repeated .protobuf.common.KVint3264 awards = 3;
  for (int i = 0; i < this->awards_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->awards(i), target);
  }
  
  // optional double chageValue = 4;
  if (has_chagevalue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->chagevalue(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeEnemy::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 enemySit = 1;
    if (has_enemysit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->enemysit());
    }
    
    // optional .protobuf.common.LineupDetail enemyLineup = 2;
    if (has_enemylineup()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->enemylineup());
    }
    
    // optional double chageValue = 4;
    if (has_chagevalue()) {
      total_size += 1 + 8;
    }
    
  }
  // repeated .protobuf.common.KVint3264 awards = 3;
  total_size += 1 * this->awards_size();
  for (int i = 0; i < this->awards_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->awards(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeEnemy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeEnemy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeEnemy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeEnemy::MergeFrom(const MazeEnemy& from) {
  GOOGLE_CHECK_NE(&from, this);
  awards_.MergeFrom(from.awards_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enemysit()) {
      set_enemysit(from.enemysit());
    }
    if (from.has_enemylineup()) {
      mutable_enemylineup()->::protobuf::common::LineupDetail::MergeFrom(from.enemylineup());
    }
    if (from.has_chagevalue()) {
      set_chagevalue(from.chagevalue());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeEnemy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeEnemy::CopyFrom(const MazeEnemy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeEnemy::IsInitialized() const {
  
  if (has_enemylineup()) {
    if (!this->enemylineup().IsInitialized()) return false;
  }
  for (int i = 0; i < awards_size(); i++) {
    if (!this->awards(i).IsInitialized()) return false;
  }
  return true;
}

void MazeEnemy::Swap(MazeEnemy* other) {
  if (other != this) {
    std::swap(enemysit_, other->enemysit_);
    std::swap(enemylineup_, other->enemylineup_);
    awards_.Swap(&other->awards_);
    std::swap(chagevalue_, other->chagevalue_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeEnemy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeEnemy_descriptor_;
  metadata.reflection = MazeEnemy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeHelpEnemy::kEnemyInfoFieldNumber;
const int MazeHelpEnemy::kHelpInfoFieldNumber;
const int MazeHelpEnemy::kBossBuffFieldNumber;
#endif  // !_MSC_VER

MazeHelpEnemy::MazeHelpEnemy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeHelpEnemy::InitAsDefaultInstance() {
}

MazeHelpEnemy::MazeHelpEnemy(const MazeHelpEnemy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeHelpEnemy::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeHelpEnemy::~MazeHelpEnemy() {
  SharedDtor();
}

void MazeHelpEnemy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeHelpEnemy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeHelpEnemy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeHelpEnemy_descriptor_;
}

const MazeHelpEnemy& MazeHelpEnemy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeHelpEnemy* MazeHelpEnemy::default_instance_ = NULL;

MazeHelpEnemy* MazeHelpEnemy::New() const {
  return new MazeHelpEnemy;
}

void MazeHelpEnemy::Clear() {
  enemyinfo_.Clear();
  helpinfo_.Clear();
  bossbuff_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeHelpEnemy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protobuf.maze.MazeEnemy enemyInfo = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_enemyInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_enemyinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_enemyInfo;
        if (input->ExpectTag(18)) goto parse_helpInfo;
        break;
      }
      
      // repeated .protobuf.maze.MazeHelpHero helpInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_helpInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_helpinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_helpInfo;
        if (input->ExpectTag(26)) goto parse_bossBuff;
        break;
      }
      
      // repeated .protobuf.common.KVint32List32 bossBuff = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bossBuff:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bossbuff()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bossBuff;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeHelpEnemy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .protobuf.maze.MazeEnemy enemyInfo = 1;
  for (int i = 0; i < this->enemyinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->enemyinfo(i), output);
  }
  
  // repeated .protobuf.maze.MazeHelpHero helpInfo = 2;
  for (int i = 0; i < this->helpinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->helpinfo(i), output);
  }
  
  // repeated .protobuf.common.KVint32List32 bossBuff = 3;
  for (int i = 0; i < this->bossbuff_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->bossbuff(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeHelpEnemy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .protobuf.maze.MazeEnemy enemyInfo = 1;
  for (int i = 0; i < this->enemyinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->enemyinfo(i), target);
  }
  
  // repeated .protobuf.maze.MazeHelpHero helpInfo = 2;
  for (int i = 0; i < this->helpinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->helpinfo(i), target);
  }
  
  // repeated .protobuf.common.KVint32List32 bossBuff = 3;
  for (int i = 0; i < this->bossbuff_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->bossbuff(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeHelpEnemy::ByteSize() const {
  int total_size = 0;
  
  // repeated .protobuf.maze.MazeEnemy enemyInfo = 1;
  total_size += 1 * this->enemyinfo_size();
  for (int i = 0; i < this->enemyinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->enemyinfo(i));
  }
  
  // repeated .protobuf.maze.MazeHelpHero helpInfo = 2;
  total_size += 1 * this->helpinfo_size();
  for (int i = 0; i < this->helpinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->helpinfo(i));
  }
  
  // repeated .protobuf.common.KVint32List32 bossBuff = 3;
  total_size += 1 * this->bossbuff_size();
  for (int i = 0; i < this->bossbuff_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bossbuff(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeHelpEnemy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeHelpEnemy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeHelpEnemy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeHelpEnemy::MergeFrom(const MazeHelpEnemy& from) {
  GOOGLE_CHECK_NE(&from, this);
  enemyinfo_.MergeFrom(from.enemyinfo_);
  helpinfo_.MergeFrom(from.helpinfo_);
  bossbuff_.MergeFrom(from.bossbuff_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeHelpEnemy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeHelpEnemy::CopyFrom(const MazeHelpEnemy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeHelpEnemy::IsInitialized() const {
  
  for (int i = 0; i < enemyinfo_size(); i++) {
    if (!this->enemyinfo(i).IsInitialized()) return false;
  }
  for (int i = 0; i < helpinfo_size(); i++) {
    if (!this->helpinfo(i).IsInitialized()) return false;
  }
  for (int i = 0; i < bossbuff_size(); i++) {
    if (!this->bossbuff(i).IsInitialized()) return false;
  }
  return true;
}

void MazeHelpEnemy::Swap(MazeHelpEnemy* other) {
  if (other != this) {
    enemyinfo_.Swap(&other->enemyinfo_);
    helpinfo_.Swap(&other->helpinfo_);
    bossbuff_.Swap(&other->bossbuff_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeHelpEnemy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeHelpEnemy_descriptor_;
  metadata.reflection = MazeHelpEnemy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeHero::kHeroIdFieldNumber;
const int MazeHero::kLastHpFieldNumber;
const int MazeHero::kIsHelpHeroFieldNumber;
const int MazeHero::kEnergyFieldNumber;
#endif  // !_MSC_VER

MazeHero::MazeHero()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeHero::InitAsDefaultInstance() {
}

MazeHero::MazeHero(const MazeHero& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeHero::SharedCtor() {
  _cached_size_ = 0;
  heroid_ = 0;
  lasthp_ = 0;
  ishelphero_ = false;
  energy_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeHero::~MazeHero() {
  SharedDtor();
}

void MazeHero::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeHero::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeHero::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeHero_descriptor_;
}

const MazeHero& MazeHero::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeHero* MazeHero::default_instance_ = NULL;

MazeHero* MazeHero::New() const {
  return new MazeHero;
}

void MazeHero::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    heroid_ = 0;
    lasthp_ = 0;
    ishelphero_ = false;
    energy_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeHero::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 heroId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heroid_)));
          set_has_heroid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_lastHp;
        break;
      }
      
      // required int32 lastHp = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lastHp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lasthp_)));
          set_has_lasthp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_isHelpHero;
        break;
      }
      
      // required bool isHelpHero = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isHelpHero:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ishelphero_)));
          set_has_ishelphero();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_energy;
        break;
      }
      
      // required int32 energy = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_energy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &energy_)));
          set_has_energy();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeHero::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 heroId = 1;
  if (has_heroid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->heroid(), output);
  }
  
  // required int32 lastHp = 2;
  if (has_lasthp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->lasthp(), output);
  }
  
  // required bool isHelpHero = 3;
  if (has_ishelphero()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->ishelphero(), output);
  }
  
  // required int32 energy = 4;
  if (has_energy()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->energy(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeHero::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 heroId = 1;
  if (has_heroid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->heroid(), target);
  }
  
  // required int32 lastHp = 2;
  if (has_lasthp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->lasthp(), target);
  }
  
  // required bool isHelpHero = 3;
  if (has_ishelphero()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->ishelphero(), target);
  }
  
  // required int32 energy = 4;
  if (has_energy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->energy(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeHero::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 heroId = 1;
    if (has_heroid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heroid());
    }
    
    // required int32 lastHp = 2;
    if (has_lasthp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lasthp());
    }
    
    // required bool isHelpHero = 3;
    if (has_ishelphero()) {
      total_size += 1 + 1;
    }
    
    // required int32 energy = 4;
    if (has_energy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->energy());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeHero::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeHero* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeHero*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeHero::MergeFrom(const MazeHero& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_heroid()) {
      set_heroid(from.heroid());
    }
    if (from.has_lasthp()) {
      set_lasthp(from.lasthp());
    }
    if (from.has_ishelphero()) {
      set_ishelphero(from.ishelphero());
    }
    if (from.has_energy()) {
      set_energy(from.energy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeHero::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeHero::CopyFrom(const MazeHero& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeHero::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void MazeHero::Swap(MazeHero* other) {
  if (other != this) {
    std::swap(heroid_, other->heroid_);
    std::swap(lasthp_, other->lasthp_);
    std::swap(ishelphero_, other->ishelphero_);
    std::swap(energy_, other->energy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeHero::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeHero_descriptor_;
  metadata.reflection = MazeHero_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeUpdate::kHeroPackeageFieldNumber;
const int MazeUpdate::kMapNumberFieldNumber;
const int MazeUpdate::kHeroHelpPackeageFieldNumber;
#endif  // !_MSC_VER

MazeUpdate::MazeUpdate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeUpdate::InitAsDefaultInstance() {
}

MazeUpdate::MazeUpdate(const MazeUpdate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeUpdate::SharedCtor() {
  _cached_size_ = 0;
  mapnumber_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeUpdate::~MazeUpdate() {
  SharedDtor();
}

void MazeUpdate::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeUpdate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeUpdate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeUpdate_descriptor_;
}

const MazeUpdate& MazeUpdate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeUpdate* MazeUpdate::default_instance_ = NULL;

MazeUpdate* MazeUpdate::New() const {
  return new MazeUpdate;
}

void MazeUpdate::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    mapnumber_ = 0;
  }
  heropackeage_.Clear();
  herohelppackeage_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protobuf.maze.MazeHero heroPackeage = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heroPackeage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_heropackeage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_heroPackeage;
        if (input->ExpectTag(16)) goto parse_mapNumber;
        break;
      }
      
      // optional int32 mapNumber = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapNumber:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapnumber_)));
          set_has_mapnumber();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_heroHelpPackeage;
        break;
      }
      
      // repeated .protobuf.common.Hero heroHelpPackeage = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_heroHelpPackeage:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_herohelppackeage()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_heroHelpPackeage;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .protobuf.maze.MazeHero heroPackeage = 1;
  for (int i = 0; i < this->heropackeage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->heropackeage(i), output);
  }
  
  // optional int32 mapNumber = 2;
  if (has_mapnumber()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->mapnumber(), output);
  }
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 3;
  for (int i = 0; i < this->herohelppackeage_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->herohelppackeage(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeUpdate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .protobuf.maze.MazeHero heroPackeage = 1;
  for (int i = 0; i < this->heropackeage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->heropackeage(i), target);
  }
  
  // optional int32 mapNumber = 2;
  if (has_mapnumber()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->mapnumber(), target);
  }
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 3;
  for (int i = 0; i < this->herohelppackeage_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->herohelppackeage(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeUpdate::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 mapNumber = 2;
    if (has_mapnumber()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapnumber());
    }
    
  }
  // repeated .protobuf.maze.MazeHero heroPackeage = 1;
  total_size += 1 * this->heropackeage_size();
  for (int i = 0; i < this->heropackeage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->heropackeage(i));
  }
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 3;
  total_size += 1 * this->herohelppackeage_size();
  for (int i = 0; i < this->herohelppackeage_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->herohelppackeage(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeUpdate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeUpdate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeUpdate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeUpdate::MergeFrom(const MazeUpdate& from) {
  GOOGLE_CHECK_NE(&from, this);
  heropackeage_.MergeFrom(from.heropackeage_);
  herohelppackeage_.MergeFrom(from.herohelppackeage_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_mapnumber()) {
      set_mapnumber(from.mapnumber());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeUpdate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeUpdate::CopyFrom(const MazeUpdate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeUpdate::IsInitialized() const {
  
  for (int i = 0; i < heropackeage_size(); i++) {
    if (!this->heropackeage(i).IsInitialized()) return false;
  }
  for (int i = 0; i < herohelppackeage_size(); i++) {
    if (!this->herohelppackeage(i).IsInitialized()) return false;
  }
  return true;
}

void MazeUpdate::Swap(MazeUpdate* other) {
  if (other != this) {
    heropackeage_.Swap(&other->heropackeage_);
    std::swap(mapnumber_, other->mapnumber_);
    herohelppackeage_.Swap(&other->herohelppackeage_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeUpdate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeUpdate_descriptor_;
  metadata.reflection = MazeUpdate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeNext::kInfoFieldNumber;
const int MazeNext::kAwardsFieldNumber;
const int MazeNext::kMazeTypeFieldNumber;
#endif  // !_MSC_VER

MazeNext::MazeNext()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeNext::InitAsDefaultInstance() {
  info_ = const_cast< ::protobuf::common::KVint3233*>(&::protobuf::common::KVint3233::default_instance());
}

MazeNext::MazeNext(const MazeNext& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeNext::SharedCtor() {
  _cached_size_ = 0;
  info_ = NULL;
  mazetype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeNext::~MazeNext() {
  SharedDtor();
}

void MazeNext::SharedDtor() {
  if (this != default_instance_) {
    delete info_;
  }
}

void MazeNext::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeNext::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeNext_descriptor_;
}

const MazeNext& MazeNext::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeNext* MazeNext::default_instance_ = NULL;

MazeNext* MazeNext::New() const {
  return new MazeNext;
}

void MazeNext::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_info()) {
      if (info_ != NULL) info_->::protobuf::common::KVint3233::Clear();
    }
    mazetype_ = 0;
  }
  awards_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeNext::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protobuf.common.KVint3233 info = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_awards;
        break;
      }
      
      // repeated .protobuf.common.KVint3264 awards = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_awards:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_awards()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_awards;
        if (input->ExpectTag(32)) goto parse_mazeType;
        break;
      }
      
      // optional int32 mazeType = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mazeType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mazetype_)));
          set_has_mazetype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeNext::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .protobuf.common.KVint3233 info = 1;
  if (has_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->info(), output);
  }
  
  // repeated .protobuf.common.KVint3264 awards = 2;
  for (int i = 0; i < this->awards_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->awards(i), output);
  }
  
  // optional int32 mazeType = 4;
  if (has_mazetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->mazetype(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeNext::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .protobuf.common.KVint3233 info = 1;
  if (has_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->info(), target);
  }
  
  // repeated .protobuf.common.KVint3264 awards = 2;
  for (int i = 0; i < this->awards_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->awards(i), target);
  }
  
  // optional int32 mazeType = 4;
  if (has_mazetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->mazetype(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeNext::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .protobuf.common.KVint3233 info = 1;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->info());
    }
    
    // optional int32 mazeType = 4;
    if (has_mazetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mazetype());
    }
    
  }
  // repeated .protobuf.common.KVint3264 awards = 2;
  total_size += 1 * this->awards_size();
  for (int i = 0; i < this->awards_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->awards(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeNext::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeNext* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeNext*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeNext::MergeFrom(const MazeNext& from) {
  GOOGLE_CHECK_NE(&from, this);
  awards_.MergeFrom(from.awards_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info()) {
      mutable_info()->::protobuf::common::KVint3233::MergeFrom(from.info());
    }
    if (from.has_mazetype()) {
      set_mazetype(from.mazetype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeNext::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeNext::CopyFrom(const MazeNext& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeNext::IsInitialized() const {
  
  if (has_info()) {
    if (!this->info().IsInitialized()) return false;
  }
  for (int i = 0; i < awards_size(); i++) {
    if (!this->awards(i).IsInitialized()) return false;
  }
  return true;
}

void MazeNext::Swap(MazeNext* other) {
  if (other != this) {
    std::swap(info_, other->info_);
    awards_.Swap(&other->awards_);
    std::swap(mazetype_, other->mazetype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeNext::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeNext_descriptor_;
  metadata.reflection = MazeNext_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeMarket::kSitFieldNumber;
const int MazeMarket::kMarketFieldNumber;
#endif  // !_MSC_VER

MazeMarket::MazeMarket()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeMarket::InitAsDefaultInstance() {
}

MazeMarket::MazeMarket(const MazeMarket& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeMarket::SharedCtor() {
  _cached_size_ = 0;
  sit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeMarket::~MazeMarket() {
  SharedDtor();
}

void MazeMarket::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeMarket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeMarket::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeMarket_descriptor_;
}

const MazeMarket& MazeMarket::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeMarket* MazeMarket::default_instance_ = NULL;

MazeMarket* MazeMarket::New() const {
  return new MazeMarket;
}

void MazeMarket::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sit_ = 0;
  }
  market_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeMarket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 sit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sit_)));
          set_has_sit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_market;
        break;
      }
      
      // repeated .protobuf.maze.MazeShop market = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_market:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_market()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_market;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeMarket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 sit = 1;
  if (has_sit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->sit(), output);
  }
  
  // repeated .protobuf.maze.MazeShop market = 2;
  for (int i = 0; i < this->market_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->market(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeMarket::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 sit = 1;
  if (has_sit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->sit(), target);
  }
  
  // repeated .protobuf.maze.MazeShop market = 2;
  for (int i = 0; i < this->market_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->market(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeMarket::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 sit = 1;
    if (has_sit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sit());
    }
    
  }
  // repeated .protobuf.maze.MazeShop market = 2;
  total_size += 1 * this->market_size();
  for (int i = 0; i < this->market_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->market(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeMarket::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeMarket* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeMarket*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeMarket::MergeFrom(const MazeMarket& from) {
  GOOGLE_CHECK_NE(&from, this);
  market_.MergeFrom(from.market_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sit()) {
      set_sit(from.sit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeMarket::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeMarket::CopyFrom(const MazeMarket& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeMarket::IsInitialized() const {
  
  return true;
}

void MazeMarket::Swap(MazeMarket* other) {
  if (other != this) {
    std::swap(sit_, other->sit_);
    market_.Swap(&other->market_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeMarket::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeMarket_descriptor_;
  metadata.reflection = MazeMarket_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeShop::kMarketIdFieldNumber;
const int MazeShop::kIsShopFieldNumber;
const int MazeShop::kItemIdFieldNumber;
#endif  // !_MSC_VER

MazeShop::MazeShop()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeShop::InitAsDefaultInstance() {
}

MazeShop::MazeShop(const MazeShop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeShop::SharedCtor() {
  _cached_size_ = 0;
  marketid_ = 0;
  isshop_ = false;
  itemid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeShop::~MazeShop() {
  SharedDtor();
}

void MazeShop::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeShop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeShop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeShop_descriptor_;
}

const MazeShop& MazeShop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeShop* MazeShop::default_instance_ = NULL;

MazeShop* MazeShop::New() const {
  return new MazeShop;
}

void MazeShop::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    marketid_ = 0;
    isshop_ = false;
    itemid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeShop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 marketId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &marketid_)));
          set_has_marketid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_isShop;
        break;
      }
      
      // optional bool isShop = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isShop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isshop_)));
          set_has_isshop();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_itemId;
        break;
      }
      
      // optional int32 itemId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_itemId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &itemid_)));
          set_has_itemid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeShop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 marketId = 1;
  if (has_marketid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->marketid(), output);
  }
  
  // optional bool isShop = 2;
  if (has_isshop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isshop(), output);
  }
  
  // optional int32 itemId = 3;
  if (has_itemid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->itemid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeShop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 marketId = 1;
  if (has_marketid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->marketid(), target);
  }
  
  // optional bool isShop = 2;
  if (has_isshop()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->isshop(), target);
  }
  
  // optional int32 itemId = 3;
  if (has_itemid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->itemid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeShop::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 marketId = 1;
    if (has_marketid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->marketid());
    }
    
    // optional bool isShop = 2;
    if (has_isshop()) {
      total_size += 1 + 1;
    }
    
    // optional int32 itemId = 3;
    if (has_itemid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->itemid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeShop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeShop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeShop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeShop::MergeFrom(const MazeShop& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_marketid()) {
      set_marketid(from.marketid());
    }
    if (from.has_isshop()) {
      set_isshop(from.isshop());
    }
    if (from.has_itemid()) {
      set_itemid(from.itemid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeShop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeShop::CopyFrom(const MazeShop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeShop::IsInitialized() const {
  
  return true;
}

void MazeShop::Swap(MazeShop* other) {
  if (other != this) {
    std::swap(marketid_, other->marketid_);
    std::swap(isshop_, other->isshop_);
    std::swap(itemid_, other->itemid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeShop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeShop_descriptor_;
  metadata.reflection = MazeShop_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeHelpHero::kSitFieldNumber;
const int MazeHelpHero::kHeroFieldNumber;
#endif  // !_MSC_VER

MazeHelpHero::MazeHelpHero()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeHelpHero::InitAsDefaultInstance() {
}

MazeHelpHero::MazeHelpHero(const MazeHelpHero& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeHelpHero::SharedCtor() {
  _cached_size_ = 0;
  sit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeHelpHero::~MazeHelpHero() {
  SharedDtor();
}

void MazeHelpHero::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeHelpHero::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeHelpHero::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeHelpHero_descriptor_;
}

const MazeHelpHero& MazeHelpHero::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeHelpHero* MazeHelpHero::default_instance_ = NULL;

MazeHelpHero* MazeHelpHero::New() const {
  return new MazeHelpHero;
}

void MazeHelpHero::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sit_ = 0;
  }
  hero_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeHelpHero::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 sit = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sit_)));
          set_has_sit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hero;
        break;
      }
      
      // repeated .protobuf.common.Hero hero = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_hero:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_hero()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_hero;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeHelpHero::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 sit = 1;
  if (has_sit()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->sit(), output);
  }
  
  // repeated .protobuf.common.Hero hero = 2;
  for (int i = 0; i < this->hero_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->hero(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeHelpHero::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 sit = 1;
  if (has_sit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->sit(), target);
  }
  
  // repeated .protobuf.common.Hero hero = 2;
  for (int i = 0; i < this->hero_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->hero(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeHelpHero::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 sit = 1;
    if (has_sit()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sit());
    }
    
  }
  // repeated .protobuf.common.Hero hero = 2;
  total_size += 1 * this->hero_size();
  for (int i = 0; i < this->hero_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->hero(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeHelpHero::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeHelpHero* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeHelpHero*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeHelpHero::MergeFrom(const MazeHelpHero& from) {
  GOOGLE_CHECK_NE(&from, this);
  hero_.MergeFrom(from.hero_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sit()) {
      set_sit(from.sit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeHelpHero::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeHelpHero::CopyFrom(const MazeHelpHero& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeHelpHero::IsInitialized() const {
  
  for (int i = 0; i < hero_size(); i++) {
    if (!this->hero(i).IsInitialized()) return false;
  }
  return true;
}

void MazeHelpHero::Swap(MazeHelpHero* other) {
  if (other != this) {
    std::swap(sit_, other->sit_);
    hero_.Swap(&other->hero_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeHelpHero::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeHelpHero_descriptor_;
  metadata.reflection = MazeHelpHero_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MazeKVint::kKeyFieldNumber;
const int MazeKVint::kValueFieldNumber;
const int MazeKVint::kTypeFieldNumber;
const int MazeKVint::kMapIdFieldNumber;
#endif  // !_MSC_VER

MazeKVint::MazeKVint()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MazeKVint::InitAsDefaultInstance() {
}

MazeKVint::MazeKVint(const MazeKVint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MazeKVint::SharedCtor() {
  _cached_size_ = 0;
  key_ = 0;
  value_ = 0;
  type_ = 0;
  mapid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MazeKVint::~MazeKVint() {
  SharedDtor();
}

void MazeKVint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MazeKVint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MazeKVint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MazeKVint_descriptor_;
}

const MazeKVint& MazeKVint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

MazeKVint* MazeKVint::default_instance_ = NULL;

MazeKVint* MazeKVint::New() const {
  return new MazeKVint;
}

void MazeKVint::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    key_ = 0;
    value_ = 0;
    type_ = 0;
    mapid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MazeKVint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &key_)));
          set_has_key();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }
      
      // required int32 value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }
      
      // required int32 type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_mapId;
        break;
      }
      
      // required int32 mapId = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MazeKVint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->key(), output);
  }
  
  // required int32 value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->value(), output);
  }
  
  // required int32 type = 3;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->type(), output);
  }
  
  // required int32 mapId = 4;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->mapid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MazeKVint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 key = 1;
  if (has_key()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->key(), target);
  }
  
  // required int32 value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->value(), target);
  }
  
  // required int32 type = 3;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->type(), target);
  }
  
  // required int32 mapId = 4;
  if (has_mapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->mapid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MazeKVint::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->key());
    }
    
    // required int32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->value());
    }
    
    // required int32 type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }
    
    // required int32 mapId = 4;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MazeKVint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MazeKVint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MazeKVint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MazeKVint::MergeFrom(const MazeKVint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MazeKVint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MazeKVint::CopyFrom(const MazeKVint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MazeKVint::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

void MazeKVint::Swap(MazeKVint* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(type_, other->type_);
    std::swap(mapid_, other->mapid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MazeKVint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MazeKVint_descriptor_;
  metadata.reflection = MazeKVint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TopTimeInfo::kOpenMapFieldNumber;
#endif  // !_MSC_VER

TopTimeInfo::TopTimeInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TopTimeInfo::InitAsDefaultInstance() {
}

TopTimeInfo::TopTimeInfo(const TopTimeInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TopTimeInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TopTimeInfo::~TopTimeInfo() {
  SharedDtor();
}

void TopTimeInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TopTimeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TopTimeInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TopTimeInfo_descriptor_;
}

const TopTimeInfo& TopTimeInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_maze_2eproto();  return *default_instance_;
}

TopTimeInfo* TopTimeInfo::default_instance_ = NULL;

TopTimeInfo* TopTimeInfo::New() const {
  return new TopTimeInfo;
}

void TopTimeInfo::Clear() {
  openmap_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TopTimeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .protobuf.common.KVint32List32 openMap = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_openMap:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_openmap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_openMap;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TopTimeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .protobuf.common.KVint32List32 openMap = 1;
  for (int i = 0; i < this->openmap_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->openmap(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TopTimeInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .protobuf.common.KVint32List32 openMap = 1;
  for (int i = 0; i < this->openmap_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->openmap(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TopTimeInfo::ByteSize() const {
  int total_size = 0;
  
  // repeated .protobuf.common.KVint32List32 openMap = 1;
  total_size += 1 * this->openmap_size();
  for (int i = 0; i < this->openmap_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->openmap(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TopTimeInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TopTimeInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TopTimeInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TopTimeInfo::MergeFrom(const TopTimeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  openmap_.MergeFrom(from.openmap_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TopTimeInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TopTimeInfo::CopyFrom(const TopTimeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TopTimeInfo::IsInitialized() const {
  
  for (int i = 0; i < openmap_size(); i++) {
    if (!this->openmap(i).IsInitialized()) return false;
  }
  return true;
}

void TopTimeInfo::Swap(TopTimeInfo* other) {
  if (other != this) {
    openmap_.Swap(&other->openmap_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TopTimeInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TopTimeInfo_descriptor_;
  metadata.reflection = TopTimeInfo_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace maze
}  // namespace protobuf

// @@protoc_insertion_point(global_scope)
