// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: champion.proto

#ifndef PROTOBUF_champion_2eproto__INCLUDED
#define PROTOBUF_champion_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace champion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_champion_2eproto();
void protobuf_AssignDesc_champion_2eproto();
void protobuf_ShutdownFile_champion_2eproto();

class ChampionLineup;
class BattleStartM;
class iconinfo;
class playerInfoList;
class BattleHistory;
class BattleHistoryList;
class BattleVideoList;
class BattleLineupDetail;
class NewBattleStartM;

// ===================================================================

class ChampionLineup : public ::google::protobuf::Message {
 public:
  ChampionLineup();
  virtual ~ChampionLineup();
  
  ChampionLineup(const ChampionLineup& from);
  
  inline ChampionLineup& operator=(const ChampionLineup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChampionLineup& default_instance();
  
  void Swap(ChampionLineup* other);
  
  // implements Message ----------------------------------------------
  
  ChampionLineup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChampionLineup& from);
  void MergeFrom(const ChampionLineup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // repeated .protobuf.common.LineupTemplate lineup = 2;
  inline int lineup_size() const;
  inline void clear_lineup();
  static const int kLineupFieldNumber = 2;
  inline const ::protobuf::common::LineupTemplate& lineup(int index) const;
  inline ::protobuf::common::LineupTemplate* mutable_lineup(int index);
  inline ::protobuf::common::LineupTemplate* add_lineup();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
      lineup() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
      mutable_lineup();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.ChampionLineup)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate > lineup_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static ChampionLineup* default_instance_;
};
// -------------------------------------------------------------------

class BattleStartM : public ::google::protobuf::Message {
 public:
  BattleStartM();
  virtual ~BattleStartM();
  
  BattleStartM(const BattleStartM& from);
  
  inline BattleStartM& operator=(const BattleStartM& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleStartM& default_instance();
  
  void Swap(BattleStartM* other);
  
  // implements Message ----------------------------------------------
  
  BattleStartM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleStartM& from);
  void MergeFrom(const BattleStartM& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string enemyId = 2;
  inline bool has_enemyid() const;
  inline void clear_enemyid();
  static const int kEnemyIdFieldNumber = 2;
  inline const ::std::string& enemyid() const;
  inline void set_enemyid(const ::std::string& value);
  inline void set_enemyid(const char* value);
  inline void set_enemyid(const char* value, size_t size);
  inline ::std::string* mutable_enemyid();
  inline ::std::string* release_enemyid();
  
  // required bool result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline bool result() const;
  inline void set_result(bool value);
  
  // required string sign = 4;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 4;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  
  // repeated bool perResult = 5;
  inline int perresult_size() const;
  inline void clear_perresult();
  static const int kPerResultFieldNumber = 5;
  inline bool perresult(int index) const;
  inline void set_perresult(int index, bool value);
  inline void add_perresult(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      perresult() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_perresult();
  
  // repeated .protobuf.common.LineupTemplate perLineup = 6;
  inline int perlineup_size() const;
  inline void clear_perlineup();
  static const int kPerLineupFieldNumber = 6;
  inline const ::protobuf::common::LineupTemplate& perlineup(int index) const;
  inline ::protobuf::common::LineupTemplate* mutable_perlineup(int index);
  inline ::protobuf::common::LineupTemplate* add_perlineup();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
      perlineup() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
      mutable_perlineup();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.BattleStartM)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enemyid();
  inline void clear_has_enemyid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_sign();
  inline void clear_has_sign();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* enemyid_;
  ::google::protobuf::int32 type_;
  bool result_;
  ::std::string* sign_;
  ::google::protobuf::RepeatedField< bool > perresult_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate > perlineup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static BattleStartM* default_instance_;
};
// -------------------------------------------------------------------

class iconinfo : public ::google::protobuf::Message {
 public:
  iconinfo();
  virtual ~iconinfo();
  
  iconinfo(const iconinfo& from);
  
  inline iconinfo& operator=(const iconinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const iconinfo& default_instance();
  
  void Swap(iconinfo* other);
  
  // implements Message ----------------------------------------------
  
  iconinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const iconinfo& from);
  void MergeFrom(const iconinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string head = 3;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 3;
  inline const ::std::string& head() const;
  inline void set_head(const ::std::string& value);
  inline void set_head(const char* value);
  inline void set_head(const char* value, size_t size);
  inline ::std::string* mutable_head();
  inline ::std::string* release_head();
  
  // optional string guildName = 4;
  inline bool has_guildname() const;
  inline void clear_guildname();
  static const int kGuildNameFieldNumber = 4;
  inline const ::std::string& guildname() const;
  inline void set_guildname(const ::std::string& value);
  inline void set_guildname(const char* value);
  inline void set_guildname(const char* value, size_t size);
  inline ::std::string* mutable_guildname();
  inline ::std::string* release_guildname();
  
  // optional string serverName = 5;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 5;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  
  // optional string playerid = 6;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 6;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 rank = 7;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 7;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // optional int64 rankPoints = 8;
  inline bool has_rankpoints() const;
  inline void clear_rankpoints();
  static const int kRankPointsFieldNumber = 8;
  inline ::google::protobuf::int64 rankpoints() const;
  inline void set_rankpoints(::google::protobuf::int64 value);
  
  // optional int32 power = 9;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 9;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);
  
  // optional int32 headFrame = 10;
  inline bool has_headframe() const;
  inline void clear_headframe();
  static const int kHeadFrameFieldNumber = 10;
  inline ::google::protobuf::int32 headframe() const;
  inline void set_headframe(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.iconinfo)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_guildname();
  inline void clear_has_guildname();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_rankpoints();
  inline void clear_has_rankpoints();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_headframe();
  inline void clear_has_headframe();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* head_;
  ::std::string* guildname_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 rank_;
  ::std::string* servername_;
  ::std::string* playerid_;
  ::google::protobuf::int64 rankpoints_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 headframe_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static iconinfo* default_instance_;
};
// -------------------------------------------------------------------

class playerInfoList : public ::google::protobuf::Message {
 public:
  playerInfoList();
  virtual ~playerInfoList();
  
  playerInfoList(const playerInfoList& from);
  
  inline playerInfoList& operator=(const playerInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const playerInfoList& default_instance();
  
  void Swap(playerInfoList* other);
  
  // implements Message ----------------------------------------------
  
  playerInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerInfoList& from);
  void MergeFrom(const playerInfoList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.champion.iconinfo showinfo = 1;
  inline int showinfo_size() const;
  inline void clear_showinfo();
  static const int kShowinfoFieldNumber = 1;
  inline const ::protobuf::champion::iconinfo& showinfo(int index) const;
  inline ::protobuf::champion::iconinfo* mutable_showinfo(int index);
  inline ::protobuf::champion::iconinfo* add_showinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::champion::iconinfo >&
      showinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::champion::iconinfo >*
      mutable_showinfo();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.playerInfoList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::champion::iconinfo > showinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static playerInfoList* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistory : public ::google::protobuf::Message {
 public:
  BattleHistory();
  virtual ~BattleHistory();
  
  BattleHistory(const BattleHistory& from);
  
  inline BattleHistory& operator=(const BattleHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleHistory& default_instance();
  
  void Swap(BattleHistory* other);
  
  // implements Message ----------------------------------------------
  
  BattleHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleHistory& from);
  void MergeFrom(const BattleHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string attackName = 2;
  inline bool has_attackname() const;
  inline void clear_attackname();
  static const int kAttackNameFieldNumber = 2;
  inline const ::std::string& attackname() const;
  inline void set_attackname(const ::std::string& value);
  inline void set_attackname(const char* value);
  inline void set_attackname(const char* value, size_t size);
  inline ::std::string* mutable_attackname();
  inline ::std::string* release_attackname();
  
  // required int32 attackLvl = 3;
  inline bool has_attacklvl() const;
  inline void clear_attacklvl();
  static const int kAttackLvlFieldNumber = 3;
  inline ::google::protobuf::int32 attacklvl() const;
  inline void set_attacklvl(::google::protobuf::int32 value);
  
  // required string attackHead = 4;
  inline bool has_attackhead() const;
  inline void clear_attackhead();
  static const int kAttackHeadFieldNumber = 4;
  inline const ::std::string& attackhead() const;
  inline void set_attackhead(const ::std::string& value);
  inline void set_attackhead(const char* value);
  inline void set_attackhead(const char* value, size_t size);
  inline ::std::string* mutable_attackhead();
  inline ::std::string* release_attackhead();
  
  // required string attackId = 5;
  inline bool has_attackid() const;
  inline void clear_attackid();
  static const int kAttackIdFieldNumber = 5;
  inline const ::std::string& attackid() const;
  inline void set_attackid(const ::std::string& value);
  inline void set_attackid(const char* value);
  inline void set_attackid(const char* value, size_t size);
  inline ::std::string* mutable_attackid();
  inline ::std::string* release_attackid();
  
  // optional int32 atHeadFrame = 6;
  inline bool has_atheadframe() const;
  inline void clear_atheadframe();
  static const int kAtHeadFrameFieldNumber = 6;
  inline ::google::protobuf::int32 atheadframe() const;
  inline void set_atheadframe(::google::protobuf::int32 value);
  
  // required string defenseId = 7;
  inline bool has_defenseid() const;
  inline void clear_defenseid();
  static const int kDefenseIdFieldNumber = 7;
  inline const ::std::string& defenseid() const;
  inline void set_defenseid(const ::std::string& value);
  inline void set_defenseid(const char* value);
  inline void set_defenseid(const char* value, size_t size);
  inline ::std::string* mutable_defenseid();
  inline ::std::string* release_defenseid();
  
  // required string defenseName = 8;
  inline bool has_defensename() const;
  inline void clear_defensename();
  static const int kDefenseNameFieldNumber = 8;
  inline const ::std::string& defensename() const;
  inline void set_defensename(const ::std::string& value);
  inline void set_defensename(const char* value);
  inline void set_defensename(const char* value, size_t size);
  inline ::std::string* mutable_defensename();
  inline ::std::string* release_defensename();
  
  // required int32 defenseLvl = 9;
  inline bool has_defenselvl() const;
  inline void clear_defenselvl();
  static const int kDefenseLvlFieldNumber = 9;
  inline ::google::protobuf::int32 defenselvl() const;
  inline void set_defenselvl(::google::protobuf::int32 value);
  
  // required string defenseHead = 10;
  inline bool has_defensehead() const;
  inline void clear_defensehead();
  static const int kDefenseHeadFieldNumber = 10;
  inline const ::std::string& defensehead() const;
  inline void set_defensehead(const ::std::string& value);
  inline void set_defensehead(const char* value);
  inline void set_defensehead(const char* value, size_t size);
  inline ::std::string* mutable_defensehead();
  inline ::std::string* release_defensehead();
  
  // optional int32 deHeadFrame = 11;
  inline bool has_deheadframe() const;
  inline void clear_deheadframe();
  static const int kDeHeadFrameFieldNumber = 11;
  inline ::google::protobuf::int32 deheadframe() const;
  inline void set_deheadframe(::google::protobuf::int32 value);
  
  // required bool victory = 14;
  inline bool has_victory() const;
  inline void clear_victory();
  static const int kVictoryFieldNumber = 14;
  inline bool victory() const;
  inline void set_victory(bool value);
  
  // optional int32 attackPoint = 15;
  inline bool has_attackpoint() const;
  inline void clear_attackpoint();
  static const int kAttackPointFieldNumber = 15;
  inline ::google::protobuf::int32 attackpoint() const;
  inline void set_attackpoint(::google::protobuf::int32 value);
  
  // optional int32 defensePoint = 16;
  inline bool has_defensepoint() const;
  inline void clear_defensepoint();
  static const int kDefensePointFieldNumber = 16;
  inline ::google::protobuf::int32 defensepoint() const;
  inline void set_defensepoint(::google::protobuf::int32 value);
  
  // required int64 time = 17;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 17;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // repeated bool oneVictory = 18;
  inline int onevictory_size() const;
  inline void clear_onevictory();
  static const int kOneVictoryFieldNumber = 18;
  inline bool onevictory(int index) const;
  inline void set_onevictory(int index, bool value);
  inline void add_onevictory(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      onevictory() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_onevictory();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.BattleHistory)
 private:
  inline void set_has_attackname();
  inline void clear_has_attackname();
  inline void set_has_attacklvl();
  inline void clear_has_attacklvl();
  inline void set_has_attackhead();
  inline void clear_has_attackhead();
  inline void set_has_attackid();
  inline void clear_has_attackid();
  inline void set_has_atheadframe();
  inline void clear_has_atheadframe();
  inline void set_has_defenseid();
  inline void clear_has_defenseid();
  inline void set_has_defensename();
  inline void clear_has_defensename();
  inline void set_has_defenselvl();
  inline void clear_has_defenselvl();
  inline void set_has_defensehead();
  inline void clear_has_defensehead();
  inline void set_has_deheadframe();
  inline void clear_has_deheadframe();
  inline void set_has_victory();
  inline void clear_has_victory();
  inline void set_has_attackpoint();
  inline void clear_has_attackpoint();
  inline void set_has_defensepoint();
  inline void clear_has_defensepoint();
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* attackname_;
  ::std::string* attackhead_;
  ::google::protobuf::int32 attacklvl_;
  ::google::protobuf::int32 atheadframe_;
  ::std::string* attackid_;
  ::std::string* defenseid_;
  ::std::string* defensename_;
  ::std::string* defensehead_;
  ::google::protobuf::int32 defenselvl_;
  ::google::protobuf::int32 deheadframe_;
  bool victory_;
  ::google::protobuf::int32 attackpoint_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::RepeatedField< bool > onevictory_;
  ::google::protobuf::int32 defensepoint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static BattleHistory* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistoryList : public ::google::protobuf::Message {
 public:
  BattleHistoryList();
  virtual ~BattleHistoryList();
  
  BattleHistoryList(const BattleHistoryList& from);
  
  inline BattleHistoryList& operator=(const BattleHistoryList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleHistoryList& default_instance();
  
  void Swap(BattleHistoryList* other);
  
  // implements Message ----------------------------------------------
  
  BattleHistoryList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleHistoryList& from);
  void MergeFrom(const BattleHistoryList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.champion.BattleHistory battles = 1;
  inline int battles_size() const;
  inline void clear_battles();
  static const int kBattlesFieldNumber = 1;
  inline const ::protobuf::champion::BattleHistory& battles(int index) const;
  inline ::protobuf::champion::BattleHistory* mutable_battles(int index);
  inline ::protobuf::champion::BattleHistory* add_battles();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleHistory >&
      battles() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleHistory >*
      mutable_battles();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.BattleHistoryList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleHistory > battles_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static BattleHistoryList* default_instance_;
};
// -------------------------------------------------------------------

class BattleVideoList : public ::google::protobuf::Message {
 public:
  BattleVideoList();
  virtual ~BattleVideoList();
  
  BattleVideoList(const BattleVideoList& from);
  
  inline BattleVideoList& operator=(const BattleVideoList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleVideoList& default_instance();
  
  void Swap(BattleVideoList* other);
  
  // implements Message ----------------------------------------------
  
  BattleVideoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleVideoList& from);
  void MergeFrom(const BattleVideoList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.champion.BattleLineupDetail videos = 1;
  inline int videos_size() const;
  inline void clear_videos();
  static const int kVideosFieldNumber = 1;
  inline const ::protobuf::champion::BattleLineupDetail& videos(int index) const;
  inline ::protobuf::champion::BattleLineupDetail* mutable_videos(int index);
  inline ::protobuf::champion::BattleLineupDetail* add_videos();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleLineupDetail >&
      videos() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleLineupDetail >*
      mutable_videos();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.BattleVideoList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleLineupDetail > videos_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static BattleVideoList* default_instance_;
};
// -------------------------------------------------------------------

class BattleLineupDetail : public ::google::protobuf::Message {
 public:
  BattleLineupDetail();
  virtual ~BattleLineupDetail();
  
  BattleLineupDetail(const BattleLineupDetail& from);
  
  inline BattleLineupDetail& operator=(const BattleLineupDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleLineupDetail& default_instance();
  
  void Swap(BattleLineupDetail* other);
  
  // implements Message ----------------------------------------------
  
  BattleLineupDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleLineupDetail& from);
  void MergeFrom(const BattleLineupDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 seed = 1;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 1;
  inline ::google::protobuf::int64 seed() const;
  inline void set_seed(::google::protobuf::int64 value);
  
  // required bool victory = 2;
  inline bool has_victory() const;
  inline void clear_victory();
  static const int kVictoryFieldNumber = 2;
  inline bool victory() const;
  inline void set_victory(bool value);
  
  // required .protobuf.common.LineupDetail attacker = 3;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 3;
  inline const ::protobuf::common::LineupDetail& attacker() const;
  inline ::protobuf::common::LineupDetail* mutable_attacker();
  inline ::protobuf::common::LineupDetail* release_attacker();
  
  // required .protobuf.common.LineupDetail defineer = 4;
  inline bool has_defineer() const;
  inline void clear_defineer();
  static const int kDefineerFieldNumber = 4;
  inline const ::protobuf::common::LineupDetail& defineer() const;
  inline ::protobuf::common::LineupDetail* mutable_defineer();
  inline ::protobuf::common::LineupDetail* release_defineer();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.BattleLineupDetail)
 private:
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_victory();
  inline void clear_has_victory();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_defineer();
  inline void clear_has_defineer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 seed_;
  ::protobuf::common::LineupDetail* attacker_;
  ::protobuf::common::LineupDetail* defineer_;
  bool victory_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static BattleLineupDetail* default_instance_;
};
// -------------------------------------------------------------------

class NewBattleStartM : public ::google::protobuf::Message {
 public:
  NewBattleStartM();
  virtual ~NewBattleStartM();
  
  NewBattleStartM(const NewBattleStartM& from);
  
  inline NewBattleStartM& operator=(const NewBattleStartM& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewBattleStartM& default_instance();
  
  void Swap(NewBattleStartM* other);
  
  // implements Message ----------------------------------------------
  
  NewBattleStartM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewBattleStartM& from);
  void MergeFrom(const NewBattleStartM& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string enemyId = 2;
  inline bool has_enemyid() const;
  inline void clear_enemyid();
  static const int kEnemyIdFieldNumber = 2;
  inline const ::std::string& enemyid() const;
  inline void set_enemyid(const ::std::string& value);
  inline void set_enemyid(const char* value);
  inline void set_enemyid(const char* value, size_t size);
  inline ::std::string* mutable_enemyid();
  inline ::std::string* release_enemyid();
  
  // repeated .protobuf.common.LineupTemplate perLineup = 6;
  inline int perlineup_size() const;
  inline void clear_perlineup();
  static const int kPerLineupFieldNumber = 6;
  inline const ::protobuf::common::LineupTemplate& perlineup(int index) const;
  inline ::protobuf::common::LineupTemplate* mutable_perlineup(int index);
  inline ::protobuf::common::LineupTemplate* add_perlineup();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
      perlineup() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
      mutable_perlineup();
  
  // @@protoc_insertion_point(class_scope:protobuf.champion.NewBattleStartM)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enemyid();
  inline void clear_has_enemyid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* enemyid_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate > perlineup_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_champion_2eproto();
  friend void protobuf_AssignDesc_champion_2eproto();
  friend void protobuf_ShutdownFile_champion_2eproto();
  
  void InitAsDefaultInstance();
  static NewBattleStartM* default_instance_;
};
// ===================================================================


// ===================================================================

// ChampionLineup

// optional int32 type = 1;
inline bool ChampionLineup::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChampionLineup::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChampionLineup::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChampionLineup::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ChampionLineup::type() const {
  return type_;
}
inline void ChampionLineup::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .protobuf.common.LineupTemplate lineup = 2;
inline int ChampionLineup::lineup_size() const {
  return lineup_.size();
}
inline void ChampionLineup::clear_lineup() {
  lineup_.Clear();
}
inline const ::protobuf::common::LineupTemplate& ChampionLineup::lineup(int index) const {
  return lineup_.Get(index);
}
inline ::protobuf::common::LineupTemplate* ChampionLineup::mutable_lineup(int index) {
  return lineup_.Mutable(index);
}
inline ::protobuf::common::LineupTemplate* ChampionLineup::add_lineup() {
  return lineup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
ChampionLineup::lineup() const {
  return lineup_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
ChampionLineup::mutable_lineup() {
  return &lineup_;
}

// -------------------------------------------------------------------

// BattleStartM

// required int32 type = 1;
inline bool BattleStartM::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleStartM::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleStartM::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleStartM::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 BattleStartM::type() const {
  return type_;
}
inline void BattleStartM::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string enemyId = 2;
inline bool BattleStartM::has_enemyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleStartM::set_has_enemyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleStartM::clear_has_enemyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleStartM::clear_enemyid() {
  if (enemyid_ != &::google::protobuf::internal::kEmptyString) {
    enemyid_->clear();
  }
  clear_has_enemyid();
}
inline const ::std::string& BattleStartM::enemyid() const {
  return *enemyid_;
}
inline void BattleStartM::set_enemyid(const ::std::string& value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleStartM::set_enemyid(const char* value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void BattleStartM::set_enemyid(const char* value, size_t size) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleStartM::mutable_enemyid() {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  return enemyid_;
}
inline ::std::string* BattleStartM::release_enemyid() {
  clear_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enemyid_;
    enemyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool result = 3;
inline bool BattleStartM::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleStartM::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleStartM::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleStartM::clear_result() {
  result_ = false;
  clear_has_result();
}
inline bool BattleStartM::result() const {
  return result_;
}
inline void BattleStartM::set_result(bool value) {
  set_has_result();
  result_ = value;
}

// required string sign = 4;
inline bool BattleStartM::has_sign() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleStartM::set_has_sign() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleStartM::clear_has_sign() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleStartM::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& BattleStartM::sign() const {
  return *sign_;
}
inline void BattleStartM::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void BattleStartM::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void BattleStartM::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleStartM::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* BattleStartM::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated bool perResult = 5;
inline int BattleStartM::perresult_size() const {
  return perresult_.size();
}
inline void BattleStartM::clear_perresult() {
  perresult_.Clear();
}
inline bool BattleStartM::perresult(int index) const {
  return perresult_.Get(index);
}
inline void BattleStartM::set_perresult(int index, bool value) {
  perresult_.Set(index, value);
}
inline void BattleStartM::add_perresult(bool value) {
  perresult_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
BattleStartM::perresult() const {
  return perresult_;
}
inline ::google::protobuf::RepeatedField< bool >*
BattleStartM::mutable_perresult() {
  return &perresult_;
}

// repeated .protobuf.common.LineupTemplate perLineup = 6;
inline int BattleStartM::perlineup_size() const {
  return perlineup_.size();
}
inline void BattleStartM::clear_perlineup() {
  perlineup_.Clear();
}
inline const ::protobuf::common::LineupTemplate& BattleStartM::perlineup(int index) const {
  return perlineup_.Get(index);
}
inline ::protobuf::common::LineupTemplate* BattleStartM::mutable_perlineup(int index) {
  return perlineup_.Mutable(index);
}
inline ::protobuf::common::LineupTemplate* BattleStartM::add_perlineup() {
  return perlineup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
BattleStartM::perlineup() const {
  return perlineup_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
BattleStartM::mutable_perlineup() {
  return &perlineup_;
}

// -------------------------------------------------------------------

// iconinfo

// required int32 level = 1;
inline bool iconinfo::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iconinfo::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iconinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iconinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 iconinfo::level() const {
  return level_;
}
inline void iconinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string name = 2;
inline bool iconinfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iconinfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iconinfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iconinfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& iconinfo::name() const {
  return *name_;
}
inline void iconinfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* iconinfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string head = 3;
inline bool iconinfo::has_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iconinfo::set_has_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iconinfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iconinfo::clear_head() {
  if (head_ != &::google::protobuf::internal::kEmptyString) {
    head_->clear();
  }
  clear_has_head();
}
inline const ::std::string& iconinfo::head() const {
  return *head_;
}
inline void iconinfo::set_head(const ::std::string& value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value, size_t size) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_head() {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  return head_;
}
inline ::std::string* iconinfo::release_head() {
  clear_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_;
    head_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string guildName = 4;
inline bool iconinfo::has_guildname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iconinfo::set_has_guildname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void iconinfo::clear_has_guildname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void iconinfo::clear_guildname() {
  if (guildname_ != &::google::protobuf::internal::kEmptyString) {
    guildname_->clear();
  }
  clear_has_guildname();
}
inline const ::std::string& iconinfo::guildname() const {
  return *guildname_;
}
inline void iconinfo::set_guildname(const ::std::string& value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void iconinfo::set_guildname(const char* value) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(value);
}
inline void iconinfo::set_guildname(const char* value, size_t size) {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  guildname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_guildname() {
  set_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    guildname_ = new ::std::string;
  }
  return guildname_;
}
inline ::std::string* iconinfo::release_guildname() {
  clear_has_guildname();
  if (guildname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guildname_;
    guildname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string serverName = 5;
inline bool iconinfo::has_servername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void iconinfo::set_has_servername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void iconinfo::clear_has_servername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void iconinfo::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& iconinfo::servername() const {
  return *servername_;
}
inline void iconinfo::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void iconinfo::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void iconinfo::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* iconinfo::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string playerid = 6;
inline bool iconinfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void iconinfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void iconinfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void iconinfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& iconinfo::playerid() const {
  return *playerid_;
}
inline void iconinfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* iconinfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rank = 7;
inline bool iconinfo::has_rank() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void iconinfo::set_has_rank() {
  _has_bits_[0] |= 0x00000040u;
}
inline void iconinfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void iconinfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 iconinfo::rank() const {
  return rank_;
}
inline void iconinfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int64 rankPoints = 8;
inline bool iconinfo::has_rankpoints() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void iconinfo::set_has_rankpoints() {
  _has_bits_[0] |= 0x00000080u;
}
inline void iconinfo::clear_has_rankpoints() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void iconinfo::clear_rankpoints() {
  rankpoints_ = GOOGLE_LONGLONG(0);
  clear_has_rankpoints();
}
inline ::google::protobuf::int64 iconinfo::rankpoints() const {
  return rankpoints_;
}
inline void iconinfo::set_rankpoints(::google::protobuf::int64 value) {
  set_has_rankpoints();
  rankpoints_ = value;
}

// optional int32 power = 9;
inline bool iconinfo::has_power() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void iconinfo::set_has_power() {
  _has_bits_[0] |= 0x00000100u;
}
inline void iconinfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void iconinfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 iconinfo::power() const {
  return power_;
}
inline void iconinfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 headFrame = 10;
inline bool iconinfo::has_headframe() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void iconinfo::set_has_headframe() {
  _has_bits_[0] |= 0x00000200u;
}
inline void iconinfo::clear_has_headframe() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void iconinfo::clear_headframe() {
  headframe_ = 0;
  clear_has_headframe();
}
inline ::google::protobuf::int32 iconinfo::headframe() const {
  return headframe_;
}
inline void iconinfo::set_headframe(::google::protobuf::int32 value) {
  set_has_headframe();
  headframe_ = value;
}

// -------------------------------------------------------------------

// playerInfoList

// repeated .protobuf.champion.iconinfo showinfo = 1;
inline int playerInfoList::showinfo_size() const {
  return showinfo_.size();
}
inline void playerInfoList::clear_showinfo() {
  showinfo_.Clear();
}
inline const ::protobuf::champion::iconinfo& playerInfoList::showinfo(int index) const {
  return showinfo_.Get(index);
}
inline ::protobuf::champion::iconinfo* playerInfoList::mutable_showinfo(int index) {
  return showinfo_.Mutable(index);
}
inline ::protobuf::champion::iconinfo* playerInfoList::add_showinfo() {
  return showinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::champion::iconinfo >&
playerInfoList::showinfo() const {
  return showinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::champion::iconinfo >*
playerInfoList::mutable_showinfo() {
  return &showinfo_;
}

// -------------------------------------------------------------------

// BattleHistory

// required string attackName = 2;
inline bool BattleHistory::has_attackname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleHistory::set_has_attackname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleHistory::clear_has_attackname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleHistory::clear_attackname() {
  if (attackname_ != &::google::protobuf::internal::kEmptyString) {
    attackname_->clear();
  }
  clear_has_attackname();
}
inline const ::std::string& BattleHistory::attackname() const {
  return *attackname_;
}
inline void BattleHistory::set_attackname(const ::std::string& value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void BattleHistory::set_attackname(const char* value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void BattleHistory::set_attackname(const char* value, size_t size) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackname() {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  return attackname_;
}
inline ::std::string* BattleHistory::release_attackname() {
  clear_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackname_;
    attackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 attackLvl = 3;
inline bool BattleHistory::has_attacklvl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleHistory::set_has_attacklvl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleHistory::clear_has_attacklvl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleHistory::clear_attacklvl() {
  attacklvl_ = 0;
  clear_has_attacklvl();
}
inline ::google::protobuf::int32 BattleHistory::attacklvl() const {
  return attacklvl_;
}
inline void BattleHistory::set_attacklvl(::google::protobuf::int32 value) {
  set_has_attacklvl();
  attacklvl_ = value;
}

// required string attackHead = 4;
inline bool BattleHistory::has_attackhead() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleHistory::set_has_attackhead() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleHistory::clear_has_attackhead() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleHistory::clear_attackhead() {
  if (attackhead_ != &::google::protobuf::internal::kEmptyString) {
    attackhead_->clear();
  }
  clear_has_attackhead();
}
inline const ::std::string& BattleHistory::attackhead() const {
  return *attackhead_;
}
inline void BattleHistory::set_attackhead(const ::std::string& value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void BattleHistory::set_attackhead(const char* value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void BattleHistory::set_attackhead(const char* value, size_t size) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackhead() {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  return attackhead_;
}
inline ::std::string* BattleHistory::release_attackhead() {
  clear_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackhead_;
    attackhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string attackId = 5;
inline bool BattleHistory::has_attackid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleHistory::set_has_attackid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleHistory::clear_has_attackid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleHistory::clear_attackid() {
  if (attackid_ != &::google::protobuf::internal::kEmptyString) {
    attackid_->clear();
  }
  clear_has_attackid();
}
inline const ::std::string& BattleHistory::attackid() const {
  return *attackid_;
}
inline void BattleHistory::set_attackid(const ::std::string& value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void BattleHistory::set_attackid(const char* value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void BattleHistory::set_attackid(const char* value, size_t size) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackid() {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  return attackid_;
}
inline ::std::string* BattleHistory::release_attackid() {
  clear_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackid_;
    attackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 atHeadFrame = 6;
inline bool BattleHistory::has_atheadframe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleHistory::set_has_atheadframe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleHistory::clear_has_atheadframe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleHistory::clear_atheadframe() {
  atheadframe_ = 0;
  clear_has_atheadframe();
}
inline ::google::protobuf::int32 BattleHistory::atheadframe() const {
  return atheadframe_;
}
inline void BattleHistory::set_atheadframe(::google::protobuf::int32 value) {
  set_has_atheadframe();
  atheadframe_ = value;
}

// required string defenseId = 7;
inline bool BattleHistory::has_defenseid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleHistory::set_has_defenseid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleHistory::clear_has_defenseid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleHistory::clear_defenseid() {
  if (defenseid_ != &::google::protobuf::internal::kEmptyString) {
    defenseid_->clear();
  }
  clear_has_defenseid();
}
inline const ::std::string& BattleHistory::defenseid() const {
  return *defenseid_;
}
inline void BattleHistory::set_defenseid(const ::std::string& value) {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  defenseid_->assign(value);
}
inline void BattleHistory::set_defenseid(const char* value) {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  defenseid_->assign(value);
}
inline void BattleHistory::set_defenseid(const char* value, size_t size) {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  defenseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_defenseid() {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  return defenseid_;
}
inline ::std::string* BattleHistory::release_defenseid() {
  clear_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defenseid_;
    defenseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string defenseName = 8;
inline bool BattleHistory::has_defensename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleHistory::set_has_defensename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleHistory::clear_has_defensename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleHistory::clear_defensename() {
  if (defensename_ != &::google::protobuf::internal::kEmptyString) {
    defensename_->clear();
  }
  clear_has_defensename();
}
inline const ::std::string& BattleHistory::defensename() const {
  return *defensename_;
}
inline void BattleHistory::set_defensename(const ::std::string& value) {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  defensename_->assign(value);
}
inline void BattleHistory::set_defensename(const char* value) {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  defensename_->assign(value);
}
inline void BattleHistory::set_defensename(const char* value, size_t size) {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  defensename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_defensename() {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  return defensename_;
}
inline ::std::string* BattleHistory::release_defensename() {
  clear_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defensename_;
    defensename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 defenseLvl = 9;
inline bool BattleHistory::has_defenselvl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleHistory::set_has_defenselvl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleHistory::clear_has_defenselvl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleHistory::clear_defenselvl() {
  defenselvl_ = 0;
  clear_has_defenselvl();
}
inline ::google::protobuf::int32 BattleHistory::defenselvl() const {
  return defenselvl_;
}
inline void BattleHistory::set_defenselvl(::google::protobuf::int32 value) {
  set_has_defenselvl();
  defenselvl_ = value;
}

// required string defenseHead = 10;
inline bool BattleHistory::has_defensehead() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleHistory::set_has_defensehead() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleHistory::clear_has_defensehead() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleHistory::clear_defensehead() {
  if (defensehead_ != &::google::protobuf::internal::kEmptyString) {
    defensehead_->clear();
  }
  clear_has_defensehead();
}
inline const ::std::string& BattleHistory::defensehead() const {
  return *defensehead_;
}
inline void BattleHistory::set_defensehead(const ::std::string& value) {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  defensehead_->assign(value);
}
inline void BattleHistory::set_defensehead(const char* value) {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  defensehead_->assign(value);
}
inline void BattleHistory::set_defensehead(const char* value, size_t size) {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  defensehead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_defensehead() {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  return defensehead_;
}
inline ::std::string* BattleHistory::release_defensehead() {
  clear_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defensehead_;
    defensehead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 deHeadFrame = 11;
inline bool BattleHistory::has_deheadframe() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleHistory::set_has_deheadframe() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleHistory::clear_has_deheadframe() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleHistory::clear_deheadframe() {
  deheadframe_ = 0;
  clear_has_deheadframe();
}
inline ::google::protobuf::int32 BattleHistory::deheadframe() const {
  return deheadframe_;
}
inline void BattleHistory::set_deheadframe(::google::protobuf::int32 value) {
  set_has_deheadframe();
  deheadframe_ = value;
}

// required bool victory = 14;
inline bool BattleHistory::has_victory() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleHistory::set_has_victory() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleHistory::clear_has_victory() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleHistory::clear_victory() {
  victory_ = false;
  clear_has_victory();
}
inline bool BattleHistory::victory() const {
  return victory_;
}
inline void BattleHistory::set_victory(bool value) {
  set_has_victory();
  victory_ = value;
}

// optional int32 attackPoint = 15;
inline bool BattleHistory::has_attackpoint() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BattleHistory::set_has_attackpoint() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BattleHistory::clear_has_attackpoint() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BattleHistory::clear_attackpoint() {
  attackpoint_ = 0;
  clear_has_attackpoint();
}
inline ::google::protobuf::int32 BattleHistory::attackpoint() const {
  return attackpoint_;
}
inline void BattleHistory::set_attackpoint(::google::protobuf::int32 value) {
  set_has_attackpoint();
  attackpoint_ = value;
}

// optional int32 defensePoint = 16;
inline bool BattleHistory::has_defensepoint() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BattleHistory::set_has_defensepoint() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BattleHistory::clear_has_defensepoint() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BattleHistory::clear_defensepoint() {
  defensepoint_ = 0;
  clear_has_defensepoint();
}
inline ::google::protobuf::int32 BattleHistory::defensepoint() const {
  return defensepoint_;
}
inline void BattleHistory::set_defensepoint(::google::protobuf::int32 value) {
  set_has_defensepoint();
  defensepoint_ = value;
}

// required int64 time = 17;
inline bool BattleHistory::has_time() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BattleHistory::set_has_time() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BattleHistory::clear_has_time() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BattleHistory::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 BattleHistory::time() const {
  return time_;
}
inline void BattleHistory::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// repeated bool oneVictory = 18;
inline int BattleHistory::onevictory_size() const {
  return onevictory_.size();
}
inline void BattleHistory::clear_onevictory() {
  onevictory_.Clear();
}
inline bool BattleHistory::onevictory(int index) const {
  return onevictory_.Get(index);
}
inline void BattleHistory::set_onevictory(int index, bool value) {
  onevictory_.Set(index, value);
}
inline void BattleHistory::add_onevictory(bool value) {
  onevictory_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
BattleHistory::onevictory() const {
  return onevictory_;
}
inline ::google::protobuf::RepeatedField< bool >*
BattleHistory::mutable_onevictory() {
  return &onevictory_;
}

// -------------------------------------------------------------------

// BattleHistoryList

// repeated .protobuf.champion.BattleHistory battles = 1;
inline int BattleHistoryList::battles_size() const {
  return battles_.size();
}
inline void BattleHistoryList::clear_battles() {
  battles_.Clear();
}
inline const ::protobuf::champion::BattleHistory& BattleHistoryList::battles(int index) const {
  return battles_.Get(index);
}
inline ::protobuf::champion::BattleHistory* BattleHistoryList::mutable_battles(int index) {
  return battles_.Mutable(index);
}
inline ::protobuf::champion::BattleHistory* BattleHistoryList::add_battles() {
  return battles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleHistory >&
BattleHistoryList::battles() const {
  return battles_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleHistory >*
BattleHistoryList::mutable_battles() {
  return &battles_;
}

// -------------------------------------------------------------------

// BattleVideoList

// repeated .protobuf.champion.BattleLineupDetail videos = 1;
inline int BattleVideoList::videos_size() const {
  return videos_.size();
}
inline void BattleVideoList::clear_videos() {
  videos_.Clear();
}
inline const ::protobuf::champion::BattleLineupDetail& BattleVideoList::videos(int index) const {
  return videos_.Get(index);
}
inline ::protobuf::champion::BattleLineupDetail* BattleVideoList::mutable_videos(int index) {
  return videos_.Mutable(index);
}
inline ::protobuf::champion::BattleLineupDetail* BattleVideoList::add_videos() {
  return videos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleLineupDetail >&
BattleVideoList::videos() const {
  return videos_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::champion::BattleLineupDetail >*
BattleVideoList::mutable_videos() {
  return &videos_;
}

// -------------------------------------------------------------------

// BattleLineupDetail

// required int64 seed = 1;
inline bool BattleLineupDetail::has_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleLineupDetail::set_has_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleLineupDetail::clear_has_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleLineupDetail::clear_seed() {
  seed_ = GOOGLE_LONGLONG(0);
  clear_has_seed();
}
inline ::google::protobuf::int64 BattleLineupDetail::seed() const {
  return seed_;
}
inline void BattleLineupDetail::set_seed(::google::protobuf::int64 value) {
  set_has_seed();
  seed_ = value;
}

// required bool victory = 2;
inline bool BattleLineupDetail::has_victory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleLineupDetail::set_has_victory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleLineupDetail::clear_has_victory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleLineupDetail::clear_victory() {
  victory_ = false;
  clear_has_victory();
}
inline bool BattleLineupDetail::victory() const {
  return victory_;
}
inline void BattleLineupDetail::set_victory(bool value) {
  set_has_victory();
  victory_ = value;
}

// required .protobuf.common.LineupDetail attacker = 3;
inline bool BattleLineupDetail::has_attacker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleLineupDetail::set_has_attacker() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleLineupDetail::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleLineupDetail::clear_attacker() {
  if (attacker_ != NULL) attacker_->::protobuf::common::LineupDetail::Clear();
  clear_has_attacker();
}
inline const ::protobuf::common::LineupDetail& BattleLineupDetail::attacker() const {
  return attacker_ != NULL ? *attacker_ : *default_instance_->attacker_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == NULL) attacker_ = new ::protobuf::common::LineupDetail;
  return attacker_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::release_attacker() {
  clear_has_attacker();
  ::protobuf::common::LineupDetail* temp = attacker_;
  attacker_ = NULL;
  return temp;
}

// required .protobuf.common.LineupDetail defineer = 4;
inline bool BattleLineupDetail::has_defineer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleLineupDetail::set_has_defineer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleLineupDetail::clear_has_defineer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleLineupDetail::clear_defineer() {
  if (defineer_ != NULL) defineer_->::protobuf::common::LineupDetail::Clear();
  clear_has_defineer();
}
inline const ::protobuf::common::LineupDetail& BattleLineupDetail::defineer() const {
  return defineer_ != NULL ? *defineer_ : *default_instance_->defineer_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::mutable_defineer() {
  set_has_defineer();
  if (defineer_ == NULL) defineer_ = new ::protobuf::common::LineupDetail;
  return defineer_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::release_defineer() {
  clear_has_defineer();
  ::protobuf::common::LineupDetail* temp = defineer_;
  defineer_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NewBattleStartM

// required int32 type = 1;
inline bool NewBattleStartM::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewBattleStartM::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewBattleStartM::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewBattleStartM::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 NewBattleStartM::type() const {
  return type_;
}
inline void NewBattleStartM::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string enemyId = 2;
inline bool NewBattleStartM::has_enemyid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewBattleStartM::set_has_enemyid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewBattleStartM::clear_has_enemyid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewBattleStartM::clear_enemyid() {
  if (enemyid_ != &::google::protobuf::internal::kEmptyString) {
    enemyid_->clear();
  }
  clear_has_enemyid();
}
inline const ::std::string& NewBattleStartM::enemyid() const {
  return *enemyid_;
}
inline void NewBattleStartM::set_enemyid(const ::std::string& value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void NewBattleStartM::set_enemyid(const char* value) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(value);
}
inline void NewBattleStartM::set_enemyid(const char* value, size_t size) {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  enemyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewBattleStartM::mutable_enemyid() {
  set_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    enemyid_ = new ::std::string;
  }
  return enemyid_;
}
inline ::std::string* NewBattleStartM::release_enemyid() {
  clear_has_enemyid();
  if (enemyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enemyid_;
    enemyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .protobuf.common.LineupTemplate perLineup = 6;
inline int NewBattleStartM::perlineup_size() const {
  return perlineup_.size();
}
inline void NewBattleStartM::clear_perlineup() {
  perlineup_.Clear();
}
inline const ::protobuf::common::LineupTemplate& NewBattleStartM::perlineup(int index) const {
  return perlineup_.Get(index);
}
inline ::protobuf::common::LineupTemplate* NewBattleStartM::mutable_perlineup(int index) {
  return perlineup_.Mutable(index);
}
inline ::protobuf::common::LineupTemplate* NewBattleStartM::add_perlineup() {
  return perlineup_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >&
NewBattleStartM::perlineup() const {
  return perlineup_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::LineupTemplate >*
NewBattleStartM::mutable_perlineup() {
  return &perlineup_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace champion
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_champion_2eproto__INCLUDED
