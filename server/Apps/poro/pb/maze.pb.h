// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: maze.proto

#ifndef PROTOBUF_maze_2eproto__INCLUDED
#define PROTOBUF_maze_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace maze {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maze_2eproto();
void protobuf_AssignDesc_maze_2eproto();
void protobuf_ShutdownFile_maze_2eproto();

class MazeInfo;
class MazeEnemy;
class MazeHelpEnemy;
class MazeHero;
class MazeUpdate;
class MazeNext;
class MazeMarket;
class MazeShop;
class MazeHelpHero;
class MazeKVint;
class TopTimeInfo;

// ===================================================================

class MazeInfo : public ::google::protobuf::Message {
 public:
  MazeInfo();
  virtual ~MazeInfo();
  
  MazeInfo(const MazeInfo& from);
  
  inline MazeInfo& operator=(const MazeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeInfo& default_instance();
  
  void Swap(MazeInfo* other);
  
  // implements Message ----------------------------------------------
  
  MazeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeInfo& from);
  void MergeFrom(const MazeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 layer = 1;
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);
  
  // required bool isOpen = 2;
  inline bool has_isopen() const;
  inline void clear_isopen();
  static const int kIsOpenFieldNumber = 2;
  inline bool isopen() const;
  inline void set_isopen(bool value);
  
  // optional int64 updateTime = 3;
  inline bool has_updatetime() const;
  inline void clear_updatetime();
  static const int kUpdateTimeFieldNumber = 3;
  inline ::google::protobuf::int64 updatetime() const;
  inline void set_updatetime(::google::protobuf::int64 value);
  
  // optional int32 sit = 4;
  inline bool has_sit() const;
  inline void clear_sit();
  static const int kSitFieldNumber = 4;
  inline ::google::protobuf::int32 sit() const;
  inline void set_sit(::google::protobuf::int32 value);
  
  // optional int32 nextSit = 5;
  inline bool has_nextsit() const;
  inline void clear_nextsit();
  static const int kNextSitFieldNumber = 5;
  inline ::google::protobuf::int32 nextsit() const;
  inline void set_nextsit(::google::protobuf::int32 value);
  
  // repeated int32 buffPackage = 6;
  inline int buffpackage_size() const;
  inline void clear_buffpackage();
  static const int kBuffPackageFieldNumber = 6;
  inline ::google::protobuf::int32 buffpackage(int index) const;
  inline void set_buffpackage(int index, ::google::protobuf::int32 value);
  inline void add_buffpackage(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      buffpackage() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_buffpackage();
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 7;
  inline int herohelppackeage_size() const;
  inline void clear_herohelppackeage();
  static const int kHeroHelpPackeageFieldNumber = 7;
  inline const ::protobuf::common::Hero& herohelppackeage(int index) const;
  inline ::protobuf::common::Hero* mutable_herohelppackeage(int index);
  inline ::protobuf::common::Hero* add_herohelppackeage();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >&
      herohelppackeage() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >*
      mutable_herohelppackeage();
  
  // repeated .protobuf.maze.MazeHero heroPackeage = 8;
  inline int heropackeage_size() const;
  inline void clear_heropackeage();
  static const int kHeroPackeageFieldNumber = 8;
  inline const ::protobuf::maze::MazeHero& heropackeage(int index) const;
  inline ::protobuf::maze::MazeHero* mutable_heropackeage(int index);
  inline ::protobuf::maze::MazeHero* add_heropackeage();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >&
      heropackeage() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >*
      mutable_heropackeage();
  
  // repeated int32 queue = 9;
  inline int queue_size() const;
  inline void clear_queue();
  static const int kQueueFieldNumber = 9;
  inline ::google::protobuf::int32 queue(int index) const;
  inline void set_queue(int index, ::google::protobuf::int32 value);
  inline void add_queue(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      queue() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_queue();
  
  // repeated int32 pathWay = 10;
  inline int pathway_size() const;
  inline void clear_pathway();
  static const int kPathWayFieldNumber = 10;
  inline ::google::protobuf::int32 pathway(int index) const;
  inline void set_pathway(int index, ::google::protobuf::int32 value);
  inline void add_pathway(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      pathway() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_pathway();
  
  // repeated .protobuf.maze.MazeMarket mazeMarket = 11;
  inline int mazemarket_size() const;
  inline void clear_mazemarket();
  static const int kMazeMarketFieldNumber = 11;
  inline const ::protobuf::maze::MazeMarket& mazemarket(int index) const;
  inline ::protobuf::maze::MazeMarket* mutable_mazemarket(int index);
  inline ::protobuf::maze::MazeMarket* add_mazemarket();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeMarket >&
      mazemarket() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeMarket >*
      mutable_mazemarket();
  
  // optional int32 mapNumber = 12;
  inline bool has_mapnumber() const;
  inline void clear_mapnumber();
  static const int kMapNumberFieldNumber = 12;
  inline ::google::protobuf::int32 mapnumber() const;
  inline void set_mapnumber(::google::protobuf::int32 value);
  
  // repeated int32 haveReceiveSit = 13;
  inline int havereceivesit_size() const;
  inline void clear_havereceivesit();
  static const int kHaveReceiveSitFieldNumber = 13;
  inline ::google::protobuf::int32 havereceivesit(int index) const;
  inline void set_havereceivesit(int index, ::google::protobuf::int32 value);
  inline void add_havereceivesit(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      havereceivesit() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_havereceivesit();
  
  // repeated .protobuf.common.KVint3232 sitType = 14;
  inline int sittype_size() const;
  inline void clear_sittype();
  static const int kSitTypeFieldNumber = 14;
  inline const ::protobuf::common::KVint3232& sittype(int index) const;
  inline ::protobuf::common::KVint3232* mutable_sittype(int index);
  inline ::protobuf::common::KVint3232* add_sittype();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
      sittype() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
      mutable_sittype();
  
  // repeated .protobuf.common.KVint3232 fogNumber = 15;
  inline int fognumber_size() const;
  inline void clear_fognumber();
  static const int kFogNumberFieldNumber = 15;
  inline const ::protobuf::common::KVint3232& fognumber(int index) const;
  inline ::protobuf::common::KVint3232* mutable_fognumber(int index);
  inline ::protobuf::common::KVint3232* add_fognumber();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
      fognumber() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
      mutable_fognumber();
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeInfo)
 private:
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_isopen();
  inline void clear_has_isopen();
  inline void set_has_updatetime();
  inline void clear_has_updatetime();
  inline void set_has_sit();
  inline void clear_has_sit();
  inline void set_has_nextsit();
  inline void clear_has_nextsit();
  inline void set_has_mapnumber();
  inline void clear_has_mapnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 layer_;
  bool isopen_;
  ::google::protobuf::int64 updatetime_;
  ::google::protobuf::int32 sit_;
  ::google::protobuf::int32 nextsit_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > buffpackage_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero > herohelppackeage_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero > heropackeage_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > queue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pathway_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeMarket > mazemarket_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > havereceivesit_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 > sittype_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 > fognumber_;
  ::google::protobuf::int32 mapnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeInfo* default_instance_;
};
// -------------------------------------------------------------------

class MazeEnemy : public ::google::protobuf::Message {
 public:
  MazeEnemy();
  virtual ~MazeEnemy();
  
  MazeEnemy(const MazeEnemy& from);
  
  inline MazeEnemy& operator=(const MazeEnemy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeEnemy& default_instance();
  
  void Swap(MazeEnemy* other);
  
  // implements Message ----------------------------------------------
  
  MazeEnemy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeEnemy& from);
  void MergeFrom(const MazeEnemy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 enemySit = 1;
  inline bool has_enemysit() const;
  inline void clear_enemysit();
  static const int kEnemySitFieldNumber = 1;
  inline ::google::protobuf::int32 enemysit() const;
  inline void set_enemysit(::google::protobuf::int32 value);
  
  // optional .protobuf.common.LineupDetail enemyLineup = 2;
  inline bool has_enemylineup() const;
  inline void clear_enemylineup();
  static const int kEnemyLineupFieldNumber = 2;
  inline const ::protobuf::common::LineupDetail& enemylineup() const;
  inline ::protobuf::common::LineupDetail* mutable_enemylineup();
  inline ::protobuf::common::LineupDetail* release_enemylineup();
  
  // repeated .protobuf.common.KVint3264 awards = 3;
  inline int awards_size() const;
  inline void clear_awards();
  static const int kAwardsFieldNumber = 3;
  inline const ::protobuf::common::KVint3264& awards(int index) const;
  inline ::protobuf::common::KVint3264* mutable_awards(int index);
  inline ::protobuf::common::KVint3264* add_awards();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
      awards() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
      mutable_awards();
  
  // optional double chageValue = 4;
  inline bool has_chagevalue() const;
  inline void clear_chagevalue();
  static const int kChageValueFieldNumber = 4;
  inline double chagevalue() const;
  inline void set_chagevalue(double value);
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeEnemy)
 private:
  inline void set_has_enemysit();
  inline void clear_has_enemysit();
  inline void set_has_enemylineup();
  inline void clear_has_enemylineup();
  inline void set_has_chagevalue();
  inline void clear_has_chagevalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::protobuf::common::LineupDetail* enemylineup_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 > awards_;
  double chagevalue_;
  ::google::protobuf::int32 enemysit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeEnemy* default_instance_;
};
// -------------------------------------------------------------------

class MazeHelpEnemy : public ::google::protobuf::Message {
 public:
  MazeHelpEnemy();
  virtual ~MazeHelpEnemy();
  
  MazeHelpEnemy(const MazeHelpEnemy& from);
  
  inline MazeHelpEnemy& operator=(const MazeHelpEnemy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeHelpEnemy& default_instance();
  
  void Swap(MazeHelpEnemy* other);
  
  // implements Message ----------------------------------------------
  
  MazeHelpEnemy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeHelpEnemy& from);
  void MergeFrom(const MazeHelpEnemy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.maze.MazeEnemy enemyInfo = 1;
  inline int enemyinfo_size() const;
  inline void clear_enemyinfo();
  static const int kEnemyInfoFieldNumber = 1;
  inline const ::protobuf::maze::MazeEnemy& enemyinfo(int index) const;
  inline ::protobuf::maze::MazeEnemy* mutable_enemyinfo(int index);
  inline ::protobuf::maze::MazeEnemy* add_enemyinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeEnemy >&
      enemyinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeEnemy >*
      mutable_enemyinfo();
  
  // repeated .protobuf.maze.MazeHelpHero helpInfo = 2;
  inline int helpinfo_size() const;
  inline void clear_helpinfo();
  static const int kHelpInfoFieldNumber = 2;
  inline const ::protobuf::maze::MazeHelpHero& helpinfo(int index) const;
  inline ::protobuf::maze::MazeHelpHero* mutable_helpinfo(int index);
  inline ::protobuf::maze::MazeHelpHero* add_helpinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHelpHero >&
      helpinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHelpHero >*
      mutable_helpinfo();
  
  // repeated .protobuf.common.KVint32List32 bossBuff = 3;
  inline int bossbuff_size() const;
  inline void clear_bossbuff();
  static const int kBossBuffFieldNumber = 3;
  inline const ::protobuf::common::KVint32List32& bossbuff(int index) const;
  inline ::protobuf::common::KVint32List32* mutable_bossbuff(int index);
  inline ::protobuf::common::KVint32List32* add_bossbuff();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >&
      bossbuff() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >*
      mutable_bossbuff();
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeHelpEnemy)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeEnemy > enemyinfo_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHelpHero > helpinfo_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 > bossbuff_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeHelpEnemy* default_instance_;
};
// -------------------------------------------------------------------

class MazeHero : public ::google::protobuf::Message {
 public:
  MazeHero();
  virtual ~MazeHero();
  
  MazeHero(const MazeHero& from);
  
  inline MazeHero& operator=(const MazeHero& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeHero& default_instance();
  
  void Swap(MazeHero* other);
  
  // implements Message ----------------------------------------------
  
  MazeHero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeHero& from);
  void MergeFrom(const MazeHero& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 heroId = 1;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroIdFieldNumber = 1;
  inline ::google::protobuf::int32 heroid() const;
  inline void set_heroid(::google::protobuf::int32 value);
  
  // required int32 lastHp = 2;
  inline bool has_lasthp() const;
  inline void clear_lasthp();
  static const int kLastHpFieldNumber = 2;
  inline ::google::protobuf::int32 lasthp() const;
  inline void set_lasthp(::google::protobuf::int32 value);
  
  // required bool isHelpHero = 3;
  inline bool has_ishelphero() const;
  inline void clear_ishelphero();
  static const int kIsHelpHeroFieldNumber = 3;
  inline bool ishelphero() const;
  inline void set_ishelphero(bool value);
  
  // required int32 energy = 4;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 4;
  inline ::google::protobuf::int32 energy() const;
  inline void set_energy(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeHero)
 private:
  inline void set_has_heroid();
  inline void clear_has_heroid();
  inline void set_has_lasthp();
  inline void clear_has_lasthp();
  inline void set_has_ishelphero();
  inline void clear_has_ishelphero();
  inline void set_has_energy();
  inline void clear_has_energy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 heroid_;
  ::google::protobuf::int32 lasthp_;
  bool ishelphero_;
  ::google::protobuf::int32 energy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeHero* default_instance_;
};
// -------------------------------------------------------------------

class MazeUpdate : public ::google::protobuf::Message {
 public:
  MazeUpdate();
  virtual ~MazeUpdate();
  
  MazeUpdate(const MazeUpdate& from);
  
  inline MazeUpdate& operator=(const MazeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeUpdate& default_instance();
  
  void Swap(MazeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  MazeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeUpdate& from);
  void MergeFrom(const MazeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.maze.MazeHero heroPackeage = 1;
  inline int heropackeage_size() const;
  inline void clear_heropackeage();
  static const int kHeroPackeageFieldNumber = 1;
  inline const ::protobuf::maze::MazeHero& heropackeage(int index) const;
  inline ::protobuf::maze::MazeHero* mutable_heropackeage(int index);
  inline ::protobuf::maze::MazeHero* add_heropackeage();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >&
      heropackeage() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >*
      mutable_heropackeage();
  
  // optional int32 mapNumber = 2;
  inline bool has_mapnumber() const;
  inline void clear_mapnumber();
  static const int kMapNumberFieldNumber = 2;
  inline ::google::protobuf::int32 mapnumber() const;
  inline void set_mapnumber(::google::protobuf::int32 value);
  
  // repeated .protobuf.common.Hero heroHelpPackeage = 3;
  inline int herohelppackeage_size() const;
  inline void clear_herohelppackeage();
  static const int kHeroHelpPackeageFieldNumber = 3;
  inline const ::protobuf::common::Hero& herohelppackeage(int index) const;
  inline ::protobuf::common::Hero* mutable_herohelppackeage(int index);
  inline ::protobuf::common::Hero* add_herohelppackeage();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >&
      herohelppackeage() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >*
      mutable_herohelppackeage();
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeUpdate)
 private:
  inline void set_has_mapnumber();
  inline void clear_has_mapnumber();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero > heropackeage_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero > herohelppackeage_;
  ::google::protobuf::int32 mapnumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class MazeNext : public ::google::protobuf::Message {
 public:
  MazeNext();
  virtual ~MazeNext();
  
  MazeNext(const MazeNext& from);
  
  inline MazeNext& operator=(const MazeNext& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeNext& default_instance();
  
  void Swap(MazeNext* other);
  
  // implements Message ----------------------------------------------
  
  MazeNext* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeNext& from);
  void MergeFrom(const MazeNext& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .protobuf.common.KVint3233 info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::protobuf::common::KVint3233& info() const;
  inline ::protobuf::common::KVint3233* mutable_info();
  inline ::protobuf::common::KVint3233* release_info();
  
  // repeated .protobuf.common.KVint3264 awards = 2;
  inline int awards_size() const;
  inline void clear_awards();
  static const int kAwardsFieldNumber = 2;
  inline const ::protobuf::common::KVint3264& awards(int index) const;
  inline ::protobuf::common::KVint3264* mutable_awards(int index);
  inline ::protobuf::common::KVint3264* add_awards();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
      awards() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
      mutable_awards();
  
  // optional int32 mazeType = 4;
  inline bool has_mazetype() const;
  inline void clear_mazetype();
  static const int kMazeTypeFieldNumber = 4;
  inline ::google::protobuf::int32 mazetype() const;
  inline void set_mazetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeNext)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_mazetype();
  inline void clear_has_mazetype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::protobuf::common::KVint3233* info_;
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 > awards_;
  ::google::protobuf::int32 mazetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeNext* default_instance_;
};
// -------------------------------------------------------------------

class MazeMarket : public ::google::protobuf::Message {
 public:
  MazeMarket();
  virtual ~MazeMarket();
  
  MazeMarket(const MazeMarket& from);
  
  inline MazeMarket& operator=(const MazeMarket& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeMarket& default_instance();
  
  void Swap(MazeMarket* other);
  
  // implements Message ----------------------------------------------
  
  MazeMarket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeMarket& from);
  void MergeFrom(const MazeMarket& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 sit = 1;
  inline bool has_sit() const;
  inline void clear_sit();
  static const int kSitFieldNumber = 1;
  inline ::google::protobuf::int32 sit() const;
  inline void set_sit(::google::protobuf::int32 value);
  
  // repeated .protobuf.maze.MazeShop market = 2;
  inline int market_size() const;
  inline void clear_market();
  static const int kMarketFieldNumber = 2;
  inline const ::protobuf::maze::MazeShop& market(int index) const;
  inline ::protobuf::maze::MazeShop* mutable_market(int index);
  inline ::protobuf::maze::MazeShop* add_market();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeShop >&
      market() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeShop >*
      mutable_market();
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeMarket)
 private:
  inline void set_has_sit();
  inline void clear_has_sit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeShop > market_;
  ::google::protobuf::int32 sit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeMarket* default_instance_;
};
// -------------------------------------------------------------------

class MazeShop : public ::google::protobuf::Message {
 public:
  MazeShop();
  virtual ~MazeShop();
  
  MazeShop(const MazeShop& from);
  
  inline MazeShop& operator=(const MazeShop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeShop& default_instance();
  
  void Swap(MazeShop* other);
  
  // implements Message ----------------------------------------------
  
  MazeShop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeShop& from);
  void MergeFrom(const MazeShop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 marketId = 1;
  inline bool has_marketid() const;
  inline void clear_marketid();
  static const int kMarketIdFieldNumber = 1;
  inline ::google::protobuf::int32 marketid() const;
  inline void set_marketid(::google::protobuf::int32 value);
  
  // optional bool isShop = 2;
  inline bool has_isshop() const;
  inline void clear_isshop();
  static const int kIsShopFieldNumber = 2;
  inline bool isshop() const;
  inline void set_isshop(bool value);
  
  // optional int32 itemId = 3;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 3;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeShop)
 private:
  inline void set_has_marketid();
  inline void clear_has_marketid();
  inline void set_has_isshop();
  inline void clear_has_isshop();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 marketid_;
  bool isshop_;
  ::google::protobuf::int32 itemid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeShop* default_instance_;
};
// -------------------------------------------------------------------

class MazeHelpHero : public ::google::protobuf::Message {
 public:
  MazeHelpHero();
  virtual ~MazeHelpHero();
  
  MazeHelpHero(const MazeHelpHero& from);
  
  inline MazeHelpHero& operator=(const MazeHelpHero& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeHelpHero& default_instance();
  
  void Swap(MazeHelpHero* other);
  
  // implements Message ----------------------------------------------
  
  MazeHelpHero* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeHelpHero& from);
  void MergeFrom(const MazeHelpHero& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 sit = 1;
  inline bool has_sit() const;
  inline void clear_sit();
  static const int kSitFieldNumber = 1;
  inline ::google::protobuf::int32 sit() const;
  inline void set_sit(::google::protobuf::int32 value);
  
  // repeated .protobuf.common.Hero hero = 2;
  inline int hero_size() const;
  inline void clear_hero();
  static const int kHeroFieldNumber = 2;
  inline const ::protobuf::common::Hero& hero(int index) const;
  inline ::protobuf::common::Hero* mutable_hero(int index);
  inline ::protobuf::common::Hero* add_hero();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >&
      hero() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >*
      mutable_hero();
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeHelpHero)
 private:
  inline void set_has_sit();
  inline void clear_has_sit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero > hero_;
  ::google::protobuf::int32 sit_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeHelpHero* default_instance_;
};
// -------------------------------------------------------------------

class MazeKVint : public ::google::protobuf::Message {
 public:
  MazeKVint();
  virtual ~MazeKVint();
  
  MazeKVint(const MazeKVint& from);
  
  inline MazeKVint& operator=(const MazeKVint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MazeKVint& default_instance();
  
  void Swap(MazeKVint* other);
  
  // implements Message ----------------------------------------------
  
  MazeKVint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MazeKVint& from);
  void MergeFrom(const MazeKVint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::int32 key() const;
  inline void set_key(::google::protobuf::int32 value);
  
  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int32 mapId = 4;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 4;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.MazeKVint)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 key_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 mapid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static MazeKVint* default_instance_;
};
// -------------------------------------------------------------------

class TopTimeInfo : public ::google::protobuf::Message {
 public:
  TopTimeInfo();
  virtual ~TopTimeInfo();
  
  TopTimeInfo(const TopTimeInfo& from);
  
  inline TopTimeInfo& operator=(const TopTimeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TopTimeInfo& default_instance();
  
  void Swap(TopTimeInfo* other);
  
  // implements Message ----------------------------------------------
  
  TopTimeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopTimeInfo& from);
  void MergeFrom(const TopTimeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.common.KVint32List32 openMap = 1;
  inline int openmap_size() const;
  inline void clear_openmap();
  static const int kOpenMapFieldNumber = 1;
  inline const ::protobuf::common::KVint32List32& openmap(int index) const;
  inline ::protobuf::common::KVint32List32* mutable_openmap(int index);
  inline ::protobuf::common::KVint32List32* add_openmap();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >&
      openmap() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >*
      mutable_openmap();
  
  // @@protoc_insertion_point(class_scope:protobuf.maze.TopTimeInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 > openmap_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_maze_2eproto();
  friend void protobuf_AssignDesc_maze_2eproto();
  friend void protobuf_ShutdownFile_maze_2eproto();
  
  void InitAsDefaultInstance();
  static TopTimeInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// MazeInfo

// required int32 layer = 1;
inline bool MazeInfo::has_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeInfo::set_has_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeInfo::clear_has_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeInfo::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MazeInfo::layer() const {
  return layer_;
}
inline void MazeInfo::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// required bool isOpen = 2;
inline bool MazeInfo::has_isopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MazeInfo::set_has_isopen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MazeInfo::clear_has_isopen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MazeInfo::clear_isopen() {
  isopen_ = false;
  clear_has_isopen();
}
inline bool MazeInfo::isopen() const {
  return isopen_;
}
inline void MazeInfo::set_isopen(bool value) {
  set_has_isopen();
  isopen_ = value;
}

// optional int64 updateTime = 3;
inline bool MazeInfo::has_updatetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MazeInfo::set_has_updatetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MazeInfo::clear_has_updatetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MazeInfo::clear_updatetime() {
  updatetime_ = GOOGLE_LONGLONG(0);
  clear_has_updatetime();
}
inline ::google::protobuf::int64 MazeInfo::updatetime() const {
  return updatetime_;
}
inline void MazeInfo::set_updatetime(::google::protobuf::int64 value) {
  set_has_updatetime();
  updatetime_ = value;
}

// optional int32 sit = 4;
inline bool MazeInfo::has_sit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MazeInfo::set_has_sit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MazeInfo::clear_has_sit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MazeInfo::clear_sit() {
  sit_ = 0;
  clear_has_sit();
}
inline ::google::protobuf::int32 MazeInfo::sit() const {
  return sit_;
}
inline void MazeInfo::set_sit(::google::protobuf::int32 value) {
  set_has_sit();
  sit_ = value;
}

// optional int32 nextSit = 5;
inline bool MazeInfo::has_nextsit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MazeInfo::set_has_nextsit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MazeInfo::clear_has_nextsit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MazeInfo::clear_nextsit() {
  nextsit_ = 0;
  clear_has_nextsit();
}
inline ::google::protobuf::int32 MazeInfo::nextsit() const {
  return nextsit_;
}
inline void MazeInfo::set_nextsit(::google::protobuf::int32 value) {
  set_has_nextsit();
  nextsit_ = value;
}

// repeated int32 buffPackage = 6;
inline int MazeInfo::buffpackage_size() const {
  return buffpackage_.size();
}
inline void MazeInfo::clear_buffpackage() {
  buffpackage_.Clear();
}
inline ::google::protobuf::int32 MazeInfo::buffpackage(int index) const {
  return buffpackage_.Get(index);
}
inline void MazeInfo::set_buffpackage(int index, ::google::protobuf::int32 value) {
  buffpackage_.Set(index, value);
}
inline void MazeInfo::add_buffpackage(::google::protobuf::int32 value) {
  buffpackage_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MazeInfo::buffpackage() const {
  return buffpackage_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MazeInfo::mutable_buffpackage() {
  return &buffpackage_;
}

// repeated .protobuf.common.Hero heroHelpPackeage = 7;
inline int MazeInfo::herohelppackeage_size() const {
  return herohelppackeage_.size();
}
inline void MazeInfo::clear_herohelppackeage() {
  herohelppackeage_.Clear();
}
inline const ::protobuf::common::Hero& MazeInfo::herohelppackeage(int index) const {
  return herohelppackeage_.Get(index);
}
inline ::protobuf::common::Hero* MazeInfo::mutable_herohelppackeage(int index) {
  return herohelppackeage_.Mutable(index);
}
inline ::protobuf::common::Hero* MazeInfo::add_herohelppackeage() {
  return herohelppackeage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >&
MazeInfo::herohelppackeage() const {
  return herohelppackeage_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >*
MazeInfo::mutable_herohelppackeage() {
  return &herohelppackeage_;
}

// repeated .protobuf.maze.MazeHero heroPackeage = 8;
inline int MazeInfo::heropackeage_size() const {
  return heropackeage_.size();
}
inline void MazeInfo::clear_heropackeage() {
  heropackeage_.Clear();
}
inline const ::protobuf::maze::MazeHero& MazeInfo::heropackeage(int index) const {
  return heropackeage_.Get(index);
}
inline ::protobuf::maze::MazeHero* MazeInfo::mutable_heropackeage(int index) {
  return heropackeage_.Mutable(index);
}
inline ::protobuf::maze::MazeHero* MazeInfo::add_heropackeage() {
  return heropackeage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >&
MazeInfo::heropackeage() const {
  return heropackeage_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >*
MazeInfo::mutable_heropackeage() {
  return &heropackeage_;
}

// repeated int32 queue = 9;
inline int MazeInfo::queue_size() const {
  return queue_.size();
}
inline void MazeInfo::clear_queue() {
  queue_.Clear();
}
inline ::google::protobuf::int32 MazeInfo::queue(int index) const {
  return queue_.Get(index);
}
inline void MazeInfo::set_queue(int index, ::google::protobuf::int32 value) {
  queue_.Set(index, value);
}
inline void MazeInfo::add_queue(::google::protobuf::int32 value) {
  queue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MazeInfo::queue() const {
  return queue_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MazeInfo::mutable_queue() {
  return &queue_;
}

// repeated int32 pathWay = 10;
inline int MazeInfo::pathway_size() const {
  return pathway_.size();
}
inline void MazeInfo::clear_pathway() {
  pathway_.Clear();
}
inline ::google::protobuf::int32 MazeInfo::pathway(int index) const {
  return pathway_.Get(index);
}
inline void MazeInfo::set_pathway(int index, ::google::protobuf::int32 value) {
  pathway_.Set(index, value);
}
inline void MazeInfo::add_pathway(::google::protobuf::int32 value) {
  pathway_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MazeInfo::pathway() const {
  return pathway_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MazeInfo::mutable_pathway() {
  return &pathway_;
}

// repeated .protobuf.maze.MazeMarket mazeMarket = 11;
inline int MazeInfo::mazemarket_size() const {
  return mazemarket_.size();
}
inline void MazeInfo::clear_mazemarket() {
  mazemarket_.Clear();
}
inline const ::protobuf::maze::MazeMarket& MazeInfo::mazemarket(int index) const {
  return mazemarket_.Get(index);
}
inline ::protobuf::maze::MazeMarket* MazeInfo::mutable_mazemarket(int index) {
  return mazemarket_.Mutable(index);
}
inline ::protobuf::maze::MazeMarket* MazeInfo::add_mazemarket() {
  return mazemarket_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeMarket >&
MazeInfo::mazemarket() const {
  return mazemarket_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeMarket >*
MazeInfo::mutable_mazemarket() {
  return &mazemarket_;
}

// optional int32 mapNumber = 12;
inline bool MazeInfo::has_mapnumber() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MazeInfo::set_has_mapnumber() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MazeInfo::clear_has_mapnumber() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MazeInfo::clear_mapnumber() {
  mapnumber_ = 0;
  clear_has_mapnumber();
}
inline ::google::protobuf::int32 MazeInfo::mapnumber() const {
  return mapnumber_;
}
inline void MazeInfo::set_mapnumber(::google::protobuf::int32 value) {
  set_has_mapnumber();
  mapnumber_ = value;
}

// repeated int32 haveReceiveSit = 13;
inline int MazeInfo::havereceivesit_size() const {
  return havereceivesit_.size();
}
inline void MazeInfo::clear_havereceivesit() {
  havereceivesit_.Clear();
}
inline ::google::protobuf::int32 MazeInfo::havereceivesit(int index) const {
  return havereceivesit_.Get(index);
}
inline void MazeInfo::set_havereceivesit(int index, ::google::protobuf::int32 value) {
  havereceivesit_.Set(index, value);
}
inline void MazeInfo::add_havereceivesit(::google::protobuf::int32 value) {
  havereceivesit_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MazeInfo::havereceivesit() const {
  return havereceivesit_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MazeInfo::mutable_havereceivesit() {
  return &havereceivesit_;
}

// repeated .protobuf.common.KVint3232 sitType = 14;
inline int MazeInfo::sittype_size() const {
  return sittype_.size();
}
inline void MazeInfo::clear_sittype() {
  sittype_.Clear();
}
inline const ::protobuf::common::KVint3232& MazeInfo::sittype(int index) const {
  return sittype_.Get(index);
}
inline ::protobuf::common::KVint3232* MazeInfo::mutable_sittype(int index) {
  return sittype_.Mutable(index);
}
inline ::protobuf::common::KVint3232* MazeInfo::add_sittype() {
  return sittype_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
MazeInfo::sittype() const {
  return sittype_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
MazeInfo::mutable_sittype() {
  return &sittype_;
}

// repeated .protobuf.common.KVint3232 fogNumber = 15;
inline int MazeInfo::fognumber_size() const {
  return fognumber_.size();
}
inline void MazeInfo::clear_fognumber() {
  fognumber_.Clear();
}
inline const ::protobuf::common::KVint3232& MazeInfo::fognumber(int index) const {
  return fognumber_.Get(index);
}
inline ::protobuf::common::KVint3232* MazeInfo::mutable_fognumber(int index) {
  return fognumber_.Mutable(index);
}
inline ::protobuf::common::KVint3232* MazeInfo::add_fognumber() {
  return fognumber_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >&
MazeInfo::fognumber() const {
  return fognumber_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3232 >*
MazeInfo::mutable_fognumber() {
  return &fognumber_;
}

// -------------------------------------------------------------------

// MazeEnemy

// optional int32 enemySit = 1;
inline bool MazeEnemy::has_enemysit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeEnemy::set_has_enemysit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeEnemy::clear_has_enemysit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeEnemy::clear_enemysit() {
  enemysit_ = 0;
  clear_has_enemysit();
}
inline ::google::protobuf::int32 MazeEnemy::enemysit() const {
  return enemysit_;
}
inline void MazeEnemy::set_enemysit(::google::protobuf::int32 value) {
  set_has_enemysit();
  enemysit_ = value;
}

// optional .protobuf.common.LineupDetail enemyLineup = 2;
inline bool MazeEnemy::has_enemylineup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MazeEnemy::set_has_enemylineup() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MazeEnemy::clear_has_enemylineup() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MazeEnemy::clear_enemylineup() {
  if (enemylineup_ != NULL) enemylineup_->::protobuf::common::LineupDetail::Clear();
  clear_has_enemylineup();
}
inline const ::protobuf::common::LineupDetail& MazeEnemy::enemylineup() const {
  return enemylineup_ != NULL ? *enemylineup_ : *default_instance_->enemylineup_;
}
inline ::protobuf::common::LineupDetail* MazeEnemy::mutable_enemylineup() {
  set_has_enemylineup();
  if (enemylineup_ == NULL) enemylineup_ = new ::protobuf::common::LineupDetail;
  return enemylineup_;
}
inline ::protobuf::common::LineupDetail* MazeEnemy::release_enemylineup() {
  clear_has_enemylineup();
  ::protobuf::common::LineupDetail* temp = enemylineup_;
  enemylineup_ = NULL;
  return temp;
}

// repeated .protobuf.common.KVint3264 awards = 3;
inline int MazeEnemy::awards_size() const {
  return awards_.size();
}
inline void MazeEnemy::clear_awards() {
  awards_.Clear();
}
inline const ::protobuf::common::KVint3264& MazeEnemy::awards(int index) const {
  return awards_.Get(index);
}
inline ::protobuf::common::KVint3264* MazeEnemy::mutable_awards(int index) {
  return awards_.Mutable(index);
}
inline ::protobuf::common::KVint3264* MazeEnemy::add_awards() {
  return awards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
MazeEnemy::awards() const {
  return awards_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
MazeEnemy::mutable_awards() {
  return &awards_;
}

// optional double chageValue = 4;
inline bool MazeEnemy::has_chagevalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MazeEnemy::set_has_chagevalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MazeEnemy::clear_has_chagevalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MazeEnemy::clear_chagevalue() {
  chagevalue_ = 0;
  clear_has_chagevalue();
}
inline double MazeEnemy::chagevalue() const {
  return chagevalue_;
}
inline void MazeEnemy::set_chagevalue(double value) {
  set_has_chagevalue();
  chagevalue_ = value;
}

// -------------------------------------------------------------------

// MazeHelpEnemy

// repeated .protobuf.maze.MazeEnemy enemyInfo = 1;
inline int MazeHelpEnemy::enemyinfo_size() const {
  return enemyinfo_.size();
}
inline void MazeHelpEnemy::clear_enemyinfo() {
  enemyinfo_.Clear();
}
inline const ::protobuf::maze::MazeEnemy& MazeHelpEnemy::enemyinfo(int index) const {
  return enemyinfo_.Get(index);
}
inline ::protobuf::maze::MazeEnemy* MazeHelpEnemy::mutable_enemyinfo(int index) {
  return enemyinfo_.Mutable(index);
}
inline ::protobuf::maze::MazeEnemy* MazeHelpEnemy::add_enemyinfo() {
  return enemyinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeEnemy >&
MazeHelpEnemy::enemyinfo() const {
  return enemyinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeEnemy >*
MazeHelpEnemy::mutable_enemyinfo() {
  return &enemyinfo_;
}

// repeated .protobuf.maze.MazeHelpHero helpInfo = 2;
inline int MazeHelpEnemy::helpinfo_size() const {
  return helpinfo_.size();
}
inline void MazeHelpEnemy::clear_helpinfo() {
  helpinfo_.Clear();
}
inline const ::protobuf::maze::MazeHelpHero& MazeHelpEnemy::helpinfo(int index) const {
  return helpinfo_.Get(index);
}
inline ::protobuf::maze::MazeHelpHero* MazeHelpEnemy::mutable_helpinfo(int index) {
  return helpinfo_.Mutable(index);
}
inline ::protobuf::maze::MazeHelpHero* MazeHelpEnemy::add_helpinfo() {
  return helpinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHelpHero >&
MazeHelpEnemy::helpinfo() const {
  return helpinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHelpHero >*
MazeHelpEnemy::mutable_helpinfo() {
  return &helpinfo_;
}

// repeated .protobuf.common.KVint32List32 bossBuff = 3;
inline int MazeHelpEnemy::bossbuff_size() const {
  return bossbuff_.size();
}
inline void MazeHelpEnemy::clear_bossbuff() {
  bossbuff_.Clear();
}
inline const ::protobuf::common::KVint32List32& MazeHelpEnemy::bossbuff(int index) const {
  return bossbuff_.Get(index);
}
inline ::protobuf::common::KVint32List32* MazeHelpEnemy::mutable_bossbuff(int index) {
  return bossbuff_.Mutable(index);
}
inline ::protobuf::common::KVint32List32* MazeHelpEnemy::add_bossbuff() {
  return bossbuff_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >&
MazeHelpEnemy::bossbuff() const {
  return bossbuff_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >*
MazeHelpEnemy::mutable_bossbuff() {
  return &bossbuff_;
}

// -------------------------------------------------------------------

// MazeHero

// required int32 heroId = 1;
inline bool MazeHero::has_heroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeHero::set_has_heroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeHero::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeHero::clear_heroid() {
  heroid_ = 0;
  clear_has_heroid();
}
inline ::google::protobuf::int32 MazeHero::heroid() const {
  return heroid_;
}
inline void MazeHero::set_heroid(::google::protobuf::int32 value) {
  set_has_heroid();
  heroid_ = value;
}

// required int32 lastHp = 2;
inline bool MazeHero::has_lasthp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MazeHero::set_has_lasthp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MazeHero::clear_has_lasthp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MazeHero::clear_lasthp() {
  lasthp_ = 0;
  clear_has_lasthp();
}
inline ::google::protobuf::int32 MazeHero::lasthp() const {
  return lasthp_;
}
inline void MazeHero::set_lasthp(::google::protobuf::int32 value) {
  set_has_lasthp();
  lasthp_ = value;
}

// required bool isHelpHero = 3;
inline bool MazeHero::has_ishelphero() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MazeHero::set_has_ishelphero() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MazeHero::clear_has_ishelphero() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MazeHero::clear_ishelphero() {
  ishelphero_ = false;
  clear_has_ishelphero();
}
inline bool MazeHero::ishelphero() const {
  return ishelphero_;
}
inline void MazeHero::set_ishelphero(bool value) {
  set_has_ishelphero();
  ishelphero_ = value;
}

// required int32 energy = 4;
inline bool MazeHero::has_energy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MazeHero::set_has_energy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MazeHero::clear_has_energy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MazeHero::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 MazeHero::energy() const {
  return energy_;
}
inline void MazeHero::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
}

// -------------------------------------------------------------------

// MazeUpdate

// repeated .protobuf.maze.MazeHero heroPackeage = 1;
inline int MazeUpdate::heropackeage_size() const {
  return heropackeage_.size();
}
inline void MazeUpdate::clear_heropackeage() {
  heropackeage_.Clear();
}
inline const ::protobuf::maze::MazeHero& MazeUpdate::heropackeage(int index) const {
  return heropackeage_.Get(index);
}
inline ::protobuf::maze::MazeHero* MazeUpdate::mutable_heropackeage(int index) {
  return heropackeage_.Mutable(index);
}
inline ::protobuf::maze::MazeHero* MazeUpdate::add_heropackeage() {
  return heropackeage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >&
MazeUpdate::heropackeage() const {
  return heropackeage_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeHero >*
MazeUpdate::mutable_heropackeage() {
  return &heropackeage_;
}

// optional int32 mapNumber = 2;
inline bool MazeUpdate::has_mapnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MazeUpdate::set_has_mapnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MazeUpdate::clear_has_mapnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MazeUpdate::clear_mapnumber() {
  mapnumber_ = 0;
  clear_has_mapnumber();
}
inline ::google::protobuf::int32 MazeUpdate::mapnumber() const {
  return mapnumber_;
}
inline void MazeUpdate::set_mapnumber(::google::protobuf::int32 value) {
  set_has_mapnumber();
  mapnumber_ = value;
}

// repeated .protobuf.common.Hero heroHelpPackeage = 3;
inline int MazeUpdate::herohelppackeage_size() const {
  return herohelppackeage_.size();
}
inline void MazeUpdate::clear_herohelppackeage() {
  herohelppackeage_.Clear();
}
inline const ::protobuf::common::Hero& MazeUpdate::herohelppackeage(int index) const {
  return herohelppackeage_.Get(index);
}
inline ::protobuf::common::Hero* MazeUpdate::mutable_herohelppackeage(int index) {
  return herohelppackeage_.Mutable(index);
}
inline ::protobuf::common::Hero* MazeUpdate::add_herohelppackeage() {
  return herohelppackeage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >&
MazeUpdate::herohelppackeage() const {
  return herohelppackeage_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >*
MazeUpdate::mutable_herohelppackeage() {
  return &herohelppackeage_;
}

// -------------------------------------------------------------------

// MazeNext

// optional .protobuf.common.KVint3233 info = 1;
inline bool MazeNext::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeNext::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeNext::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeNext::clear_info() {
  if (info_ != NULL) info_->::protobuf::common::KVint3233::Clear();
  clear_has_info();
}
inline const ::protobuf::common::KVint3233& MazeNext::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::protobuf::common::KVint3233* MazeNext::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::protobuf::common::KVint3233;
  return info_;
}
inline ::protobuf::common::KVint3233* MazeNext::release_info() {
  clear_has_info();
  ::protobuf::common::KVint3233* temp = info_;
  info_ = NULL;
  return temp;
}

// repeated .protobuf.common.KVint3264 awards = 2;
inline int MazeNext::awards_size() const {
  return awards_.size();
}
inline void MazeNext::clear_awards() {
  awards_.Clear();
}
inline const ::protobuf::common::KVint3264& MazeNext::awards(int index) const {
  return awards_.Get(index);
}
inline ::protobuf::common::KVint3264* MazeNext::mutable_awards(int index) {
  return awards_.Mutable(index);
}
inline ::protobuf::common::KVint3264* MazeNext::add_awards() {
  return awards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >&
MazeNext::awards() const {
  return awards_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint3264 >*
MazeNext::mutable_awards() {
  return &awards_;
}

// optional int32 mazeType = 4;
inline bool MazeNext::has_mazetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MazeNext::set_has_mazetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MazeNext::clear_has_mazetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MazeNext::clear_mazetype() {
  mazetype_ = 0;
  clear_has_mazetype();
}
inline ::google::protobuf::int32 MazeNext::mazetype() const {
  return mazetype_;
}
inline void MazeNext::set_mazetype(::google::protobuf::int32 value) {
  set_has_mazetype();
  mazetype_ = value;
}

// -------------------------------------------------------------------

// MazeMarket

// optional int32 sit = 1;
inline bool MazeMarket::has_sit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeMarket::set_has_sit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeMarket::clear_has_sit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeMarket::clear_sit() {
  sit_ = 0;
  clear_has_sit();
}
inline ::google::protobuf::int32 MazeMarket::sit() const {
  return sit_;
}
inline void MazeMarket::set_sit(::google::protobuf::int32 value) {
  set_has_sit();
  sit_ = value;
}

// repeated .protobuf.maze.MazeShop market = 2;
inline int MazeMarket::market_size() const {
  return market_.size();
}
inline void MazeMarket::clear_market() {
  market_.Clear();
}
inline const ::protobuf::maze::MazeShop& MazeMarket::market(int index) const {
  return market_.Get(index);
}
inline ::protobuf::maze::MazeShop* MazeMarket::mutable_market(int index) {
  return market_.Mutable(index);
}
inline ::protobuf::maze::MazeShop* MazeMarket::add_market() {
  return market_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeShop >&
MazeMarket::market() const {
  return market_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::maze::MazeShop >*
MazeMarket::mutable_market() {
  return &market_;
}

// -------------------------------------------------------------------

// MazeShop

// optional int32 marketId = 1;
inline bool MazeShop::has_marketid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeShop::set_has_marketid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeShop::clear_has_marketid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeShop::clear_marketid() {
  marketid_ = 0;
  clear_has_marketid();
}
inline ::google::protobuf::int32 MazeShop::marketid() const {
  return marketid_;
}
inline void MazeShop::set_marketid(::google::protobuf::int32 value) {
  set_has_marketid();
  marketid_ = value;
}

// optional bool isShop = 2;
inline bool MazeShop::has_isshop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MazeShop::set_has_isshop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MazeShop::clear_has_isshop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MazeShop::clear_isshop() {
  isshop_ = false;
  clear_has_isshop();
}
inline bool MazeShop::isshop() const {
  return isshop_;
}
inline void MazeShop::set_isshop(bool value) {
  set_has_isshop();
  isshop_ = value;
}

// optional int32 itemId = 3;
inline bool MazeShop::has_itemid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MazeShop::set_has_itemid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MazeShop::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MazeShop::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 MazeShop::itemid() const {
  return itemid_;
}
inline void MazeShop::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// -------------------------------------------------------------------

// MazeHelpHero

// optional int32 sit = 1;
inline bool MazeHelpHero::has_sit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeHelpHero::set_has_sit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeHelpHero::clear_has_sit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeHelpHero::clear_sit() {
  sit_ = 0;
  clear_has_sit();
}
inline ::google::protobuf::int32 MazeHelpHero::sit() const {
  return sit_;
}
inline void MazeHelpHero::set_sit(::google::protobuf::int32 value) {
  set_has_sit();
  sit_ = value;
}

// repeated .protobuf.common.Hero hero = 2;
inline int MazeHelpHero::hero_size() const {
  return hero_.size();
}
inline void MazeHelpHero::clear_hero() {
  hero_.Clear();
}
inline const ::protobuf::common::Hero& MazeHelpHero::hero(int index) const {
  return hero_.Get(index);
}
inline ::protobuf::common::Hero* MazeHelpHero::mutable_hero(int index) {
  return hero_.Mutable(index);
}
inline ::protobuf::common::Hero* MazeHelpHero::add_hero() {
  return hero_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >&
MazeHelpHero::hero() const {
  return hero_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::Hero >*
MazeHelpHero::mutable_hero() {
  return &hero_;
}

// -------------------------------------------------------------------

// MazeKVint

// required int32 key = 1;
inline bool MazeKVint::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MazeKVint::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MazeKVint::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MazeKVint::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 MazeKVint::key() const {
  return key_;
}
inline void MazeKVint::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
}

// required int32 value = 2;
inline bool MazeKVint::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MazeKVint::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MazeKVint::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MazeKVint::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 MazeKVint::value() const {
  return value_;
}
inline void MazeKVint::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// required int32 type = 3;
inline bool MazeKVint::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MazeKVint::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MazeKVint::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MazeKVint::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MazeKVint::type() const {
  return type_;
}
inline void MazeKVint::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 mapId = 4;
inline bool MazeKVint::has_mapid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MazeKVint::set_has_mapid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MazeKVint::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MazeKVint::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 MazeKVint::mapid() const {
  return mapid_;
}
inline void MazeKVint::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// -------------------------------------------------------------------

// TopTimeInfo

// repeated .protobuf.common.KVint32List32 openMap = 1;
inline int TopTimeInfo::openmap_size() const {
  return openmap_.size();
}
inline void TopTimeInfo::clear_openmap() {
  openmap_.Clear();
}
inline const ::protobuf::common::KVint32List32& TopTimeInfo::openmap(int index) const {
  return openmap_.Get(index);
}
inline ::protobuf::common::KVint32List32* TopTimeInfo::mutable_openmap(int index) {
  return openmap_.Mutable(index);
}
inline ::protobuf::common::KVint32List32* TopTimeInfo::add_openmap() {
  return openmap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >&
TopTimeInfo::openmap() const {
  return openmap_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::common::KVint32List32 >*
TopTimeInfo::mutable_openmap() {
  return &openmap_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace maze
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_maze_2eproto__INCLUDED
