// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: arena.proto

#ifndef PROTOBUF_arena_2eproto__INCLUDED
#define PROTOBUF_arena_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf {
namespace arena {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_arena_2eproto();
void protobuf_AssignDesc_arena_2eproto();
void protobuf_ShutdownFile_arena_2eproto();

class iconinfo;
class playerInfoList;
class BattleHistory;
class BattleHistoryList;
class BattleLineupDetail;
class ArenaInfo;

// ===================================================================

class iconinfo : public ::google::protobuf::Message {
 public:
  iconinfo();
  virtual ~iconinfo();
  
  iconinfo(const iconinfo& from);
  
  inline iconinfo& operator=(const iconinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const iconinfo& default_instance();
  
  void Swap(iconinfo* other);
  
  // implements Message ----------------------------------------------
  
  iconinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const iconinfo& from);
  void MergeFrom(const iconinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string head = 3;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 3;
  inline const ::std::string& head() const;
  inline void set_head(const ::std::string& value);
  inline void set_head(const char* value);
  inline void set_head(const char* value, size_t size);
  inline ::std::string* mutable_head();
  inline ::std::string* release_head();
  
  // optional string playerid = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 4;
  inline const ::std::string& playerid() const;
  inline void set_playerid(const ::std::string& value);
  inline void set_playerid(const char* value);
  inline void set_playerid(const char* value, size_t size);
  inline ::std::string* mutable_playerid();
  inline ::std::string* release_playerid();
  
  // optional int32 rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // optional int64 rankPoints = 6;
  inline bool has_rankpoints() const;
  inline void clear_rankpoints();
  static const int kRankPointsFieldNumber = 6;
  inline ::google::protobuf::int64 rankpoints() const;
  inline void set_rankpoints(::google::protobuf::int64 value);
  
  // optional int32 power = 7;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 7;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);
  
  // optional int32 headFrame = 8;
  inline bool has_headframe() const;
  inline void clear_headframe();
  static const int kHeadFrameFieldNumber = 8;
  inline ::google::protobuf::int32 headframe() const;
  inline void set_headframe(::google::protobuf::int32 value);
  
  // optional .protobuf.common.LineupDetail attacker = 9;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 9;
  inline const ::protobuf::common::LineupDetail& attacker() const;
  inline ::protobuf::common::LineupDetail* mutable_attacker();
  inline ::protobuf::common::LineupDetail* release_attacker();
  
  // @@protoc_insertion_point(class_scope:protobuf.arena.iconinfo)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_rankpoints();
  inline void clear_has_rankpoints();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_headframe();
  inline void clear_has_headframe();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* head_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 rank_;
  ::std::string* playerid_;
  ::google::protobuf::int64 rankpoints_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 headframe_;
  ::protobuf::common::LineupDetail* attacker_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_arena_2eproto();
  friend void protobuf_AssignDesc_arena_2eproto();
  friend void protobuf_ShutdownFile_arena_2eproto();
  
  void InitAsDefaultInstance();
  static iconinfo* default_instance_;
};
// -------------------------------------------------------------------

class playerInfoList : public ::google::protobuf::Message {
 public:
  playerInfoList();
  virtual ~playerInfoList();
  
  playerInfoList(const playerInfoList& from);
  
  inline playerInfoList& operator=(const playerInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const playerInfoList& default_instance();
  
  void Swap(playerInfoList* other);
  
  // implements Message ----------------------------------------------
  
  playerInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const playerInfoList& from);
  void MergeFrom(const playerInfoList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.arena.iconinfo showinfo = 1;
  inline int showinfo_size() const;
  inline void clear_showinfo();
  static const int kShowinfoFieldNumber = 1;
  inline const ::protobuf::arena::iconinfo& showinfo(int index) const;
  inline ::protobuf::arena::iconinfo* mutable_showinfo(int index);
  inline ::protobuf::arena::iconinfo* add_showinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::arena::iconinfo >&
      showinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::arena::iconinfo >*
      mutable_showinfo();
  
  // @@protoc_insertion_point(class_scope:protobuf.arena.playerInfoList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::arena::iconinfo > showinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_arena_2eproto();
  friend void protobuf_AssignDesc_arena_2eproto();
  friend void protobuf_ShutdownFile_arena_2eproto();
  
  void InitAsDefaultInstance();
  static playerInfoList* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistory : public ::google::protobuf::Message {
 public:
  BattleHistory();
  virtual ~BattleHistory();
  
  BattleHistory(const BattleHistory& from);
  
  inline BattleHistory& operator=(const BattleHistory& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleHistory& default_instance();
  
  void Swap(BattleHistory* other);
  
  // implements Message ----------------------------------------------
  
  BattleHistory* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleHistory& from);
  void MergeFrom(const BattleHistory& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required string attackName = 2;
  inline bool has_attackname() const;
  inline void clear_attackname();
  static const int kAttackNameFieldNumber = 2;
  inline const ::std::string& attackname() const;
  inline void set_attackname(const ::std::string& value);
  inline void set_attackname(const char* value);
  inline void set_attackname(const char* value, size_t size);
  inline ::std::string* mutable_attackname();
  inline ::std::string* release_attackname();
  
  // required int32 attackLvl = 3;
  inline bool has_attacklvl() const;
  inline void clear_attacklvl();
  static const int kAttackLvlFieldNumber = 3;
  inline ::google::protobuf::int32 attacklvl() const;
  inline void set_attacklvl(::google::protobuf::int32 value);
  
  // required string attackHead = 4;
  inline bool has_attackhead() const;
  inline void clear_attackhead();
  static const int kAttackHeadFieldNumber = 4;
  inline const ::std::string& attackhead() const;
  inline void set_attackhead(const ::std::string& value);
  inline void set_attackhead(const char* value);
  inline void set_attackhead(const char* value, size_t size);
  inline ::std::string* mutable_attackhead();
  inline ::std::string* release_attackhead();
  
  // required string attackId = 5;
  inline bool has_attackid() const;
  inline void clear_attackid();
  static const int kAttackIdFieldNumber = 5;
  inline const ::std::string& attackid() const;
  inline void set_attackid(const ::std::string& value);
  inline void set_attackid(const char* value);
  inline void set_attackid(const char* value, size_t size);
  inline ::std::string* mutable_attackid();
  inline ::std::string* release_attackid();
  
  // optional int32 atHeadFrame = 6;
  inline bool has_atheadframe() const;
  inline void clear_atheadframe();
  static const int kAtHeadFrameFieldNumber = 6;
  inline ::google::protobuf::int32 atheadframe() const;
  inline void set_atheadframe(::google::protobuf::int32 value);
  
  // required string defenseId = 7;
  inline bool has_defenseid() const;
  inline void clear_defenseid();
  static const int kDefenseIdFieldNumber = 7;
  inline const ::std::string& defenseid() const;
  inline void set_defenseid(const ::std::string& value);
  inline void set_defenseid(const char* value);
  inline void set_defenseid(const char* value, size_t size);
  inline ::std::string* mutable_defenseid();
  inline ::std::string* release_defenseid();
  
  // required string defenseName = 8;
  inline bool has_defensename() const;
  inline void clear_defensename();
  static const int kDefenseNameFieldNumber = 8;
  inline const ::std::string& defensename() const;
  inline void set_defensename(const ::std::string& value);
  inline void set_defensename(const char* value);
  inline void set_defensename(const char* value, size_t size);
  inline ::std::string* mutable_defensename();
  inline ::std::string* release_defensename();
  
  // required int32 defenseLvl = 9;
  inline bool has_defenselvl() const;
  inline void clear_defenselvl();
  static const int kDefenseLvlFieldNumber = 9;
  inline ::google::protobuf::int32 defenselvl() const;
  inline void set_defenselvl(::google::protobuf::int32 value);
  
  // required string defenseHead = 10;
  inline bool has_defensehead() const;
  inline void clear_defensehead();
  static const int kDefenseHeadFieldNumber = 10;
  inline const ::std::string& defensehead() const;
  inline void set_defensehead(const ::std::string& value);
  inline void set_defensehead(const char* value);
  inline void set_defensehead(const char* value, size_t size);
  inline ::std::string* mutable_defensehead();
  inline ::std::string* release_defensehead();
  
  // optional int32 deHeadFrame = 11;
  inline bool has_deheadframe() const;
  inline void clear_deheadframe();
  static const int kDeHeadFrameFieldNumber = 11;
  inline ::google::protobuf::int32 deheadframe() const;
  inline void set_deheadframe(::google::protobuf::int32 value);
  
  // required bool victory = 14;
  inline bool has_victory() const;
  inline void clear_victory();
  static const int kVictoryFieldNumber = 14;
  inline bool victory() const;
  inline void set_victory(bool value);
  
  // optional int32 attackPoint = 15;
  inline bool has_attackpoint() const;
  inline void clear_attackpoint();
  static const int kAttackPointFieldNumber = 15;
  inline ::google::protobuf::int32 attackpoint() const;
  inline void set_attackpoint(::google::protobuf::int32 value);
  
  // optional int32 defensePoint = 16;
  inline bool has_defensepoint() const;
  inline void clear_defensepoint();
  static const int kDefensePointFieldNumber = 16;
  inline ::google::protobuf::int32 defensepoint() const;
  inline void set_defensepoint(::google::protobuf::int32 value);
  
  // required int64 time = 17;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 17;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.arena.BattleHistory)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_attackname();
  inline void clear_has_attackname();
  inline void set_has_attacklvl();
  inline void clear_has_attacklvl();
  inline void set_has_attackhead();
  inline void clear_has_attackhead();
  inline void set_has_attackid();
  inline void clear_has_attackid();
  inline void set_has_atheadframe();
  inline void clear_has_atheadframe();
  inline void set_has_defenseid();
  inline void clear_has_defenseid();
  inline void set_has_defensename();
  inline void clear_has_defensename();
  inline void set_has_defenselvl();
  inline void clear_has_defenselvl();
  inline void set_has_defensehead();
  inline void clear_has_defensehead();
  inline void set_has_deheadframe();
  inline void clear_has_deheadframe();
  inline void set_has_victory();
  inline void clear_has_victory();
  inline void set_has_attackpoint();
  inline void clear_has_attackpoint();
  inline void set_has_defensepoint();
  inline void clear_has_defensepoint();
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* id_;
  ::std::string* attackname_;
  ::std::string* attackhead_;
  ::google::protobuf::int32 attacklvl_;
  ::google::protobuf::int32 atheadframe_;
  ::std::string* attackid_;
  ::std::string* defenseid_;
  ::std::string* defensename_;
  ::std::string* defensehead_;
  ::google::protobuf::int32 defenselvl_;
  ::google::protobuf::int32 deheadframe_;
  bool victory_;
  ::google::protobuf::int32 attackpoint_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 defensepoint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_arena_2eproto();
  friend void protobuf_AssignDesc_arena_2eproto();
  friend void protobuf_ShutdownFile_arena_2eproto();
  
  void InitAsDefaultInstance();
  static BattleHistory* default_instance_;
};
// -------------------------------------------------------------------

class BattleHistoryList : public ::google::protobuf::Message {
 public:
  BattleHistoryList();
  virtual ~BattleHistoryList();
  
  BattleHistoryList(const BattleHistoryList& from);
  
  inline BattleHistoryList& operator=(const BattleHistoryList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleHistoryList& default_instance();
  
  void Swap(BattleHistoryList* other);
  
  // implements Message ----------------------------------------------
  
  BattleHistoryList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleHistoryList& from);
  void MergeFrom(const BattleHistoryList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .protobuf.arena.BattleHistory battles = 1;
  inline int battles_size() const;
  inline void clear_battles();
  static const int kBattlesFieldNumber = 1;
  inline const ::protobuf::arena::BattleHistory& battles(int index) const;
  inline ::protobuf::arena::BattleHistory* mutable_battles(int index);
  inline ::protobuf::arena::BattleHistory* add_battles();
  inline const ::google::protobuf::RepeatedPtrField< ::protobuf::arena::BattleHistory >&
      battles() const;
  inline ::google::protobuf::RepeatedPtrField< ::protobuf::arena::BattleHistory >*
      mutable_battles();
  
  // @@protoc_insertion_point(class_scope:protobuf.arena.BattleHistoryList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::protobuf::arena::BattleHistory > battles_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_arena_2eproto();
  friend void protobuf_AssignDesc_arena_2eproto();
  friend void protobuf_ShutdownFile_arena_2eproto();
  
  void InitAsDefaultInstance();
  static BattleHistoryList* default_instance_;
};
// -------------------------------------------------------------------

class BattleLineupDetail : public ::google::protobuf::Message {
 public:
  BattleLineupDetail();
  virtual ~BattleLineupDetail();
  
  BattleLineupDetail(const BattleLineupDetail& from);
  
  inline BattleLineupDetail& operator=(const BattleLineupDetail& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BattleLineupDetail& default_instance();
  
  void Swap(BattleLineupDetail* other);
  
  // implements Message ----------------------------------------------
  
  BattleLineupDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BattleLineupDetail& from);
  void MergeFrom(const BattleLineupDetail& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 seed = 1;
  inline bool has_seed() const;
  inline void clear_seed();
  static const int kSeedFieldNumber = 1;
  inline ::google::protobuf::int64 seed() const;
  inline void set_seed(::google::protobuf::int64 value);
  
  // required .protobuf.common.LineupDetail attacker = 2;
  inline bool has_attacker() const;
  inline void clear_attacker();
  static const int kAttackerFieldNumber = 2;
  inline const ::protobuf::common::LineupDetail& attacker() const;
  inline ::protobuf::common::LineupDetail* mutable_attacker();
  inline ::protobuf::common::LineupDetail* release_attacker();
  
  // required .protobuf.common.LineupDetail defineer = 3;
  inline bool has_defineer() const;
  inline void clear_defineer();
  static const int kDefineerFieldNumber = 3;
  inline const ::protobuf::common::LineupDetail& defineer() const;
  inline ::protobuf::common::LineupDetail* mutable_defineer();
  inline ::protobuf::common::LineupDetail* release_defineer();
  
  // @@protoc_insertion_point(class_scope:protobuf.arena.BattleLineupDetail)
 private:
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_attacker();
  inline void clear_has_attacker();
  inline void set_has_defineer();
  inline void clear_has_defineer();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 seed_;
  ::protobuf::common::LineupDetail* attacker_;
  ::protobuf::common::LineupDetail* defineer_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_arena_2eproto();
  friend void protobuf_AssignDesc_arena_2eproto();
  friend void protobuf_ShutdownFile_arena_2eproto();
  
  void InitAsDefaultInstance();
  static BattleLineupDetail* default_instance_;
};
// -------------------------------------------------------------------

class ArenaInfo : public ::google::protobuf::Message {
 public:
  ArenaInfo();
  virtual ~ArenaInfo();
  
  ArenaInfo(const ArenaInfo& from);
  
  inline ArenaInfo& operator=(const ArenaInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArenaInfo& default_instance();
  
  void Swap(ArenaInfo* other);
  
  // implements Message ----------------------------------------------
  
  ArenaInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArenaInfo& from);
  void MergeFrom(const ArenaInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 battletype = 1;
  inline bool has_battletype() const;
  inline void clear_battletype();
  static const int kBattletypeFieldNumber = 1;
  inline ::google::protobuf::int32 battletype() const;
  inline void set_battletype(::google::protobuf::int32 value);
  
  // optional int32 myrank = 2;
  inline bool has_myrank() const;
  inline void clear_myrank();
  static const int kMyrankFieldNumber = 2;
  inline ::google::protobuf::int32 myrank() const;
  inline void set_myrank(::google::protobuf::int32 value);
  
  // optional int64 mypoint = 3;
  inline bool has_mypoint() const;
  inline void clear_mypoint();
  static const int kMypointFieldNumber = 3;
  inline ::google::protobuf::int64 mypoint() const;
  inline void set_mypoint(::google::protobuf::int64 value);
  
  // optional int64 finishTime = 5;
  inline bool has_finishtime() const;
  inline void clear_finishtime();
  static const int kFinishTimeFieldNumber = 5;
  inline ::google::protobuf::int64 finishtime() const;
  inline void set_finishtime(::google::protobuf::int64 value);
  
  // optional int64 beginTime = 6;
  inline bool has_begintime() const;
  inline void clear_begintime();
  static const int kBeginTimeFieldNumber = 6;
  inline ::google::protobuf::int64 begintime() const;
  inline void set_begintime(::google::protobuf::int64 value);
  
  // optional int64 finishTime1 = 7;
  inline bool has_finishtime1() const;
  inline void clear_finishtime1();
  static const int kFinishTime1FieldNumber = 7;
  inline ::google::protobuf::int64 finishtime1() const;
  inline void set_finishtime1(::google::protobuf::int64 value);
  
  // optional int32 power = 8;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 8;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);
  
  // optional int32 maxRank = 9;
  inline bool has_maxrank() const;
  inline void clear_maxrank();
  static const int kMaxRankFieldNumber = 9;
  inline ::google::protobuf::int32 maxrank() const;
  inline void set_maxrank(::google::protobuf::int32 value);
  
  // optional int32 todayaAttackTimes = 10;
  inline bool has_todayaattacktimes() const;
  inline void clear_todayaattacktimes();
  static const int kTodayaAttackTimesFieldNumber = 10;
  inline ::google::protobuf::int32 todayaattacktimes() const;
  inline void set_todayaattacktimes(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:protobuf.arena.ArenaInfo)
 private:
  inline void set_has_battletype();
  inline void clear_has_battletype();
  inline void set_has_myrank();
  inline void clear_has_myrank();
  inline void set_has_mypoint();
  inline void clear_has_mypoint();
  inline void set_has_finishtime();
  inline void clear_has_finishtime();
  inline void set_has_begintime();
  inline void clear_has_begintime();
  inline void set_has_finishtime1();
  inline void clear_has_finishtime1();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_maxrank();
  inline void clear_has_maxrank();
  inline void set_has_todayaattacktimes();
  inline void clear_has_todayaattacktimes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 battletype_;
  ::google::protobuf::int32 myrank_;
  ::google::protobuf::int64 mypoint_;
  ::google::protobuf::int64 finishtime_;
  ::google::protobuf::int64 begintime_;
  ::google::protobuf::int64 finishtime1_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 maxrank_;
  ::google::protobuf::int32 todayaattacktimes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_arena_2eproto();
  friend void protobuf_AssignDesc_arena_2eproto();
  friend void protobuf_ShutdownFile_arena_2eproto();
  
  void InitAsDefaultInstance();
  static ArenaInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// iconinfo

// required int32 level = 1;
inline bool iconinfo::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iconinfo::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iconinfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iconinfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 iconinfo::level() const {
  return level_;
}
inline void iconinfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string name = 2;
inline bool iconinfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iconinfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iconinfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iconinfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& iconinfo::name() const {
  return *name_;
}
inline void iconinfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void iconinfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* iconinfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string head = 3;
inline bool iconinfo::has_head() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iconinfo::set_has_head() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iconinfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iconinfo::clear_head() {
  if (head_ != &::google::protobuf::internal::kEmptyString) {
    head_->clear();
  }
  clear_has_head();
}
inline const ::std::string& iconinfo::head() const {
  return *head_;
}
inline void iconinfo::set_head(const ::std::string& value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(value);
}
inline void iconinfo::set_head(const char* value, size_t size) {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  head_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_head() {
  set_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    head_ = new ::std::string;
  }
  return head_;
}
inline ::std::string* iconinfo::release_head() {
  clear_has_head();
  if (head_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_;
    head_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string playerid = 4;
inline bool iconinfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iconinfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void iconinfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void iconinfo::clear_playerid() {
  if (playerid_ != &::google::protobuf::internal::kEmptyString) {
    playerid_->clear();
  }
  clear_has_playerid();
}
inline const ::std::string& iconinfo::playerid() const {
  return *playerid_;
}
inline void iconinfo::set_playerid(const ::std::string& value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(value);
}
inline void iconinfo::set_playerid(const char* value, size_t size) {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  playerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* iconinfo::mutable_playerid() {
  set_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    playerid_ = new ::std::string;
  }
  return playerid_;
}
inline ::std::string* iconinfo::release_playerid() {
  clear_has_playerid();
  if (playerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerid_;
    playerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rank = 5;
inline bool iconinfo::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void iconinfo::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void iconinfo::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void iconinfo::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 iconinfo::rank() const {
  return rank_;
}
inline void iconinfo::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional int64 rankPoints = 6;
inline bool iconinfo::has_rankpoints() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void iconinfo::set_has_rankpoints() {
  _has_bits_[0] |= 0x00000020u;
}
inline void iconinfo::clear_has_rankpoints() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void iconinfo::clear_rankpoints() {
  rankpoints_ = GOOGLE_LONGLONG(0);
  clear_has_rankpoints();
}
inline ::google::protobuf::int64 iconinfo::rankpoints() const {
  return rankpoints_;
}
inline void iconinfo::set_rankpoints(::google::protobuf::int64 value) {
  set_has_rankpoints();
  rankpoints_ = value;
}

// optional int32 power = 7;
inline bool iconinfo::has_power() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void iconinfo::set_has_power() {
  _has_bits_[0] |= 0x00000040u;
}
inline void iconinfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void iconinfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 iconinfo::power() const {
  return power_;
}
inline void iconinfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 headFrame = 8;
inline bool iconinfo::has_headframe() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void iconinfo::set_has_headframe() {
  _has_bits_[0] |= 0x00000080u;
}
inline void iconinfo::clear_has_headframe() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void iconinfo::clear_headframe() {
  headframe_ = 0;
  clear_has_headframe();
}
inline ::google::protobuf::int32 iconinfo::headframe() const {
  return headframe_;
}
inline void iconinfo::set_headframe(::google::protobuf::int32 value) {
  set_has_headframe();
  headframe_ = value;
}

// optional .protobuf.common.LineupDetail attacker = 9;
inline bool iconinfo::has_attacker() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void iconinfo::set_has_attacker() {
  _has_bits_[0] |= 0x00000100u;
}
inline void iconinfo::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void iconinfo::clear_attacker() {
  if (attacker_ != NULL) attacker_->::protobuf::common::LineupDetail::Clear();
  clear_has_attacker();
}
inline const ::protobuf::common::LineupDetail& iconinfo::attacker() const {
  return attacker_ != NULL ? *attacker_ : *default_instance_->attacker_;
}
inline ::protobuf::common::LineupDetail* iconinfo::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == NULL) attacker_ = new ::protobuf::common::LineupDetail;
  return attacker_;
}
inline ::protobuf::common::LineupDetail* iconinfo::release_attacker() {
  clear_has_attacker();
  ::protobuf::common::LineupDetail* temp = attacker_;
  attacker_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// playerInfoList

// repeated .protobuf.arena.iconinfo showinfo = 1;
inline int playerInfoList::showinfo_size() const {
  return showinfo_.size();
}
inline void playerInfoList::clear_showinfo() {
  showinfo_.Clear();
}
inline const ::protobuf::arena::iconinfo& playerInfoList::showinfo(int index) const {
  return showinfo_.Get(index);
}
inline ::protobuf::arena::iconinfo* playerInfoList::mutable_showinfo(int index) {
  return showinfo_.Mutable(index);
}
inline ::protobuf::arena::iconinfo* playerInfoList::add_showinfo() {
  return showinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::arena::iconinfo >&
playerInfoList::showinfo() const {
  return showinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::arena::iconinfo >*
playerInfoList::mutable_showinfo() {
  return &showinfo_;
}

// -------------------------------------------------------------------

// BattleHistory

// required string id = 1;
inline bool BattleHistory::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleHistory::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleHistory::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleHistory::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& BattleHistory::id() const {
  return *id_;
}
inline void BattleHistory::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BattleHistory::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BattleHistory::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* BattleHistory::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string attackName = 2;
inline bool BattleHistory::has_attackname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleHistory::set_has_attackname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleHistory::clear_has_attackname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleHistory::clear_attackname() {
  if (attackname_ != &::google::protobuf::internal::kEmptyString) {
    attackname_->clear();
  }
  clear_has_attackname();
}
inline const ::std::string& BattleHistory::attackname() const {
  return *attackname_;
}
inline void BattleHistory::set_attackname(const ::std::string& value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void BattleHistory::set_attackname(const char* value) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(value);
}
inline void BattleHistory::set_attackname(const char* value, size_t size) {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  attackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackname() {
  set_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    attackname_ = new ::std::string;
  }
  return attackname_;
}
inline ::std::string* BattleHistory::release_attackname() {
  clear_has_attackname();
  if (attackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackname_;
    attackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 attackLvl = 3;
inline bool BattleHistory::has_attacklvl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleHistory::set_has_attacklvl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleHistory::clear_has_attacklvl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleHistory::clear_attacklvl() {
  attacklvl_ = 0;
  clear_has_attacklvl();
}
inline ::google::protobuf::int32 BattleHistory::attacklvl() const {
  return attacklvl_;
}
inline void BattleHistory::set_attacklvl(::google::protobuf::int32 value) {
  set_has_attacklvl();
  attacklvl_ = value;
}

// required string attackHead = 4;
inline bool BattleHistory::has_attackhead() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleHistory::set_has_attackhead() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleHistory::clear_has_attackhead() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleHistory::clear_attackhead() {
  if (attackhead_ != &::google::protobuf::internal::kEmptyString) {
    attackhead_->clear();
  }
  clear_has_attackhead();
}
inline const ::std::string& BattleHistory::attackhead() const {
  return *attackhead_;
}
inline void BattleHistory::set_attackhead(const ::std::string& value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void BattleHistory::set_attackhead(const char* value) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(value);
}
inline void BattleHistory::set_attackhead(const char* value, size_t size) {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  attackhead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackhead() {
  set_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    attackhead_ = new ::std::string;
  }
  return attackhead_;
}
inline ::std::string* BattleHistory::release_attackhead() {
  clear_has_attackhead();
  if (attackhead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackhead_;
    attackhead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string attackId = 5;
inline bool BattleHistory::has_attackid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleHistory::set_has_attackid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleHistory::clear_has_attackid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleHistory::clear_attackid() {
  if (attackid_ != &::google::protobuf::internal::kEmptyString) {
    attackid_->clear();
  }
  clear_has_attackid();
}
inline const ::std::string& BattleHistory::attackid() const {
  return *attackid_;
}
inline void BattleHistory::set_attackid(const ::std::string& value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void BattleHistory::set_attackid(const char* value) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(value);
}
inline void BattleHistory::set_attackid(const char* value, size_t size) {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  attackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_attackid() {
  set_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    attackid_ = new ::std::string;
  }
  return attackid_;
}
inline ::std::string* BattleHistory::release_attackid() {
  clear_has_attackid();
  if (attackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackid_;
    attackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 atHeadFrame = 6;
inline bool BattleHistory::has_atheadframe() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleHistory::set_has_atheadframe() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleHistory::clear_has_atheadframe() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleHistory::clear_atheadframe() {
  atheadframe_ = 0;
  clear_has_atheadframe();
}
inline ::google::protobuf::int32 BattleHistory::atheadframe() const {
  return atheadframe_;
}
inline void BattleHistory::set_atheadframe(::google::protobuf::int32 value) {
  set_has_atheadframe();
  atheadframe_ = value;
}

// required string defenseId = 7;
inline bool BattleHistory::has_defenseid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleHistory::set_has_defenseid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleHistory::clear_has_defenseid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleHistory::clear_defenseid() {
  if (defenseid_ != &::google::protobuf::internal::kEmptyString) {
    defenseid_->clear();
  }
  clear_has_defenseid();
}
inline const ::std::string& BattleHistory::defenseid() const {
  return *defenseid_;
}
inline void BattleHistory::set_defenseid(const ::std::string& value) {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  defenseid_->assign(value);
}
inline void BattleHistory::set_defenseid(const char* value) {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  defenseid_->assign(value);
}
inline void BattleHistory::set_defenseid(const char* value, size_t size) {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  defenseid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_defenseid() {
  set_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    defenseid_ = new ::std::string;
  }
  return defenseid_;
}
inline ::std::string* BattleHistory::release_defenseid() {
  clear_has_defenseid();
  if (defenseid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defenseid_;
    defenseid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string defenseName = 8;
inline bool BattleHistory::has_defensename() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleHistory::set_has_defensename() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleHistory::clear_has_defensename() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleHistory::clear_defensename() {
  if (defensename_ != &::google::protobuf::internal::kEmptyString) {
    defensename_->clear();
  }
  clear_has_defensename();
}
inline const ::std::string& BattleHistory::defensename() const {
  return *defensename_;
}
inline void BattleHistory::set_defensename(const ::std::string& value) {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  defensename_->assign(value);
}
inline void BattleHistory::set_defensename(const char* value) {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  defensename_->assign(value);
}
inline void BattleHistory::set_defensename(const char* value, size_t size) {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  defensename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_defensename() {
  set_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    defensename_ = new ::std::string;
  }
  return defensename_;
}
inline ::std::string* BattleHistory::release_defensename() {
  clear_has_defensename();
  if (defensename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defensename_;
    defensename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 defenseLvl = 9;
inline bool BattleHistory::has_defenselvl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleHistory::set_has_defenselvl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleHistory::clear_has_defenselvl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleHistory::clear_defenselvl() {
  defenselvl_ = 0;
  clear_has_defenselvl();
}
inline ::google::protobuf::int32 BattleHistory::defenselvl() const {
  return defenselvl_;
}
inline void BattleHistory::set_defenselvl(::google::protobuf::int32 value) {
  set_has_defenselvl();
  defenselvl_ = value;
}

// required string defenseHead = 10;
inline bool BattleHistory::has_defensehead() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleHistory::set_has_defensehead() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleHistory::clear_has_defensehead() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleHistory::clear_defensehead() {
  if (defensehead_ != &::google::protobuf::internal::kEmptyString) {
    defensehead_->clear();
  }
  clear_has_defensehead();
}
inline const ::std::string& BattleHistory::defensehead() const {
  return *defensehead_;
}
inline void BattleHistory::set_defensehead(const ::std::string& value) {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  defensehead_->assign(value);
}
inline void BattleHistory::set_defensehead(const char* value) {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  defensehead_->assign(value);
}
inline void BattleHistory::set_defensehead(const char* value, size_t size) {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  defensehead_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleHistory::mutable_defensehead() {
  set_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    defensehead_ = new ::std::string;
  }
  return defensehead_;
}
inline ::std::string* BattleHistory::release_defensehead() {
  clear_has_defensehead();
  if (defensehead_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defensehead_;
    defensehead_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 deHeadFrame = 11;
inline bool BattleHistory::has_deheadframe() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleHistory::set_has_deheadframe() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleHistory::clear_has_deheadframe() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleHistory::clear_deheadframe() {
  deheadframe_ = 0;
  clear_has_deheadframe();
}
inline ::google::protobuf::int32 BattleHistory::deheadframe() const {
  return deheadframe_;
}
inline void BattleHistory::set_deheadframe(::google::protobuf::int32 value) {
  set_has_deheadframe();
  deheadframe_ = value;
}

// required bool victory = 14;
inline bool BattleHistory::has_victory() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BattleHistory::set_has_victory() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BattleHistory::clear_has_victory() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BattleHistory::clear_victory() {
  victory_ = false;
  clear_has_victory();
}
inline bool BattleHistory::victory() const {
  return victory_;
}
inline void BattleHistory::set_victory(bool value) {
  set_has_victory();
  victory_ = value;
}

// optional int32 attackPoint = 15;
inline bool BattleHistory::has_attackpoint() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BattleHistory::set_has_attackpoint() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BattleHistory::clear_has_attackpoint() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BattleHistory::clear_attackpoint() {
  attackpoint_ = 0;
  clear_has_attackpoint();
}
inline ::google::protobuf::int32 BattleHistory::attackpoint() const {
  return attackpoint_;
}
inline void BattleHistory::set_attackpoint(::google::protobuf::int32 value) {
  set_has_attackpoint();
  attackpoint_ = value;
}

// optional int32 defensePoint = 16;
inline bool BattleHistory::has_defensepoint() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BattleHistory::set_has_defensepoint() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BattleHistory::clear_has_defensepoint() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BattleHistory::clear_defensepoint() {
  defensepoint_ = 0;
  clear_has_defensepoint();
}
inline ::google::protobuf::int32 BattleHistory::defensepoint() const {
  return defensepoint_;
}
inline void BattleHistory::set_defensepoint(::google::protobuf::int32 value) {
  set_has_defensepoint();
  defensepoint_ = value;
}

// required int64 time = 17;
inline bool BattleHistory::has_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BattleHistory::set_has_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BattleHistory::clear_has_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BattleHistory::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 BattleHistory::time() const {
  return time_;
}
inline void BattleHistory::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// BattleHistoryList

// repeated .protobuf.arena.BattleHistory battles = 1;
inline int BattleHistoryList::battles_size() const {
  return battles_.size();
}
inline void BattleHistoryList::clear_battles() {
  battles_.Clear();
}
inline const ::protobuf::arena::BattleHistory& BattleHistoryList::battles(int index) const {
  return battles_.Get(index);
}
inline ::protobuf::arena::BattleHistory* BattleHistoryList::mutable_battles(int index) {
  return battles_.Mutable(index);
}
inline ::protobuf::arena::BattleHistory* BattleHistoryList::add_battles() {
  return battles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protobuf::arena::BattleHistory >&
BattleHistoryList::battles() const {
  return battles_;
}
inline ::google::protobuf::RepeatedPtrField< ::protobuf::arena::BattleHistory >*
BattleHistoryList::mutable_battles() {
  return &battles_;
}

// -------------------------------------------------------------------

// BattleLineupDetail

// required int64 seed = 1;
inline bool BattleLineupDetail::has_seed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleLineupDetail::set_has_seed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleLineupDetail::clear_has_seed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleLineupDetail::clear_seed() {
  seed_ = GOOGLE_LONGLONG(0);
  clear_has_seed();
}
inline ::google::protobuf::int64 BattleLineupDetail::seed() const {
  return seed_;
}
inline void BattleLineupDetail::set_seed(::google::protobuf::int64 value) {
  set_has_seed();
  seed_ = value;
}

// required .protobuf.common.LineupDetail attacker = 2;
inline bool BattleLineupDetail::has_attacker() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleLineupDetail::set_has_attacker() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleLineupDetail::clear_has_attacker() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleLineupDetail::clear_attacker() {
  if (attacker_ != NULL) attacker_->::protobuf::common::LineupDetail::Clear();
  clear_has_attacker();
}
inline const ::protobuf::common::LineupDetail& BattleLineupDetail::attacker() const {
  return attacker_ != NULL ? *attacker_ : *default_instance_->attacker_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::mutable_attacker() {
  set_has_attacker();
  if (attacker_ == NULL) attacker_ = new ::protobuf::common::LineupDetail;
  return attacker_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::release_attacker() {
  clear_has_attacker();
  ::protobuf::common::LineupDetail* temp = attacker_;
  attacker_ = NULL;
  return temp;
}

// required .protobuf.common.LineupDetail defineer = 3;
inline bool BattleLineupDetail::has_defineer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleLineupDetail::set_has_defineer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleLineupDetail::clear_has_defineer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleLineupDetail::clear_defineer() {
  if (defineer_ != NULL) defineer_->::protobuf::common::LineupDetail::Clear();
  clear_has_defineer();
}
inline const ::protobuf::common::LineupDetail& BattleLineupDetail::defineer() const {
  return defineer_ != NULL ? *defineer_ : *default_instance_->defineer_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::mutable_defineer() {
  set_has_defineer();
  if (defineer_ == NULL) defineer_ = new ::protobuf::common::LineupDetail;
  return defineer_;
}
inline ::protobuf::common::LineupDetail* BattleLineupDetail::release_defineer() {
  clear_has_defineer();
  ::protobuf::common::LineupDetail* temp = defineer_;
  defineer_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ArenaInfo

// required int32 battletype = 1;
inline bool ArenaInfo::has_battletype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArenaInfo::set_has_battletype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArenaInfo::clear_has_battletype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArenaInfo::clear_battletype() {
  battletype_ = 0;
  clear_has_battletype();
}
inline ::google::protobuf::int32 ArenaInfo::battletype() const {
  return battletype_;
}
inline void ArenaInfo::set_battletype(::google::protobuf::int32 value) {
  set_has_battletype();
  battletype_ = value;
}

// optional int32 myrank = 2;
inline bool ArenaInfo::has_myrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArenaInfo::set_has_myrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArenaInfo::clear_has_myrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArenaInfo::clear_myrank() {
  myrank_ = 0;
  clear_has_myrank();
}
inline ::google::protobuf::int32 ArenaInfo::myrank() const {
  return myrank_;
}
inline void ArenaInfo::set_myrank(::google::protobuf::int32 value) {
  set_has_myrank();
  myrank_ = value;
}

// optional int64 mypoint = 3;
inline bool ArenaInfo::has_mypoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArenaInfo::set_has_mypoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArenaInfo::clear_has_mypoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArenaInfo::clear_mypoint() {
  mypoint_ = GOOGLE_LONGLONG(0);
  clear_has_mypoint();
}
inline ::google::protobuf::int64 ArenaInfo::mypoint() const {
  return mypoint_;
}
inline void ArenaInfo::set_mypoint(::google::protobuf::int64 value) {
  set_has_mypoint();
  mypoint_ = value;
}

// optional int64 finishTime = 5;
inline bool ArenaInfo::has_finishtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArenaInfo::set_has_finishtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArenaInfo::clear_has_finishtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArenaInfo::clear_finishtime() {
  finishtime_ = GOOGLE_LONGLONG(0);
  clear_has_finishtime();
}
inline ::google::protobuf::int64 ArenaInfo::finishtime() const {
  return finishtime_;
}
inline void ArenaInfo::set_finishtime(::google::protobuf::int64 value) {
  set_has_finishtime();
  finishtime_ = value;
}

// optional int64 beginTime = 6;
inline bool ArenaInfo::has_begintime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArenaInfo::set_has_begintime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArenaInfo::clear_has_begintime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArenaInfo::clear_begintime() {
  begintime_ = GOOGLE_LONGLONG(0);
  clear_has_begintime();
}
inline ::google::protobuf::int64 ArenaInfo::begintime() const {
  return begintime_;
}
inline void ArenaInfo::set_begintime(::google::protobuf::int64 value) {
  set_has_begintime();
  begintime_ = value;
}

// optional int64 finishTime1 = 7;
inline bool ArenaInfo::has_finishtime1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArenaInfo::set_has_finishtime1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArenaInfo::clear_has_finishtime1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArenaInfo::clear_finishtime1() {
  finishtime1_ = GOOGLE_LONGLONG(0);
  clear_has_finishtime1();
}
inline ::google::protobuf::int64 ArenaInfo::finishtime1() const {
  return finishtime1_;
}
inline void ArenaInfo::set_finishtime1(::google::protobuf::int64 value) {
  set_has_finishtime1();
  finishtime1_ = value;
}

// optional int32 power = 8;
inline bool ArenaInfo::has_power() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArenaInfo::set_has_power() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArenaInfo::clear_has_power() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArenaInfo::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 ArenaInfo::power() const {
  return power_;
}
inline void ArenaInfo::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 maxRank = 9;
inline bool ArenaInfo::has_maxrank() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArenaInfo::set_has_maxrank() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArenaInfo::clear_has_maxrank() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArenaInfo::clear_maxrank() {
  maxrank_ = 0;
  clear_has_maxrank();
}
inline ::google::protobuf::int32 ArenaInfo::maxrank() const {
  return maxrank_;
}
inline void ArenaInfo::set_maxrank(::google::protobuf::int32 value) {
  set_has_maxrank();
  maxrank_ = value;
}

// optional int32 todayaAttackTimes = 10;
inline bool ArenaInfo::has_todayaattacktimes() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArenaInfo::set_has_todayaattacktimes() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArenaInfo::clear_has_todayaattacktimes() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArenaInfo::clear_todayaattacktimes() {
  todayaattacktimes_ = 0;
  clear_has_todayaattacktimes();
}
inline ::google::protobuf::int32 ArenaInfo::todayaattacktimes() const {
  return todayaattacktimes_;
}
inline void ArenaInfo::set_todayaattacktimes(::google::protobuf::int32 value) {
  set_has_todayaattacktimes();
  todayaattacktimes_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace arena
}  // namespace protobuf

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_arena_2eproto__INCLUDED
