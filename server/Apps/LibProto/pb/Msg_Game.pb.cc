// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_Game.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Msg_Game.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace msg {

void protobuf_ShutdownFile_Msg_5fGame_2eproto() {
  delete Null::default_instance_;
  delete CodeAck::default_instance_;
  delete LoginGateAck::default_instance_;
  delete LoginReq::default_instance_;
  delete PlayerAccountInfo::default_instance_;
  delete RoleInfo::default_instance_;
  delete LoginAck::default_instance_;
  delete EnterGameReq::default_instance_;
  delete EnterGameAck::default_instance_;
  delete CreateRoleReq::default_instance_;
  delete CreateRoleAck::default_instance_;
  delete ExitGameNtf::default_instance_;
  delete PVEFightInfo::default_instance_;
  delete StartPVEFightReq::default_instance_;
  delete StartPVEFightAck::default_instance_;
  delete StartPVPFightReq::default_instance_;
  delete StartPVPFightAck::default_instance_;
  delete StartFightNTF::default_instance_;
  delete JoinFightReq::default_instance_;
  delete FightWorldInfo::default_instance_;
  delete JoinFightAck::default_instance_;
  delete PlayerLoadingReq::default_instance_;
  delete PlayerLoadingAck::default_instance_;
  delete PlayerReadyNotify::default_instance_;
  delete PlayerExitFightNotify::default_instance_;
  delete FrameInputData::default_instance_;
  delete PlayerFrameInput::default_instance_;
  delete RunNextFrameReq::default_instance_;
  delete RunNextFrameAck::default_instance_;
  delete PushFrameInput::default_instance_;
  delete PlayerRecords::default_instance_;
  delete ExitFightReq::default_instance_;
  delete ExitFightAck::default_instance_;
  delete Ping::default_instance_;
  delete Pong::default_instance_;
  delete PingInfo::default_instance_;
  delete PushPingInfo::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Msg_5fGame_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Msg_5fGame_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Null::default_instance_ = new Null();
  CodeAck::default_instance_ = new CodeAck();
  LoginGateAck::default_instance_ = new LoginGateAck();
  LoginReq::default_instance_ = new LoginReq();
  PlayerAccountInfo::default_instance_ = new PlayerAccountInfo();
  RoleInfo::default_instance_ = new RoleInfo();
  LoginAck::default_instance_ = new LoginAck();
  EnterGameReq::default_instance_ = new EnterGameReq();
  EnterGameAck::default_instance_ = new EnterGameAck();
  CreateRoleReq::default_instance_ = new CreateRoleReq();
  CreateRoleAck::default_instance_ = new CreateRoleAck();
  ExitGameNtf::default_instance_ = new ExitGameNtf();
  PVEFightInfo::default_instance_ = new PVEFightInfo();
  StartPVEFightReq::default_instance_ = new StartPVEFightReq();
  StartPVEFightAck::default_instance_ = new StartPVEFightAck();
  StartPVPFightReq::default_instance_ = new StartPVPFightReq();
  StartPVPFightAck::default_instance_ = new StartPVPFightAck();
  StartFightNTF::default_instance_ = new StartFightNTF();
  JoinFightReq::default_instance_ = new JoinFightReq();
  FightWorldInfo::default_instance_ = new FightWorldInfo();
  JoinFightAck::default_instance_ = new JoinFightAck();
  PlayerLoadingReq::default_instance_ = new PlayerLoadingReq();
  PlayerLoadingAck::default_instance_ = new PlayerLoadingAck();
  PlayerReadyNotify::default_instance_ = new PlayerReadyNotify();
  PlayerExitFightNotify::default_instance_ = new PlayerExitFightNotify();
  FrameInputData::default_instance_ = new FrameInputData();
  PlayerFrameInput::default_instance_ = new PlayerFrameInput();
  RunNextFrameReq::default_instance_ = new RunNextFrameReq();
  RunNextFrameAck::default_instance_ = new RunNextFrameAck();
  PushFrameInput::default_instance_ = new PushFrameInput();
  PlayerRecords::default_instance_ = new PlayerRecords();
  ExitFightReq::default_instance_ = new ExitFightReq();
  ExitFightAck::default_instance_ = new ExitFightAck();
  Ping::default_instance_ = new Ping();
  Pong::default_instance_ = new Pong();
  PingInfo::default_instance_ = new PingInfo();
  PushPingInfo::default_instance_ = new PushPingInfo();
  Null::default_instance_->InitAsDefaultInstance();
  CodeAck::default_instance_->InitAsDefaultInstance();
  LoginGateAck::default_instance_->InitAsDefaultInstance();
  LoginReq::default_instance_->InitAsDefaultInstance();
  PlayerAccountInfo::default_instance_->InitAsDefaultInstance();
  RoleInfo::default_instance_->InitAsDefaultInstance();
  LoginAck::default_instance_->InitAsDefaultInstance();
  EnterGameReq::default_instance_->InitAsDefaultInstance();
  EnterGameAck::default_instance_->InitAsDefaultInstance();
  CreateRoleReq::default_instance_->InitAsDefaultInstance();
  CreateRoleAck::default_instance_->InitAsDefaultInstance();
  ExitGameNtf::default_instance_->InitAsDefaultInstance();
  PVEFightInfo::default_instance_->InitAsDefaultInstance();
  StartPVEFightReq::default_instance_->InitAsDefaultInstance();
  StartPVEFightAck::default_instance_->InitAsDefaultInstance();
  StartPVPFightReq::default_instance_->InitAsDefaultInstance();
  StartPVPFightAck::default_instance_->InitAsDefaultInstance();
  StartFightNTF::default_instance_->InitAsDefaultInstance();
  JoinFightReq::default_instance_->InitAsDefaultInstance();
  FightWorldInfo::default_instance_->InitAsDefaultInstance();
  JoinFightAck::default_instance_->InitAsDefaultInstance();
  PlayerLoadingReq::default_instance_->InitAsDefaultInstance();
  PlayerLoadingAck::default_instance_->InitAsDefaultInstance();
  PlayerReadyNotify::default_instance_->InitAsDefaultInstance();
  PlayerExitFightNotify::default_instance_->InitAsDefaultInstance();
  FrameInputData::default_instance_->InitAsDefaultInstance();
  PlayerFrameInput::default_instance_->InitAsDefaultInstance();
  RunNextFrameReq::default_instance_->InitAsDefaultInstance();
  RunNextFrameAck::default_instance_->InitAsDefaultInstance();
  PushFrameInput::default_instance_->InitAsDefaultInstance();
  PlayerRecords::default_instance_->InitAsDefaultInstance();
  ExitFightReq::default_instance_->InitAsDefaultInstance();
  ExitFightAck::default_instance_->InitAsDefaultInstance();
  Ping::default_instance_->InitAsDefaultInstance();
  Pong::default_instance_->InitAsDefaultInstance();
  PingInfo::default_instance_->InitAsDefaultInstance();
  PushPingInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Msg_5fGame_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Msg_5fGame_2eproto_once_);
void protobuf_AddDesc_Msg_5fGame_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Msg_5fGame_2eproto_once_,
                 &protobuf_AddDesc_Msg_5fGame_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Msg_5fGame_2eproto {
  StaticDescriptorInitializer_Msg_5fGame_2eproto() {
    protobuf_AddDesc_Msg_5fGame_2eproto();
  }
} static_descriptor_initializer_Msg_5fGame_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Null::Null()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Null::InitAsDefaultInstance() {
}

Null::Null(const Null& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Null::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Null::~Null() {
  SharedDtor();
}

void Null::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Null::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Null& Null::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

Null* Null::default_instance_ = NULL;

Null* Null::New() const {
  return new Null;
}

void Null::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Null::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void Null::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int Null::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Null::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Null*>(&from));
}

void Null::MergeFrom(const Null& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void Null::CopyFrom(const Null& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Null::IsInitialized() const {

  return true;
}

void Null::Swap(Null* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Null::GetTypeName() const {
  return "msg.Null";
}


// ===================================================================

#ifndef _MSC_VER
const int CodeAck::kCodeFieldNumber;
#endif  // !_MSC_VER

CodeAck::CodeAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CodeAck::InitAsDefaultInstance() {
}

CodeAck::CodeAck(const CodeAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CodeAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CodeAck::~CodeAck() {
  SharedDtor();
}

void CodeAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CodeAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CodeAck& CodeAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

CodeAck* CodeAck::default_instance_ = NULL;

CodeAck* CodeAck::New() const {
  return new CodeAck;
}

void CodeAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CodeAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CodeAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int CodeAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CodeAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CodeAck*>(&from));
}

void CodeAck::MergeFrom(const CodeAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void CodeAck::CopyFrom(const CodeAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CodeAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CodeAck::Swap(CodeAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CodeAck::GetTypeName() const {
  return "msg.CodeAck";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginGateAck::kCodeFieldNumber;
#endif  // !_MSC_VER

LoginGateAck::LoginGateAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginGateAck::InitAsDefaultInstance() {
}

LoginGateAck::LoginGateAck(const LoginGateAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginGateAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginGateAck::~LoginGateAck() {
  SharedDtor();
}

void LoginGateAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginGateAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginGateAck& LoginGateAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

LoginGateAck* LoginGateAck::default_instance_ = NULL;

LoginGateAck* LoginGateAck::New() const {
  return new LoginGateAck;
}

void LoginGateAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginGateAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginGateAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int LoginGateAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginGateAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginGateAck*>(&from));
}

void LoginGateAck::MergeFrom(const LoginGateAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void LoginGateAck::CopyFrom(const LoginGateAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginGateAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginGateAck::Swap(LoginGateAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginGateAck::GetTypeName() const {
  return "msg.LoginGateAck";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginReq::kTokenFieldNumber;
const int LoginReq::kAccountFieldNumber;
const int LoginReq::kPlayerIDFieldNumber;
#endif  // !_MSC_VER

LoginReq::LoginReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginReq::InitAsDefaultInstance() {
}

LoginReq::LoginReq(const LoginReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginReq::SharedCtor() {
  _cached_size_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  playerid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginReq::~LoginReq() {
  SharedDtor();
}

void LoginReq::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginReq& LoginReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

LoginReq* LoginReq::default_instance_ = NULL;

LoginReq* LoginReq::New() const {
  return new LoginReq;
}

void LoginReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    playerid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string token = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // required string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_playerID;
        break;
      }

      // required int64 playerID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->token(), output);
  }

  // required string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

  // required int64 playerID = 3;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->playerid(), output);
  }

}

int LoginReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string token = 1;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // required string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // required int64 playerID = 3;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginReq*>(&from));
}

void LoginReq::MergeFrom(const LoginReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
  }
}

void LoginReq::CopyFrom(const LoginReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void LoginReq::Swap(LoginReq* other) {
  if (other != this) {
    std::swap(token_, other->token_);
    std::swap(account_, other->account_);
    std::swap(playerid_, other->playerid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginReq::GetTypeName() const {
  return "msg.LoginReq";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerAccountInfo::kPlayerIDFieldNumber;
const int PlayerAccountInfo::kNameFieldNumber;
const int PlayerAccountInfo::kArrRoleIdsFieldNumber;
#endif  // !_MSC_VER

PlayerAccountInfo::PlayerAccountInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerAccountInfo::InitAsDefaultInstance() {
}

PlayerAccountInfo::PlayerAccountInfo(const PlayerAccountInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerAccountInfo::SharedCtor() {
  _cached_size_ = 0;
  playerid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerAccountInfo::~PlayerAccountInfo() {
  SharedDtor();
}

void PlayerAccountInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerAccountInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerAccountInfo& PlayerAccountInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerAccountInfo* PlayerAccountInfo::default_instance_ = NULL;

PlayerAccountInfo* PlayerAccountInfo::New() const {
  return new PlayerAccountInfo;
}

void PlayerAccountInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    playerid_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  arrroleids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerAccountInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 playerID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_arrRoleIds;
        break;
      }

      // repeated int64 arrRoleIds = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_arrRoleIds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 24, input, this->mutable_arrroleids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_arrroleids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_arrRoleIds;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerAccountInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 playerID = 1;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->playerid(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // repeated int64 arrRoleIds = 3;
  for (int i = 0; i < this->arrroleids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      3, this->arrroleids(i), output);
  }

}

int PlayerAccountInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 playerID = 1;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated int64 arrRoleIds = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->arrroleids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->arrroleids(i));
    }
    total_size += 1 * this->arrroleids_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerAccountInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerAccountInfo*>(&from));
}

void PlayerAccountInfo::MergeFrom(const PlayerAccountInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  arrroleids_.MergeFrom(from.arrroleids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void PlayerAccountInfo::CopyFrom(const PlayerAccountInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerAccountInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PlayerAccountInfo::Swap(PlayerAccountInfo* other) {
  if (other != this) {
    std::swap(playerid_, other->playerid_);
    std::swap(name_, other->name_);
    arrroleids_.Swap(&other->arrroleids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerAccountInfo::GetTypeName() const {
  return "msg.PlayerAccountInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RoleInfo::kRoleIdFieldNumber;
const int RoleInfo::kNameFieldNumber;
const int RoleInfo::kLvFieldNumber;
const int RoleInfo::kOccupationFieldNumber;
#endif  // !_MSC_VER

RoleInfo::RoleInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoleInfo::InitAsDefaultInstance() {
}

RoleInfo::RoleInfo(const RoleInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoleInfo::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lv_ = 0;
  occupation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoleInfo::~RoleInfo() {
  SharedDtor();
}

void RoleInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoleInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoleInfo& RoleInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

RoleInfo* RoleInfo::default_instance_ = NULL;

RoleInfo* RoleInfo::New() const {
  return new RoleInfo;
}

void RoleInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    lv_ = 0;
    occupation_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoleInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 roleId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lv;
        break;
      }

      // required int32 lv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_occupation;
        break;
      }

      // required int32 occupation = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_occupation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &occupation_)));
          set_has_occupation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoleInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 roleId = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->roleid(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // required int32 lv = 3;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lv(), output);
  }

  // required int32 occupation = 4;
  if (has_occupation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->occupation(), output);
  }

}

int RoleInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 roleId = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->roleid());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required int32 lv = 3;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // required int32 occupation = 4;
    if (has_occupation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->occupation());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoleInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoleInfo*>(&from));
}

void RoleInfo::MergeFrom(const RoleInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_occupation()) {
      set_occupation(from.occupation());
    }
  }
}

void RoleInfo::CopyFrom(const RoleInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoleInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RoleInfo::Swap(RoleInfo* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(name_, other->name_);
    std::swap(lv_, other->lv_);
    std::swap(occupation_, other->occupation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoleInfo::GetTypeName() const {
  return "msg.RoleInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginAck::kCodeFieldNumber;
const int LoginAck::kInfosFieldNumber;
#endif  // !_MSC_VER

LoginAck::LoginAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginAck::InitAsDefaultInstance() {
}

LoginAck::LoginAck(const LoginAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginAck::~LoginAck() {
  SharedDtor();
}

void LoginAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginAck& LoginAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

LoginAck* LoginAck::default_instance_ = NULL;

LoginAck* LoginAck::New() const {
  return new LoginAck;
}

void LoginAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_infos;
        break;
      }

      // repeated .msg.PlayerAccountInfo infos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_infos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_infos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // repeated .msg.PlayerAccountInfo infos = 2;
  for (int i = 0; i < this->infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->infos(i), output);
  }

}

int LoginAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  // repeated .msg.PlayerAccountInfo infos = 2;
  total_size += 1 * this->infos_size();
  for (int i = 0; i < this->infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->infos(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginAck*>(&from));
}

void LoginAck::MergeFrom(const LoginAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  infos_.MergeFrom(from.infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void LoginAck::CopyFrom(const LoginAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < infos_size(); i++) {
    if (!this->infos(i).IsInitialized()) return false;
  }
  return true;
}

void LoginAck::Swap(LoginAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    infos_.Swap(&other->infos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginAck::GetTypeName() const {
  return "msg.LoginAck";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGameReq::kTokenFieldNumber;
const int EnterGameReq::kPlayerIDFieldNumber;
const int EnterGameReq::kRoleIDFieldNumber;
#endif  // !_MSC_VER

EnterGameReq::EnterGameReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGameReq::InitAsDefaultInstance() {
}

EnterGameReq::EnterGameReq(const EnterGameReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGameReq::SharedCtor() {
  _cached_size_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  playerid_ = GOOGLE_LONGLONG(0);
  roleid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGameReq::~EnterGameReq() {
  SharedDtor();
}

void EnterGameReq::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterGameReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGameReq& EnterGameReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

EnterGameReq* EnterGameReq::default_instance_ = NULL;

EnterGameReq* EnterGameReq::New() const {
  return new EnterGameReq;
}

void EnterGameReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
    playerid_ = GOOGLE_LONGLONG(0);
    roleid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGameReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string token = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_playerID;
        break;
      }

      // required int64 playerID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_roleID;
        break;
      }

      // required int64 roleID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roleID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGameReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->token(), output);
  }

  // required int64 playerID = 2;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->playerid(), output);
  }

  // required int64 roleID = 3;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->roleid(), output);
  }

}

int EnterGameReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string token = 1;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // required int64 playerID = 2;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

    // required int64 roleID = 3;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->roleid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGameReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGameReq*>(&from));
}

void EnterGameReq::MergeFrom(const EnterGameReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
  }
}

void EnterGameReq::CopyFrom(const EnterGameReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGameReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void EnterGameReq::Swap(EnterGameReq* other) {
  if (other != this) {
    std::swap(token_, other->token_);
    std::swap(playerid_, other->playerid_);
    std::swap(roleid_, other->roleid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGameReq::GetTypeName() const {
  return "msg.EnterGameReq";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGameAck::kCodeFieldNumber;
const int EnterGameAck::kRoleinfoFieldNumber;
#endif  // !_MSC_VER

EnterGameAck::EnterGameAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGameAck::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  roleinfo_ = const_cast< ::msg::RoleInfo*>(
      ::msg::RoleInfo::internal_default_instance());
#else
  roleinfo_ = const_cast< ::msg::RoleInfo*>(&::msg::RoleInfo::default_instance());
#endif
}

EnterGameAck::EnterGameAck(const EnterGameAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGameAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  roleinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGameAck::~EnterGameAck() {
  SharedDtor();
}

void EnterGameAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete roleinfo_;
  }
}

void EnterGameAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGameAck& EnterGameAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

EnterGameAck* EnterGameAck::default_instance_ = NULL;

EnterGameAck* EnterGameAck::New() const {
  return new EnterGameAck;
}

void EnterGameAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    if (has_roleinfo()) {
      if (roleinfo_ != NULL) roleinfo_->::msg::RoleInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGameAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_roleinfo;
        break;
      }

      // optional .msg.RoleInfo roleinfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roleinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_roleinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGameAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional .msg.RoleInfo roleinfo = 2;
  if (has_roleinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->roleinfo(), output);
  }

}

int EnterGameAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional .msg.RoleInfo roleinfo = 2;
    if (has_roleinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->roleinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGameAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGameAck*>(&from));
}

void EnterGameAck::MergeFrom(const EnterGameAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_roleinfo()) {
      mutable_roleinfo()->::msg::RoleInfo::MergeFrom(from.roleinfo());
    }
  }
}

void EnterGameAck::CopyFrom(const EnterGameAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGameAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_roleinfo()) {
    if (!this->roleinfo().IsInitialized()) return false;
  }
  return true;
}

void EnterGameAck::Swap(EnterGameAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(roleinfo_, other->roleinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGameAck::GetTypeName() const {
  return "msg.EnterGameAck";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateRoleReq::kOccupationFieldNumber;
const int CreateRoleReq::kNameFieldNumber;
#endif  // !_MSC_VER

CreateRoleReq::CreateRoleReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateRoleReq::InitAsDefaultInstance() {
}

CreateRoleReq::CreateRoleReq(const CreateRoleReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateRoleReq::SharedCtor() {
  _cached_size_ = 0;
  occupation_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateRoleReq::~CreateRoleReq() {
  SharedDtor();
}

void CreateRoleReq::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateRoleReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateRoleReq& CreateRoleReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

CreateRoleReq* CreateRoleReq::default_instance_ = NULL;

CreateRoleReq* CreateRoleReq::New() const {
  return new CreateRoleReq;
}

void CreateRoleReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    occupation_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateRoleReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 occupation = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &occupation_)));
          set_has_occupation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateRoleReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 occupation = 1;
  if (has_occupation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->occupation(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

}

int CreateRoleReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 occupation = 1;
    if (has_occupation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->occupation());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateRoleReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateRoleReq*>(&from));
}

void CreateRoleReq::MergeFrom(const CreateRoleReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_occupation()) {
      set_occupation(from.occupation());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void CreateRoleReq::CopyFrom(const CreateRoleReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRoleReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CreateRoleReq::Swap(CreateRoleReq* other) {
  if (other != this) {
    std::swap(occupation_, other->occupation_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateRoleReq::GetTypeName() const {
  return "msg.CreateRoleReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateRoleAck::kCodeFieldNumber;
const int CreateRoleAck::kRoleIDFieldNumber;
#endif  // !_MSC_VER

CreateRoleAck::CreateRoleAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateRoleAck::InitAsDefaultInstance() {
}

CreateRoleAck::CreateRoleAck(const CreateRoleAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateRoleAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  roleid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateRoleAck::~CreateRoleAck() {
  SharedDtor();
}

void CreateRoleAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateRoleAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateRoleAck& CreateRoleAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

CreateRoleAck* CreateRoleAck::default_instance_ = NULL;

CreateRoleAck* CreateRoleAck::New() const {
  return new CreateRoleAck;
}

void CreateRoleAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    roleid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateRoleAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_roleID;
        break;
      }

      // required int64 roleID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roleID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateRoleAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // required int64 roleID = 2;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->roleid(), output);
  }

}

int CreateRoleAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // required int64 roleID = 2;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->roleid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateRoleAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateRoleAck*>(&from));
}

void CreateRoleAck::MergeFrom(const CreateRoleAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
  }
}

void CreateRoleAck::CopyFrom(const CreateRoleAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRoleAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CreateRoleAck::Swap(CreateRoleAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(roleid_, other->roleid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateRoleAck::GetTypeName() const {
  return "msg.CreateRoleAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ExitGameNtf::kCodeFieldNumber;
#endif  // !_MSC_VER

ExitGameNtf::ExitGameNtf()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExitGameNtf::InitAsDefaultInstance() {
}

ExitGameNtf::ExitGameNtf(const ExitGameNtf& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExitGameNtf::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitGameNtf::~ExitGameNtf() {
  SharedDtor();
}

void ExitGameNtf::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExitGameNtf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExitGameNtf& ExitGameNtf::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

ExitGameNtf* ExitGameNtf::default_instance_ = NULL;

ExitGameNtf* ExitGameNtf::New() const {
  return new ExitGameNtf;
}

void ExitGameNtf::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExitGameNtf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitGameNtf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int ExitGameNtf::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitGameNtf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExitGameNtf*>(&from));
}

void ExitGameNtf::MergeFrom(const ExitGameNtf& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void ExitGameNtf::CopyFrom(const ExitGameNtf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitGameNtf::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExitGameNtf::Swap(ExitGameNtf* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExitGameNtf::GetTypeName() const {
  return "msg.ExitGameNtf";
}


// ===================================================================

#ifndef _MSC_VER
const int PVEFightInfo::kRoleIdFieldNumber;
#endif  // !_MSC_VER

PVEFightInfo::PVEFightInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PVEFightInfo::InitAsDefaultInstance() {
}

PVEFightInfo::PVEFightInfo(const PVEFightInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PVEFightInfo::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PVEFightInfo::~PVEFightInfo() {
  SharedDtor();
}

void PVEFightInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PVEFightInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PVEFightInfo& PVEFightInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PVEFightInfo* PVEFightInfo::default_instance_ = NULL;

PVEFightInfo* PVEFightInfo::New() const {
  return new PVEFightInfo;
}

void PVEFightInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PVEFightInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 roleId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PVEFightInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 roleId = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->roleid(), output);
  }

}

int PVEFightInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 roleId = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->roleid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PVEFightInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PVEFightInfo*>(&from));
}

void PVEFightInfo::MergeFrom(const PVEFightInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
  }
}

void PVEFightInfo::CopyFrom(const PVEFightInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PVEFightInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PVEFightInfo::Swap(PVEFightInfo* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PVEFightInfo::GetTypeName() const {
  return "msg.PVEFightInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVEFightReq::kCarbonIdFieldNumber;
const int StartPVEFightReq::kIsOfflineModeFieldNumber;
const int StartPVEFightReq::kRolesFieldNumber;
#endif  // !_MSC_VER

StartPVEFightReq::StartPVEFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVEFightReq::InitAsDefaultInstance() {
}

StartPVEFightReq::StartPVEFightReq(const StartPVEFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVEFightReq::SharedCtor() {
  _cached_size_ = 0;
  carbonid_ = 0;
  isofflinemode_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVEFightReq::~StartPVEFightReq() {
  SharedDtor();
}

void StartPVEFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVEFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVEFightReq& StartPVEFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVEFightReq* StartPVEFightReq::default_instance_ = NULL;

StartPVEFightReq* StartPVEFightReq::New() const {
  return new StartPVEFightReq;
}

void StartPVEFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    carbonid_ = 0;
    isofflinemode_ = false;
  }
  roles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVEFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 carbonId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &carbonid_)));
          set_has_carbonid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_isOfflineMode;
        break;
      }

      // required bool isOfflineMode = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isOfflineMode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isofflinemode_)));
          set_has_isofflinemode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_roles;
        break;
      }

      // repeated .msg.PVEFightInfo roles = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_roles()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_roles;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVEFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 carbonId = 1;
  if (has_carbonid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->carbonid(), output);
  }

  // required bool isOfflineMode = 2;
  if (has_isofflinemode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isofflinemode(), output);
  }

  // repeated .msg.PVEFightInfo roles = 3;
  for (int i = 0; i < this->roles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->roles(i), output);
  }

}

int StartPVEFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 carbonId = 1;
    if (has_carbonid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->carbonid());
    }

    // required bool isOfflineMode = 2;
    if (has_isofflinemode()) {
      total_size += 1 + 1;
    }

  }
  // repeated .msg.PVEFightInfo roles = 3;
  total_size += 1 * this->roles_size();
  for (int i = 0; i < this->roles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->roles(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVEFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVEFightReq*>(&from));
}

void StartPVEFightReq::MergeFrom(const StartPVEFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  roles_.MergeFrom(from.roles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_carbonid()) {
      set_carbonid(from.carbonid());
    }
    if (from.has_isofflinemode()) {
      set_isofflinemode(from.isofflinemode());
    }
  }
}

void StartPVEFightReq::CopyFrom(const StartPVEFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVEFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  for (int i = 0; i < roles_size(); i++) {
    if (!this->roles(i).IsInitialized()) return false;
  }
  return true;
}

void StartPVEFightReq::Swap(StartPVEFightReq* other) {
  if (other != this) {
    std::swap(carbonid_, other->carbonid_);
    std::swap(isofflinemode_, other->isofflinemode_);
    roles_.Swap(&other->roles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVEFightReq::GetTypeName() const {
  return "msg.StartPVEFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVEFightAck::kCodeFieldNumber;
#endif  // !_MSC_VER

StartPVEFightAck::StartPVEFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVEFightAck::InitAsDefaultInstance() {
}

StartPVEFightAck::StartPVEFightAck(const StartPVEFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVEFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVEFightAck::~StartPVEFightAck() {
  SharedDtor();
}

void StartPVEFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVEFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVEFightAck& StartPVEFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVEFightAck* StartPVEFightAck::default_instance_ = NULL;

StartPVEFightAck* StartPVEFightAck::New() const {
  return new StartPVEFightAck;
}

void StartPVEFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVEFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVEFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int StartPVEFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVEFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVEFightAck*>(&from));
}

void StartPVEFightAck::MergeFrom(const StartPVEFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void StartPVEFightAck::CopyFrom(const StartPVEFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVEFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartPVEFightAck::Swap(StartPVEFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVEFightAck::GetTypeName() const {
  return "msg.StartPVEFightAck";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVPFightReq::kFoeIdFieldNumber;
#endif  // !_MSC_VER

StartPVPFightReq::StartPVPFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVPFightReq::InitAsDefaultInstance() {
}

StartPVPFightReq::StartPVPFightReq(const StartPVPFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVPFightReq::SharedCtor() {
  _cached_size_ = 0;
  foeid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVPFightReq::~StartPVPFightReq() {
  SharedDtor();
}

void StartPVPFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVPFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVPFightReq& StartPVPFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVPFightReq* StartPVPFightReq::default_instance_ = NULL;

StartPVPFightReq* StartPVPFightReq::New() const {
  return new StartPVPFightReq;
}

void StartPVPFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    foeid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVPFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 foeId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &foeid_)));
          set_has_foeid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVPFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 foeId = 1;
  if (has_foeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->foeid(), output);
  }

}

int StartPVPFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 foeId = 1;
    if (has_foeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->foeid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVPFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVPFightReq*>(&from));
}

void StartPVPFightReq::MergeFrom(const StartPVPFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_foeid()) {
      set_foeid(from.foeid());
    }
  }
}

void StartPVPFightReq::CopyFrom(const StartPVPFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVPFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartPVPFightReq::Swap(StartPVPFightReq* other) {
  if (other != this) {
    std::swap(foeid_, other->foeid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVPFightReq::GetTypeName() const {
  return "msg.StartPVPFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVPFightAck::kCodeFieldNumber;
#endif  // !_MSC_VER

StartPVPFightAck::StartPVPFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVPFightAck::InitAsDefaultInstance() {
}

StartPVPFightAck::StartPVPFightAck(const StartPVPFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVPFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVPFightAck::~StartPVPFightAck() {
  SharedDtor();
}

void StartPVPFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVPFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVPFightAck& StartPVPFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVPFightAck* StartPVPFightAck::default_instance_ = NULL;

StartPVPFightAck* StartPVPFightAck::New() const {
  return new StartPVPFightAck;
}

void StartPVPFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVPFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVPFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int StartPVPFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVPFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVPFightAck*>(&from));
}

void StartPVPFightAck::MergeFrom(const StartPVPFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void StartPVPFightAck::CopyFrom(const StartPVPFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVPFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartPVPFightAck::Swap(StartPVPFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVPFightAck::GetTypeName() const {
  return "msg.StartPVPFightAck";
}


// ===================================================================

#ifndef _MSC_VER
const int StartFightNTF::kCodeFieldNumber;
const int StartFightNTF::kFightUUIDFieldNumber;
const int StartFightNTF::kFightIPFieldNumber;
const int StartFightNTF::kFightPortFieldNumber;
#endif  // !_MSC_VER

StartFightNTF::StartFightNTF()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartFightNTF::InitAsDefaultInstance() {
}

StartFightNTF::StartFightNTF(const StartFightNTF& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartFightNTF::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  fightuuid_ = 0;
  fightip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fightport_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartFightNTF::~StartFightNTF() {
  SharedDtor();
}

void StartFightNTF::SharedDtor() {
  if (fightip_ != &::google::protobuf::internal::kEmptyString) {
    delete fightip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartFightNTF::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartFightNTF& StartFightNTF::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartFightNTF* StartFightNTF::default_instance_ = NULL;

StartFightNTF* StartFightNTF::New() const {
  return new StartFightNTF;
}

void StartFightNTF::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    fightuuid_ = 0;
    if (has_fightip()) {
      if (fightip_ != &::google::protobuf::internal::kEmptyString) {
        fightip_->clear();
      }
    }
    fightport_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartFightNTF::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fightUUID;
        break;
      }

      // optional int32 fightUUID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fightUUID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightuuid_)));
          set_has_fightuuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_fightIP;
        break;
      }

      // optional string fightIP = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fightIP:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fightip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_fightPort;
        break;
      }

      // optional int32 fightPort = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fightPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightport_)));
          set_has_fightport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartFightNTF::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional int32 fightUUID = 2;
  if (has_fightuuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->fightuuid(), output);
  }

  // optional string fightIP = 3;
  if (has_fightip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->fightip(), output);
  }

  // optional int32 fightPort = 4;
  if (has_fightport()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->fightport(), output);
  }

}

int StartFightNTF::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional int32 fightUUID = 2;
    if (has_fightuuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightuuid());
    }

    // optional string fightIP = 3;
    if (has_fightip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fightip());
    }

    // optional int32 fightPort = 4;
    if (has_fightport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightport());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartFightNTF::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartFightNTF*>(&from));
}

void StartFightNTF::MergeFrom(const StartFightNTF& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_fightuuid()) {
      set_fightuuid(from.fightuuid());
    }
    if (from.has_fightip()) {
      set_fightip(from.fightip());
    }
    if (from.has_fightport()) {
      set_fightport(from.fightport());
    }
  }
}

void StartFightNTF::CopyFrom(const StartFightNTF& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartFightNTF::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartFightNTF::Swap(StartFightNTF* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(fightuuid_, other->fightuuid_);
    std::swap(fightip_, other->fightip_);
    std::swap(fightport_, other->fightport_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartFightNTF::GetTypeName() const {
  return "msg.StartFightNTF";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinFightReq::kFightUUIDFieldNumber;
const int JoinFightReq::kPlayerIDFieldNumber;
const int JoinFightReq::kFrameFieldNumber;
#endif  // !_MSC_VER

JoinFightReq::JoinFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinFightReq::InitAsDefaultInstance() {
}

JoinFightReq::JoinFightReq(const JoinFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinFightReq::SharedCtor() {
  _cached_size_ = 0;
  fightuuid_ = 0;
  playerid_ = GOOGLE_LONGLONG(0);
  frame_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinFightReq::~JoinFightReq() {
  SharedDtor();
}

void JoinFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JoinFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinFightReq& JoinFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

JoinFightReq* JoinFightReq::default_instance_ = NULL;

JoinFightReq* JoinFightReq::New() const {
  return new JoinFightReq;
}

void JoinFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fightuuid_ = 0;
    playerid_ = GOOGLE_LONGLONG(0);
    frame_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 fightUUID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightuuid_)));
          set_has_fightuuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_playerID;
        break;
      }

      // required int64 playerID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_frame;
        break;
      }

      // required int32 frame = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 fightUUID = 1;
  if (has_fightuuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->fightuuid(), output);
  }

  // required int64 playerID = 2;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->playerid(), output);
  }

  // required int32 frame = 3;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->frame(), output);
  }

}

int JoinFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 fightUUID = 1;
    if (has_fightuuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightuuid());
    }

    // required int64 playerID = 2;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

    // required int32 frame = 3;
    if (has_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->frame());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinFightReq*>(&from));
}

void JoinFightReq::MergeFrom(const JoinFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fightuuid()) {
      set_fightuuid(from.fightuuid());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_frame()) {
      set_frame(from.frame());
    }
  }
}

void JoinFightReq::CopyFrom(const JoinFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void JoinFightReq::Swap(JoinFightReq* other) {
  if (other != this) {
    std::swap(fightuuid_, other->fightuuid_);
    std::swap(playerid_, other->playerid_);
    std::swap(frame_, other->frame_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinFightReq::GetTypeName() const {
  return "msg.JoinFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int FightWorldInfo::kFrameFieldNumber;
const int FightWorldInfo::kSvrStatusFieldNumber;
const int FightWorldInfo::kMapIdFieldNumber;
const int FightWorldInfo::kRandomSeedFieldNumber;
const int FightWorldInfo::kUuidSeedFieldNumber;
const int FightWorldInfo::kIsOfflineModeFieldNumber;
#endif  // !_MSC_VER

FightWorldInfo::FightWorldInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FightWorldInfo::InitAsDefaultInstance() {
}

FightWorldInfo::FightWorldInfo(const FightWorldInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FightWorldInfo::SharedCtor() {
  _cached_size_ = 0;
  frame_ = 0;
  svr_status_ = 0;
  mapid_ = 0;
  randomseed_ = 0u;
  uuidseed_ = 0u;
  isofflinemode_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FightWorldInfo::~FightWorldInfo() {
  SharedDtor();
}

void FightWorldInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FightWorldInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FightWorldInfo& FightWorldInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

FightWorldInfo* FightWorldInfo::default_instance_ = NULL;

FightWorldInfo* FightWorldInfo::New() const {
  return new FightWorldInfo;
}

void FightWorldInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    frame_ = 0;
    svr_status_ = 0;
    mapid_ = 0;
    randomseed_ = 0u;
    uuidseed_ = 0u;
    isofflinemode_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FightWorldInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 frame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_svr_status;
        break;
      }

      // required int32 svr_status = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_svr_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &svr_status_)));
          set_has_svr_status();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_mapId;
        break;
      }

      // required int32 mapId = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_randomSeed;
        break;
      }

      // required uint32 randomSeed = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_randomSeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &randomseed_)));
          set_has_randomseed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_uuidSeed;
        break;
      }

      // required uint32 uuidSeed = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuidSeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uuidseed_)));
          set_has_uuidseed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_isOfflineMode;
        break;
      }

      // required bool isOfflineMode = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isOfflineMode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isofflinemode_)));
          set_has_isofflinemode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FightWorldInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 frame = 1;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->frame(), output);
  }

  // required int32 svr_status = 2;
  if (has_svr_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->svr_status(), output);
  }

  // required int32 mapId = 3;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->mapid(), output);
  }

  // required uint32 randomSeed = 4;
  if (has_randomseed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->randomseed(), output);
  }

  // required uint32 uuidSeed = 5;
  if (has_uuidseed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->uuidseed(), output);
  }

  // required bool isOfflineMode = 6;
  if (has_isofflinemode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->isofflinemode(), output);
  }

}

int FightWorldInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 frame = 1;
    if (has_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->frame());
    }

    // required int32 svr_status = 2;
    if (has_svr_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->svr_status());
    }

    // required int32 mapId = 3;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapid());
    }

    // required uint32 randomSeed = 4;
    if (has_randomseed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->randomseed());
    }

    // required uint32 uuidSeed = 5;
    if (has_uuidseed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uuidseed());
    }

    // required bool isOfflineMode = 6;
    if (has_isofflinemode()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FightWorldInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FightWorldInfo*>(&from));
}

void FightWorldInfo::MergeFrom(const FightWorldInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame()) {
      set_frame(from.frame());
    }
    if (from.has_svr_status()) {
      set_svr_status(from.svr_status());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
    if (from.has_randomseed()) {
      set_randomseed(from.randomseed());
    }
    if (from.has_uuidseed()) {
      set_uuidseed(from.uuidseed());
    }
    if (from.has_isofflinemode()) {
      set_isofflinemode(from.isofflinemode());
    }
  }
}

void FightWorldInfo::CopyFrom(const FightWorldInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FightWorldInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void FightWorldInfo::Swap(FightWorldInfo* other) {
  if (other != this) {
    std::swap(frame_, other->frame_);
    std::swap(svr_status_, other->svr_status_);
    std::swap(mapid_, other->mapid_);
    std::swap(randomseed_, other->randomseed_);
    std::swap(uuidseed_, other->uuidseed_);
    std::swap(isofflinemode_, other->isofflinemode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FightWorldInfo::GetTypeName() const {
  return "msg.FightWorldInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinFightAck::kCodeFieldNumber;
const int JoinFightAck::kWorldInfoFieldNumber;
#endif  // !_MSC_VER

JoinFightAck::JoinFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinFightAck::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  worldinfo_ = const_cast< ::msg::FightWorldInfo*>(
      ::msg::FightWorldInfo::internal_default_instance());
#else
  worldinfo_ = const_cast< ::msg::FightWorldInfo*>(&::msg::FightWorldInfo::default_instance());
#endif
}

JoinFightAck::JoinFightAck(const JoinFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  worldinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinFightAck::~JoinFightAck() {
  SharedDtor();
}

void JoinFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete worldinfo_;
  }
}

void JoinFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinFightAck& JoinFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

JoinFightAck* JoinFightAck::default_instance_ = NULL;

JoinFightAck* JoinFightAck::New() const {
  return new JoinFightAck;
}

void JoinFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    if (has_worldinfo()) {
      if (worldinfo_ != NULL) worldinfo_->::msg::FightWorldInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_worldInfo;
        break;
      }

      // optional .msg.FightWorldInfo worldInfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_worldInfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_worldinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional .msg.FightWorldInfo worldInfo = 2;
  if (has_worldinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->worldinfo(), output);
  }

}

int JoinFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional .msg.FightWorldInfo worldInfo = 2;
    if (has_worldinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->worldinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinFightAck*>(&from));
}

void JoinFightAck::MergeFrom(const JoinFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_worldinfo()) {
      mutable_worldinfo()->::msg::FightWorldInfo::MergeFrom(from.worldinfo());
    }
  }
}

void JoinFightAck::CopyFrom(const JoinFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_worldinfo()) {
    if (!this->worldinfo().IsInitialized()) return false;
  }
  return true;
}

void JoinFightAck::Swap(JoinFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(worldinfo_, other->worldinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinFightAck::GetTypeName() const {
  return "msg.JoinFightAck";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerLoadingReq::kPercentFieldNumber;
const int PlayerLoadingReq::kFinishFieldNumber;
#endif  // !_MSC_VER

PlayerLoadingReq::PlayerLoadingReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerLoadingReq::InitAsDefaultInstance() {
}

PlayerLoadingReq::PlayerLoadingReq(const PlayerLoadingReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerLoadingReq::SharedCtor() {
  _cached_size_ = 0;
  percent_ = 0;
  finish_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerLoadingReq::~PlayerLoadingReq() {
  SharedDtor();
}

void PlayerLoadingReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerLoadingReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerLoadingReq& PlayerLoadingReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerLoadingReq* PlayerLoadingReq::default_instance_ = NULL;

PlayerLoadingReq* PlayerLoadingReq::New() const {
  return new PlayerLoadingReq;
}

void PlayerLoadingReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    percent_ = 0;
    finish_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerLoadingReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float percent = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &percent_)));
          set_has_percent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_finish;
        break;
      }

      // required bool finish = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_finish:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &finish_)));
          set_has_finish();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerLoadingReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required float percent = 1;
  if (has_percent()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->percent(), output);
  }

  // required bool finish = 2;
  if (has_finish()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->finish(), output);
  }

}

int PlayerLoadingReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float percent = 1;
    if (has_percent()) {
      total_size += 1 + 4;
    }

    // required bool finish = 2;
    if (has_finish()) {
      total_size += 1 + 1;
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerLoadingReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerLoadingReq*>(&from));
}

void PlayerLoadingReq::MergeFrom(const PlayerLoadingReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_percent()) {
      set_percent(from.percent());
    }
    if (from.has_finish()) {
      set_finish(from.finish());
    }
  }
}

void PlayerLoadingReq::CopyFrom(const PlayerLoadingReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerLoadingReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PlayerLoadingReq::Swap(PlayerLoadingReq* other) {
  if (other != this) {
    std::swap(percent_, other->percent_);
    std::swap(finish_, other->finish_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerLoadingReq::GetTypeName() const {
  return "msg.PlayerLoadingReq";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerLoadingAck::kPidFieldNumber;
const int PlayerLoadingAck::kPercentFieldNumber;
const int PlayerLoadingAck::kFinishFieldNumber;
#endif  // !_MSC_VER

PlayerLoadingAck::PlayerLoadingAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerLoadingAck::InitAsDefaultInstance() {
}

PlayerLoadingAck::PlayerLoadingAck(const PlayerLoadingAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerLoadingAck::SharedCtor() {
  _cached_size_ = 0;
  finish_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerLoadingAck::~PlayerLoadingAck() {
  SharedDtor();
}

void PlayerLoadingAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerLoadingAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerLoadingAck& PlayerLoadingAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerLoadingAck* PlayerLoadingAck::default_instance_ = NULL;

PlayerLoadingAck* PlayerLoadingAck::New() const {
  return new PlayerLoadingAck;
}

void PlayerLoadingAck::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    finish_ = false;
  }
  pid_.Clear();
  percent_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerLoadingAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 8, input, this->mutable_pid())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_pid())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_pid;
        if (input->ExpectTag(21)) goto parse_percent;
        break;
      }

      // repeated float percent = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_percent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_percent())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_percent())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_percent;
        if (input->ExpectTag(24)) goto parse_finish;
        break;
      }

      // required bool finish = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_finish:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &finish_)));
          set_has_finish();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerLoadingAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int64 pid = 1;
  for (int i = 0; i < this->pid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      1, this->pid(i), output);
  }

  // repeated float percent = 2;
  for (int i = 0; i < this->percent_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->percent(i), output);
  }

  // required bool finish = 3;
  if (has_finish()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->finish(), output);
  }

}

int PlayerLoadingAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required bool finish = 3;
    if (has_finish()) {
      total_size += 1 + 1;
    }

  }
  // repeated int64 pid = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->pid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->pid(i));
    }
    total_size += 1 * this->pid_size() + data_size;
  }

  // repeated float percent = 2;
  {
    int data_size = 0;
    data_size = 4 * this->percent_size();
    total_size += 1 * this->percent_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerLoadingAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerLoadingAck*>(&from));
}

void PlayerLoadingAck::MergeFrom(const PlayerLoadingAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  pid_.MergeFrom(from.pid_);
  percent_.MergeFrom(from.percent_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_finish()) {
      set_finish(from.finish());
    }
  }
}

void PlayerLoadingAck::CopyFrom(const PlayerLoadingAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerLoadingAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void PlayerLoadingAck::Swap(PlayerLoadingAck* other) {
  if (other != this) {
    pid_.Swap(&other->pid_);
    percent_.Swap(&other->percent_);
    std::swap(finish_, other->finish_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerLoadingAck::GetTypeName() const {
  return "msg.PlayerLoadingAck";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerReadyNotify::kPidFieldNumber;
#endif  // !_MSC_VER

PlayerReadyNotify::PlayerReadyNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerReadyNotify::InitAsDefaultInstance() {
}

PlayerReadyNotify::PlayerReadyNotify(const PlayerReadyNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerReadyNotify::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerReadyNotify::~PlayerReadyNotify() {
  SharedDtor();
}

void PlayerReadyNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerReadyNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerReadyNotify& PlayerReadyNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerReadyNotify* PlayerReadyNotify::default_instance_ = NULL;

PlayerReadyNotify* PlayerReadyNotify::New() const {
  return new PlayerReadyNotify;
}

void PlayerReadyNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerReadyNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerReadyNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->pid(), output);
  }

}

int PlayerReadyNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerReadyNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerReadyNotify*>(&from));
}

void PlayerReadyNotify::MergeFrom(const PlayerReadyNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
}

void PlayerReadyNotify::CopyFrom(const PlayerReadyNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerReadyNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PlayerReadyNotify::Swap(PlayerReadyNotify* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerReadyNotify::GetTypeName() const {
  return "msg.PlayerReadyNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerExitFightNotify::kPidFieldNumber;
#endif  // !_MSC_VER

PlayerExitFightNotify::PlayerExitFightNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerExitFightNotify::InitAsDefaultInstance() {
}

PlayerExitFightNotify::PlayerExitFightNotify(const PlayerExitFightNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerExitFightNotify::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerExitFightNotify::~PlayerExitFightNotify() {
  SharedDtor();
}

void PlayerExitFightNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerExitFightNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerExitFightNotify& PlayerExitFightNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerExitFightNotify* PlayerExitFightNotify::default_instance_ = NULL;

PlayerExitFightNotify* PlayerExitFightNotify::New() const {
  return new PlayerExitFightNotify;
}

void PlayerExitFightNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerExitFightNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerExitFightNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->pid(), output);
  }

}

int PlayerExitFightNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerExitFightNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerExitFightNotify*>(&from));
}

void PlayerExitFightNotify::MergeFrom(const PlayerExitFightNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
}

void PlayerExitFightNotify::CopyFrom(const PlayerExitFightNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerExitFightNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PlayerExitFightNotify::Swap(PlayerExitFightNotify* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerExitFightNotify::GetTypeName() const {
  return "msg.PlayerExitFightNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int FrameInputData::kKeyDownFieldNumber;
#endif  // !_MSC_VER

FrameInputData::FrameInputData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void FrameInputData::InitAsDefaultInstance() {
}

FrameInputData::FrameInputData(const FrameInputData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void FrameInputData::SharedCtor() {
  _cached_size_ = 0;
  key_down_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameInputData::~FrameInputData() {
  SharedDtor();
}

void FrameInputData::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FrameInputData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FrameInputData& FrameInputData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

FrameInputData* FrameInputData::default_instance_ = NULL;

FrameInputData* FrameInputData::New() const {
  return new FrameInputData;
}

void FrameInputData::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    key_down_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool FrameInputData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 key_down = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &key_down_)));
          set_has_key_down();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FrameInputData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 key_down = 1;
  if (has_key_down()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->key_down(), output);
  }

}

int FrameInputData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 key_down = 1;
    if (has_key_down()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->key_down());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameInputData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FrameInputData*>(&from));
}

void FrameInputData::MergeFrom(const FrameInputData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key_down()) {
      set_key_down(from.key_down());
    }
  }
}

void FrameInputData::CopyFrom(const FrameInputData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameInputData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FrameInputData::Swap(FrameInputData* other) {
  if (other != this) {
    std::swap(key_down_, other->key_down_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string FrameInputData::GetTypeName() const {
  return "msg.FrameInputData";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerFrameInput::kPidFieldNumber;
const int PlayerFrameInput::kFrameFieldNumber;
const int PlayerFrameInput::kInputFieldNumber;
#endif  // !_MSC_VER

PlayerFrameInput::PlayerFrameInput()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerFrameInput::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  input_ = const_cast< ::msg::FrameInputData*>(
      ::msg::FrameInputData::internal_default_instance());
#else
  input_ = const_cast< ::msg::FrameInputData*>(&::msg::FrameInputData::default_instance());
#endif
}

PlayerFrameInput::PlayerFrameInput(const PlayerFrameInput& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerFrameInput::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_LONGLONG(0);
  frame_ = 0u;
  input_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerFrameInput::~PlayerFrameInput() {
  SharedDtor();
}

void PlayerFrameInput::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete input_;
  }
}

void PlayerFrameInput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerFrameInput& PlayerFrameInput::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerFrameInput* PlayerFrameInput::default_instance_ = NULL;

PlayerFrameInput* PlayerFrameInput::New() const {
  return new PlayerFrameInput;
}

void PlayerFrameInput::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_LONGLONG(0);
    frame_ = 0u;
    if (has_input()) {
      if (input_ != NULL) input_->::msg::FrameInputData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerFrameInput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_frame;
        break;
      }

      // required uint32 frame = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_input;
        break;
      }

      // required .msg.FrameInputData input = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerFrameInput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->pid(), output);
  }

  // required uint32 frame = 2;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->frame(), output);
  }

  // required .msg.FrameInputData input = 3;
  if (has_input()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->input(), output);
  }

}

int PlayerFrameInput::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pid());
    }

    // required uint32 frame = 2;
    if (has_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame());
    }

    // required .msg.FrameInputData input = 3;
    if (has_input()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerFrameInput::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerFrameInput*>(&from));
}

void PlayerFrameInput::MergeFrom(const PlayerFrameInput& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_frame()) {
      set_frame(from.frame());
    }
    if (from.has_input()) {
      mutable_input()->::msg::FrameInputData::MergeFrom(from.input());
    }
  }
}

void PlayerFrameInput::CopyFrom(const PlayerFrameInput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerFrameInput::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_input()) {
    if (!this->input().IsInitialized()) return false;
  }
  return true;
}

void PlayerFrameInput::Swap(PlayerFrameInput* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(frame_, other->frame_);
    std::swap(input_, other->input_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerFrameInput::GetTypeName() const {
  return "msg.PlayerFrameInput";
}


// ===================================================================

#ifndef _MSC_VER
const int RunNextFrameReq::kFrameFieldNumber;
const int RunNextFrameReq::kInputFieldNumber;
#endif  // !_MSC_VER

RunNextFrameReq::RunNextFrameReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RunNextFrameReq::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  input_ = const_cast< ::msg::FrameInputData*>(
      ::msg::FrameInputData::internal_default_instance());
#else
  input_ = const_cast< ::msg::FrameInputData*>(&::msg::FrameInputData::default_instance());
#endif
}

RunNextFrameReq::RunNextFrameReq(const RunNextFrameReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RunNextFrameReq::SharedCtor() {
  _cached_size_ = 0;
  frame_ = 0u;
  input_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunNextFrameReq::~RunNextFrameReq() {
  SharedDtor();
}

void RunNextFrameReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete input_;
  }
}

void RunNextFrameReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RunNextFrameReq& RunNextFrameReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

RunNextFrameReq* RunNextFrameReq::default_instance_ = NULL;

RunNextFrameReq* RunNextFrameReq::New() const {
  return new RunNextFrameReq;
}

void RunNextFrameReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    frame_ = 0u;
    if (has_input()) {
      if (input_ != NULL) input_->::msg::FrameInputData::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RunNextFrameReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 frame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_input;
        break;
      }

      // required .msg.FrameInputData input = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RunNextFrameReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 frame = 1;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->frame(), output);
  }

  // required .msg.FrameInputData input = 2;
  if (has_input()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->input(), output);
  }

}

int RunNextFrameReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 frame = 1;
    if (has_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame());
    }

    // required .msg.FrameInputData input = 2;
    if (has_input()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunNextFrameReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RunNextFrameReq*>(&from));
}

void RunNextFrameReq::MergeFrom(const RunNextFrameReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame()) {
      set_frame(from.frame());
    }
    if (from.has_input()) {
      mutable_input()->::msg::FrameInputData::MergeFrom(from.input());
    }
  }
}

void RunNextFrameReq::CopyFrom(const RunNextFrameReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunNextFrameReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_input()) {
    if (!this->input().IsInitialized()) return false;
  }
  return true;
}

void RunNextFrameReq::Swap(RunNextFrameReq* other) {
  if (other != this) {
    std::swap(frame_, other->frame_);
    std::swap(input_, other->input_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RunNextFrameReq::GetTypeName() const {
  return "msg.RunNextFrameReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RunNextFrameAck::kNextFrameFieldNumber;
const int RunNextFrameAck::kFramesFieldNumber;
#endif  // !_MSC_VER

RunNextFrameAck::RunNextFrameAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RunNextFrameAck::InitAsDefaultInstance() {
}

RunNextFrameAck::RunNextFrameAck(const RunNextFrameAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RunNextFrameAck::SharedCtor() {
  _cached_size_ = 0;
  nextframe_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunNextFrameAck::~RunNextFrameAck() {
  SharedDtor();
}

void RunNextFrameAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RunNextFrameAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RunNextFrameAck& RunNextFrameAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

RunNextFrameAck* RunNextFrameAck::default_instance_ = NULL;

RunNextFrameAck* RunNextFrameAck::New() const {
  return new RunNextFrameAck;
}

void RunNextFrameAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    nextframe_ = 0u;
  }
  frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RunNextFrameAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 nextFrame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nextframe_)));
          set_has_nextframe();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_frames;
        break;
      }

      // repeated .msg.PlayerFrameInput frames = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RunNextFrameAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 nextFrame = 1;
  if (has_nextframe()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->nextframe(), output);
  }

  // repeated .msg.PlayerFrameInput frames = 2;
  for (int i = 0; i < this->frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->frames(i), output);
  }

}

int RunNextFrameAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 nextFrame = 1;
    if (has_nextframe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nextframe());
    }

  }
  // repeated .msg.PlayerFrameInput frames = 2;
  total_size += 1 * this->frames_size();
  for (int i = 0; i < this->frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frames(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunNextFrameAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RunNextFrameAck*>(&from));
}

void RunNextFrameAck::MergeFrom(const RunNextFrameAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  frames_.MergeFrom(from.frames_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nextframe()) {
      set_nextframe(from.nextframe());
    }
  }
}

void RunNextFrameAck::CopyFrom(const RunNextFrameAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunNextFrameAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < frames_size(); i++) {
    if (!this->frames(i).IsInitialized()) return false;
  }
  return true;
}

void RunNextFrameAck::Swap(RunNextFrameAck* other) {
  if (other != this) {
    std::swap(nextframe_, other->nextframe_);
    frames_.Swap(&other->frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RunNextFrameAck::GetTypeName() const {
  return "msg.RunNextFrameAck";
}


// ===================================================================

#ifndef _MSC_VER
const int PushFrameInput::kLastFrameFieldNumber;
const int PushFrameInput::kFramesFieldNumber;
#endif  // !_MSC_VER

PushFrameInput::PushFrameInput()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PushFrameInput::InitAsDefaultInstance() {
}

PushFrameInput::PushFrameInput(const PushFrameInput& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PushFrameInput::SharedCtor() {
  _cached_size_ = 0;
  lastframe_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushFrameInput::~PushFrameInput() {
  SharedDtor();
}

void PushFrameInput::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushFrameInput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushFrameInput& PushFrameInput::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PushFrameInput* PushFrameInput::default_instance_ = NULL;

PushFrameInput* PushFrameInput::New() const {
  return new PushFrameInput;
}

void PushFrameInput::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    lastframe_ = 0u;
  }
  frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PushFrameInput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 lastFrame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lastframe_)));
          set_has_lastframe();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_frames;
        break;
      }

      // repeated .msg.PlayerFrameInput frames = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PushFrameInput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 lastFrame = 1;
  if (has_lastframe()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->lastframe(), output);
  }

  // repeated .msg.PlayerFrameInput frames = 2;
  for (int i = 0; i < this->frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->frames(i), output);
  }

}

int PushFrameInput::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 lastFrame = 1;
    if (has_lastframe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lastframe());
    }

  }
  // repeated .msg.PlayerFrameInput frames = 2;
  total_size += 1 * this->frames_size();
  for (int i = 0; i < this->frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frames(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushFrameInput::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushFrameInput*>(&from));
}

void PushFrameInput::MergeFrom(const PushFrameInput& from) {
  GOOGLE_CHECK_NE(&from, this);
  frames_.MergeFrom(from.frames_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_lastframe()) {
      set_lastframe(from.lastframe());
    }
  }
}

void PushFrameInput::CopyFrom(const PushFrameInput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushFrameInput::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < frames_size(); i++) {
    if (!this->frames(i).IsInitialized()) return false;
  }
  return true;
}

void PushFrameInput::Swap(PushFrameInput* other) {
  if (other != this) {
    std::swap(lastframe_, other->lastframe_);
    frames_.Swap(&other->frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushFrameInput::GetTypeName() const {
  return "msg.PushFrameInput";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerRecords::kFramesFieldNumber;
#endif  // !_MSC_VER

PlayerRecords::PlayerRecords()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerRecords::InitAsDefaultInstance() {
}

PlayerRecords::PlayerRecords(const PlayerRecords& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerRecords::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerRecords::~PlayerRecords() {
  SharedDtor();
}

void PlayerRecords::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerRecords::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerRecords& PlayerRecords::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerRecords* PlayerRecords::default_instance_ = NULL;

PlayerRecords* PlayerRecords::New() const {
  return new PlayerRecords;
}

void PlayerRecords::Clear() {
  frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerRecords::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .msg.PlayerFrameInput frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerRecords::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .msg.PlayerFrameInput frames = 1;
  for (int i = 0; i < this->frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->frames(i), output);
  }

}

int PlayerRecords::ByteSize() const {
  int total_size = 0;

  // repeated .msg.PlayerFrameInput frames = 1;
  total_size += 1 * this->frames_size();
  for (int i = 0; i < this->frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frames(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerRecords::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerRecords*>(&from));
}

void PlayerRecords::MergeFrom(const PlayerRecords& from) {
  GOOGLE_CHECK_NE(&from, this);
  frames_.MergeFrom(from.frames_);
}

void PlayerRecords::CopyFrom(const PlayerRecords& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerRecords::IsInitialized() const {

  for (int i = 0; i < frames_size(); i++) {
    if (!this->frames(i).IsInitialized()) return false;
  }
  return true;
}

void PlayerRecords::Swap(PlayerRecords* other) {
  if (other != this) {
    frames_.Swap(&other->frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerRecords::GetTypeName() const {
  return "msg.PlayerRecords";
}


// ===================================================================

#ifndef _MSC_VER
const int ExitFightReq::kFightUUIDFieldNumber;
#endif  // !_MSC_VER

ExitFightReq::ExitFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExitFightReq::InitAsDefaultInstance() {
}

ExitFightReq::ExitFightReq(const ExitFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExitFightReq::SharedCtor() {
  _cached_size_ = 0;
  fightuuid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitFightReq::~ExitFightReq() {
  SharedDtor();
}

void ExitFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExitFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExitFightReq& ExitFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

ExitFightReq* ExitFightReq::default_instance_ = NULL;

ExitFightReq* ExitFightReq::New() const {
  return new ExitFightReq;
}

void ExitFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fightuuid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExitFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 fightUUID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightuuid_)));
          set_has_fightuuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 fightUUID = 1;
  if (has_fightuuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->fightuuid(), output);
  }

}

int ExitFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 fightUUID = 1;
    if (has_fightuuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightuuid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExitFightReq*>(&from));
}

void ExitFightReq::MergeFrom(const ExitFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fightuuid()) {
      set_fightuuid(from.fightuuid());
    }
  }
}

void ExitFightReq::CopyFrom(const ExitFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExitFightReq::Swap(ExitFightReq* other) {
  if (other != this) {
    std::swap(fightuuid_, other->fightuuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExitFightReq::GetTypeName() const {
  return "msg.ExitFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ExitFightAck::kCodeFieldNumber;
#endif  // !_MSC_VER

ExitFightAck::ExitFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExitFightAck::InitAsDefaultInstance() {
}

ExitFightAck::ExitFightAck(const ExitFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExitFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitFightAck::~ExitFightAck() {
  SharedDtor();
}

void ExitFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExitFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExitFightAck& ExitFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

ExitFightAck* ExitFightAck::default_instance_ = NULL;

ExitFightAck* ExitFightAck::New() const {
  return new ExitFightAck;
}

void ExitFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExitFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int ExitFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExitFightAck*>(&from));
}

void ExitFightAck::MergeFrom(const ExitFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void ExitFightAck::CopyFrom(const ExitFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExitFightAck::Swap(ExitFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExitFightAck::GetTypeName() const {
  return "msg.ExitFightAck";
}


// ===================================================================

#ifndef _MSC_VER
const int Ping::kTimestampFieldNumber;
#endif  // !_MSC_VER

Ping::Ping()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Ping::InitAsDefaultInstance() {
}

Ping::Ping(const Ping& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Ping::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ping::~Ping() {
  SharedDtor();
}

void Ping::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Ping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Ping& Ping::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

Ping* Ping::default_instance_ = NULL;

Ping* Ping::New() const {
  return new Ping;
}

void Ping::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Ping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->timestamp(), output);
  }

}

int Ping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ping::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Ping*>(&from));
}

void Ping::MergeFrom(const Ping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void Ping::CopyFrom(const Ping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ping::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Ping::Swap(Ping* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Ping::GetTypeName() const {
  return "msg.Ping";
}


// ===================================================================

#ifndef _MSC_VER
const int Pong::kTimestampFieldNumber;
#endif  // !_MSC_VER

Pong::Pong()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Pong::InitAsDefaultInstance() {
}

Pong::Pong(const Pong& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Pong::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Pong::~Pong() {
  SharedDtor();
}

void Pong::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Pong::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Pong& Pong::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

Pong* Pong::default_instance_ = NULL;

Pong* Pong::New() const {
  return new Pong;
}

void Pong::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    timestamp_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Pong::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 timestamp = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Pong::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->timestamp(), output);
  }

}

int Pong::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 timestamp = 1;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->timestamp());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pong::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Pong*>(&from));
}

void Pong::MergeFrom(const Pong& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
}

void Pong::CopyFrom(const Pong& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pong::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Pong::Swap(Pong* other) {
  if (other != this) {
    std::swap(timestamp_, other->timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Pong::GetTypeName() const {
  return "msg.Pong";
}


// ===================================================================

#ifndef _MSC_VER
const int PingInfo::kPidFieldNumber;
const int PingInfo::kPingFieldNumber;
#endif  // !_MSC_VER

PingInfo::PingInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PingInfo::InitAsDefaultInstance() {
}

PingInfo::PingInfo(const PingInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PingInfo::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_LONGLONG(0);
  ping_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PingInfo::~PingInfo() {
  SharedDtor();
}

void PingInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PingInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PingInfo& PingInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PingInfo* PingInfo::default_instance_ = NULL;

PingInfo* PingInfo::New() const {
  return new PingInfo;
}

void PingInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_LONGLONG(0);
    ping_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PingInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_ping;
        break;
      }

      // required int32 ping = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ping:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ping_)));
          set_has_ping();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PingInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->pid(), output);
  }

  // required int32 ping = 2;
  if (has_ping()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->ping(), output);
  }

}

int PingInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pid());
    }

    // required int32 ping = 2;
    if (has_ping()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ping());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PingInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PingInfo*>(&from));
}

void PingInfo::MergeFrom(const PingInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
    if (from.has_ping()) {
      set_ping(from.ping());
    }
  }
}

void PingInfo::CopyFrom(const PingInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PingInfo::Swap(PingInfo* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(ping_, other->ping_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PingInfo::GetTypeName() const {
  return "msg.PingInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int PushPingInfo::kInfosFieldNumber;
#endif  // !_MSC_VER

PushPingInfo::PushPingInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PushPingInfo::InitAsDefaultInstance() {
}

PushPingInfo::PushPingInfo(const PushPingInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PushPingInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushPingInfo::~PushPingInfo() {
  SharedDtor();
}

void PushPingInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushPingInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushPingInfo& PushPingInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PushPingInfo* PushPingInfo::default_instance_ = NULL;

PushPingInfo* PushPingInfo::New() const {
  return new PushPingInfo;
}

void PushPingInfo::Clear() {
  infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PushPingInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .msg.PingInfo infos = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_infos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_infos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PushPingInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .msg.PingInfo infos = 1;
  for (int i = 0; i < this->infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->infos(i), output);
  }

}

int PushPingInfo::ByteSize() const {
  int total_size = 0;

  // repeated .msg.PingInfo infos = 1;
  total_size += 1 * this->infos_size();
  for (int i = 0; i < this->infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->infos(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushPingInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushPingInfo*>(&from));
}

void PushPingInfo::MergeFrom(const PushPingInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  infos_.MergeFrom(from.infos_);
}

void PushPingInfo::CopyFrom(const PushPingInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushPingInfo::IsInitialized() const {

  for (int i = 0; i < infos_size(); i++) {
    if (!this->infos(i).IsInitialized()) return false;
  }
  return true;
}

void PushPingInfo::Swap(PushPingInfo* other) {
  if (other != this) {
    infos_.Swap(&other->infos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushPingInfo::GetTypeName() const {
  return "msg.PushPingInfo";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

// @@protoc_insertion_point(global_scope)
