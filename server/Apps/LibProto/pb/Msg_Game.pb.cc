// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_Game.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Msg_Game.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace msg {

void protobuf_ShutdownFile_Msg_5fGame_2eproto() {
  delete Null::default_instance_;
  delete CodeAck::default_instance_;
  delete LoginGateAck::default_instance_;
  delete LoginReq::default_instance_;
  delete PlayerAccountInfo::default_instance_;
  delete RoleInfo::default_instance_;
  delete LoginAck::default_instance_;
  delete EnterGameReq::default_instance_;
  delete EnterGameAck::default_instance_;
  delete CreateRoleReq::default_instance_;
  delete CreateRoleAck::default_instance_;
  delete ExitGameNtf::default_instance_;
  delete PVEFightPlayerInfo::default_instance_;
  delete StartPVEFightReq::default_instance_;
  delete StartPVEFightAck::default_instance_;
  delete StartPVPFightReq::default_instance_;
  delete StartPVPFightAck::default_instance_;
  delete StartFightNTF::default_instance_;
  delete JoinFightReq::default_instance_;
  delete JoinFightAck::default_instance_;
  delete PlayerReadyNotify::default_instance_;
  delete PlayerExitFightNotify::default_instance_;
  delete RunNextFrameReq::default_instance_;
  delete RunNextFrameAck::default_instance_;
  delete ExitFightReq::default_instance_;
  delete ExitFightAck::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_Msg_5fGame_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_Msg_5fGame_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Null::default_instance_ = new Null();
  CodeAck::default_instance_ = new CodeAck();
  LoginGateAck::default_instance_ = new LoginGateAck();
  LoginReq::default_instance_ = new LoginReq();
  PlayerAccountInfo::default_instance_ = new PlayerAccountInfo();
  RoleInfo::default_instance_ = new RoleInfo();
  LoginAck::default_instance_ = new LoginAck();
  EnterGameReq::default_instance_ = new EnterGameReq();
  EnterGameAck::default_instance_ = new EnterGameAck();
  CreateRoleReq::default_instance_ = new CreateRoleReq();
  CreateRoleAck::default_instance_ = new CreateRoleAck();
  ExitGameNtf::default_instance_ = new ExitGameNtf();
  PVEFightPlayerInfo::default_instance_ = new PVEFightPlayerInfo();
  StartPVEFightReq::default_instance_ = new StartPVEFightReq();
  StartPVEFightAck::default_instance_ = new StartPVEFightAck();
  StartPVPFightReq::default_instance_ = new StartPVPFightReq();
  StartPVPFightAck::default_instance_ = new StartPVPFightAck();
  StartFightNTF::default_instance_ = new StartFightNTF();
  JoinFightReq::default_instance_ = new JoinFightReq();
  JoinFightAck::default_instance_ = new JoinFightAck();
  PlayerReadyNotify::default_instance_ = new PlayerReadyNotify();
  PlayerExitFightNotify::default_instance_ = new PlayerExitFightNotify();
  RunNextFrameReq::default_instance_ = new RunNextFrameReq();
  RunNextFrameAck::default_instance_ = new RunNextFrameAck();
  ExitFightReq::default_instance_ = new ExitFightReq();
  ExitFightAck::default_instance_ = new ExitFightAck();
  Null::default_instance_->InitAsDefaultInstance();
  CodeAck::default_instance_->InitAsDefaultInstance();
  LoginGateAck::default_instance_->InitAsDefaultInstance();
  LoginReq::default_instance_->InitAsDefaultInstance();
  PlayerAccountInfo::default_instance_->InitAsDefaultInstance();
  RoleInfo::default_instance_->InitAsDefaultInstance();
  LoginAck::default_instance_->InitAsDefaultInstance();
  EnterGameReq::default_instance_->InitAsDefaultInstance();
  EnterGameAck::default_instance_->InitAsDefaultInstance();
  CreateRoleReq::default_instance_->InitAsDefaultInstance();
  CreateRoleAck::default_instance_->InitAsDefaultInstance();
  ExitGameNtf::default_instance_->InitAsDefaultInstance();
  PVEFightPlayerInfo::default_instance_->InitAsDefaultInstance();
  StartPVEFightReq::default_instance_->InitAsDefaultInstance();
  StartPVEFightAck::default_instance_->InitAsDefaultInstance();
  StartPVPFightReq::default_instance_->InitAsDefaultInstance();
  StartPVPFightAck::default_instance_->InitAsDefaultInstance();
  StartFightNTF::default_instance_->InitAsDefaultInstance();
  JoinFightReq::default_instance_->InitAsDefaultInstance();
  JoinFightAck::default_instance_->InitAsDefaultInstance();
  PlayerReadyNotify::default_instance_->InitAsDefaultInstance();
  PlayerExitFightNotify::default_instance_->InitAsDefaultInstance();
  RunNextFrameReq::default_instance_->InitAsDefaultInstance();
  RunNextFrameAck::default_instance_->InitAsDefaultInstance();
  ExitFightReq::default_instance_->InitAsDefaultInstance();
  ExitFightAck::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Msg_5fGame_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_Msg_5fGame_2eproto_once_);
void protobuf_AddDesc_Msg_5fGame_2eproto() {
  ::google::protobuf::::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_Msg_5fGame_2eproto_once_,
                 &protobuf_AddDesc_Msg_5fGame_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Msg_5fGame_2eproto {
  StaticDescriptorInitializer_Msg_5fGame_2eproto() {
    protobuf_AddDesc_Msg_5fGame_2eproto();
  }
} static_descriptor_initializer_Msg_5fGame_2eproto_;
#endif

// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Null::Null()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Null::InitAsDefaultInstance() {
}

Null::Null(const Null& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Null::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Null::~Null() {
  SharedDtor();
}

void Null::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Null::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Null& Null::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

Null* Null::default_instance_ = NULL;

Null* Null::New() const {
  return new Null;
}

void Null::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Null::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void Null::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int Null::ByteSize() const {
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Null::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Null*>(&from));
}

void Null::MergeFrom(const Null& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void Null::CopyFrom(const Null& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Null::IsInitialized() const {

  return true;
}

void Null::Swap(Null* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Null::GetTypeName() const {
  return "msg.Null";
}


// ===================================================================

#ifndef _MSC_VER
const int CodeAck::kCodeFieldNumber;
#endif  // !_MSC_VER

CodeAck::CodeAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CodeAck::InitAsDefaultInstance() {
}

CodeAck::CodeAck(const CodeAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CodeAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CodeAck::~CodeAck() {
  SharedDtor();
}

void CodeAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CodeAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CodeAck& CodeAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

CodeAck* CodeAck::default_instance_ = NULL;

CodeAck* CodeAck::New() const {
  return new CodeAck;
}

void CodeAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CodeAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CodeAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int CodeAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CodeAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CodeAck*>(&from));
}

void CodeAck::MergeFrom(const CodeAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void CodeAck::CopyFrom(const CodeAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CodeAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CodeAck::Swap(CodeAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CodeAck::GetTypeName() const {
  return "msg.CodeAck";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginGateAck::kCodeFieldNumber;
#endif  // !_MSC_VER

LoginGateAck::LoginGateAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginGateAck::InitAsDefaultInstance() {
}

LoginGateAck::LoginGateAck(const LoginGateAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginGateAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginGateAck::~LoginGateAck() {
  SharedDtor();
}

void LoginGateAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginGateAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginGateAck& LoginGateAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

LoginGateAck* LoginGateAck::default_instance_ = NULL;

LoginGateAck* LoginGateAck::New() const {
  return new LoginGateAck;
}

void LoginGateAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginGateAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginGateAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int LoginGateAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginGateAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginGateAck*>(&from));
}

void LoginGateAck::MergeFrom(const LoginGateAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void LoginGateAck::CopyFrom(const LoginGateAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginGateAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void LoginGateAck::Swap(LoginGateAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginGateAck::GetTypeName() const {
  return "msg.LoginGateAck";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginReq::kTokenFieldNumber;
const int LoginReq::kAccountFieldNumber;
const int LoginReq::kPlayerIDFieldNumber;
#endif  // !_MSC_VER

LoginReq::LoginReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginReq::InitAsDefaultInstance() {
}

LoginReq::LoginReq(const LoginReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginReq::SharedCtor() {
  _cached_size_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  playerid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginReq::~LoginReq() {
  SharedDtor();
}

void LoginReq::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginReq& LoginReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

LoginReq* LoginReq::default_instance_ = NULL;

LoginReq* LoginReq::New() const {
  return new LoginReq;
}

void LoginReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
    if (has_account()) {
      if (account_ != &::google::protobuf::internal::kEmptyString) {
        account_->clear();
      }
    }
    playerid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string token = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_account;
        break;
      }

      // required string account = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_account:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_account()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_playerID;
        break;
      }

      // required int64 playerID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->token(), output);
  }

  // required string account = 2;
  if (has_account()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->account(), output);
  }

  // required int64 playerID = 3;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->playerid(), output);
  }

}

int LoginReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string token = 1;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // required string account = 2;
    if (has_account()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->account());
    }

    // required int64 playerID = 3;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginReq*>(&from));
}

void LoginReq::MergeFrom(const LoginReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_account()) {
      set_account(from.account());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
  }
}

void LoginReq::CopyFrom(const LoginReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void LoginReq::Swap(LoginReq* other) {
  if (other != this) {
    std::swap(token_, other->token_);
    std::swap(account_, other->account_);
    std::swap(playerid_, other->playerid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginReq::GetTypeName() const {
  return "msg.LoginReq";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerAccountInfo::kPlayerIDFieldNumber;
const int PlayerAccountInfo::kNameFieldNumber;
const int PlayerAccountInfo::kArrRoleIdsFieldNumber;
#endif  // !_MSC_VER

PlayerAccountInfo::PlayerAccountInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerAccountInfo::InitAsDefaultInstance() {
}

PlayerAccountInfo::PlayerAccountInfo(const PlayerAccountInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerAccountInfo::SharedCtor() {
  _cached_size_ = 0;
  playerid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerAccountInfo::~PlayerAccountInfo() {
  SharedDtor();
}

void PlayerAccountInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerAccountInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerAccountInfo& PlayerAccountInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerAccountInfo* PlayerAccountInfo::default_instance_ = NULL;

PlayerAccountInfo* PlayerAccountInfo::New() const {
  return new PlayerAccountInfo;
}

void PlayerAccountInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    playerid_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  arrroleids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerAccountInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 playerID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_arrRoleIds;
        break;
      }

      // repeated int64 arrRoleIds = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_arrRoleIds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 1, 24, input, this->mutable_arrroleids())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, this->mutable_arrroleids())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_arrRoleIds;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerAccountInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 playerID = 1;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->playerid(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // repeated int64 arrRoleIds = 3;
  for (int i = 0; i < this->arrroleids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(
      3, this->arrroleids(i), output);
  }

}

int PlayerAccountInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 playerID = 1;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  // repeated int64 arrRoleIds = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->arrroleids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int64Size(this->arrroleids(i));
    }
    total_size += 1 * this->arrroleids_size() + data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerAccountInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerAccountInfo*>(&from));
}

void PlayerAccountInfo::MergeFrom(const PlayerAccountInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  arrroleids_.MergeFrom(from.arrroleids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void PlayerAccountInfo::CopyFrom(const PlayerAccountInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerAccountInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PlayerAccountInfo::Swap(PlayerAccountInfo* other) {
  if (other != this) {
    std::swap(playerid_, other->playerid_);
    std::swap(name_, other->name_);
    arrroleids_.Swap(&other->arrroleids_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerAccountInfo::GetTypeName() const {
  return "msg.PlayerAccountInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int RoleInfo::kRoleIdFieldNumber;
const int RoleInfo::kNameFieldNumber;
const int RoleInfo::kLvFieldNumber;
const int RoleInfo::kOccupationFieldNumber;
#endif  // !_MSC_VER

RoleInfo::RoleInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RoleInfo::InitAsDefaultInstance() {
}

RoleInfo::RoleInfo(const RoleInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RoleInfo::SharedCtor() {
  _cached_size_ = 0;
  roleid_ = GOOGLE_LONGLONG(0);
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  lv_ = 0;
  occupation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RoleInfo::~RoleInfo() {
  SharedDtor();
}

void RoleInfo::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RoleInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RoleInfo& RoleInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

RoleInfo* RoleInfo::default_instance_ = NULL;

RoleInfo* RoleInfo::New() const {
  return new RoleInfo;
}

void RoleInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    roleid_ = GOOGLE_LONGLONG(0);
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    lv_ = 0;
    occupation_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RoleInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 roleId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_lv;
        break;
      }

      // required int32 lv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lv:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &lv_)));
          set_has_lv();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_occupation;
        break;
      }

      // required int32 occupation = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_occupation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &occupation_)));
          set_has_occupation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RoleInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 roleId = 1;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->roleid(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // required int32 lv = 3;
  if (has_lv()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->lv(), output);
  }

  // required int32 occupation = 4;
  if (has_occupation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->occupation(), output);
  }

}

int RoleInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 roleId = 1;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->roleid());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required int32 lv = 3;
    if (has_lv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->lv());
    }

    // required int32 occupation = 4;
    if (has_occupation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->occupation());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoleInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RoleInfo*>(&from));
}

void RoleInfo::MergeFrom(const RoleInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_lv()) {
      set_lv(from.lv());
    }
    if (from.has_occupation()) {
      set_occupation(from.occupation());
    }
  }
}

void RoleInfo::CopyFrom(const RoleInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoleInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RoleInfo::Swap(RoleInfo* other) {
  if (other != this) {
    std::swap(roleid_, other->roleid_);
    std::swap(name_, other->name_);
    std::swap(lv_, other->lv_);
    std::swap(occupation_, other->occupation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RoleInfo::GetTypeName() const {
  return "msg.RoleInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int LoginAck::kCodeFieldNumber;
const int LoginAck::kInfosFieldNumber;
#endif  // !_MSC_VER

LoginAck::LoginAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void LoginAck::InitAsDefaultInstance() {
}

LoginAck::LoginAck(const LoginAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void LoginAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginAck::~LoginAck() {
  SharedDtor();
}

void LoginAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void LoginAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LoginAck& LoginAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

LoginAck* LoginAck::default_instance_ = NULL;

LoginAck* LoginAck::New() const {
  return new LoginAck;
}

void LoginAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool LoginAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_infos;
        break;
      }

      // repeated .msg.PlayerAccountInfo infos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_infos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_infos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoginAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // repeated .msg.PlayerAccountInfo infos = 2;
  for (int i = 0; i < this->infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->infos(i), output);
  }

}

int LoginAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  // repeated .msg.PlayerAccountInfo infos = 2;
  total_size += 1 * this->infos_size();
  for (int i = 0; i < this->infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->infos(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LoginAck*>(&from));
}

void LoginAck::MergeFrom(const LoginAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  infos_.MergeFrom(from.infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void LoginAck::CopyFrom(const LoginAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < infos_size(); i++) {
    if (!this->infos(i).IsInitialized()) return false;
  }
  return true;
}

void LoginAck::Swap(LoginAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    infos_.Swap(&other->infos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string LoginAck::GetTypeName() const {
  return "msg.LoginAck";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGameReq::kTokenFieldNumber;
const int EnterGameReq::kPlayerIDFieldNumber;
const int EnterGameReq::kRoleIDFieldNumber;
#endif  // !_MSC_VER

EnterGameReq::EnterGameReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGameReq::InitAsDefaultInstance() {
}

EnterGameReq::EnterGameReq(const EnterGameReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGameReq::SharedCtor() {
  _cached_size_ = 0;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  playerid_ = GOOGLE_LONGLONG(0);
  roleid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGameReq::~EnterGameReq() {
  SharedDtor();
}

void EnterGameReq::SharedDtor() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnterGameReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGameReq& EnterGameReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

EnterGameReq* EnterGameReq::default_instance_ = NULL;

EnterGameReq* EnterGameReq::New() const {
  return new EnterGameReq;
}

void EnterGameReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::kEmptyString) {
        token_->clear();
      }
    }
    playerid_ = GOOGLE_LONGLONG(0);
    roleid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGameReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string token = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_playerID;
        break;
      }

      // required int64 playerID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_roleID;
        break;
      }

      // required int64 roleID = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roleID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGameReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->token(), output);
  }

  // required int64 playerID = 2;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->playerid(), output);
  }

  // required int64 roleID = 3;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->roleid(), output);
  }

}

int EnterGameReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string token = 1;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // required int64 playerID = 2;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

    // required int64 roleID = 3;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->roleid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGameReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGameReq*>(&from));
}

void EnterGameReq::MergeFrom(const EnterGameReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
  }
}

void EnterGameReq::CopyFrom(const EnterGameReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGameReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void EnterGameReq::Swap(EnterGameReq* other) {
  if (other != this) {
    std::swap(token_, other->token_);
    std::swap(playerid_, other->playerid_);
    std::swap(roleid_, other->roleid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGameReq::GetTypeName() const {
  return "msg.EnterGameReq";
}


// ===================================================================

#ifndef _MSC_VER
const int EnterGameAck::kCodeFieldNumber;
const int EnterGameAck::kRoleinfoFieldNumber;
#endif  // !_MSC_VER

EnterGameAck::EnterGameAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void EnterGameAck::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  roleinfo_ = const_cast< ::msg::RoleInfo*>(
      ::msg::RoleInfo::internal_default_instance());
#else
  roleinfo_ = const_cast< ::msg::RoleInfo*>(&::msg::RoleInfo::default_instance());
#endif
}

EnterGameAck::EnterGameAck(const EnterGameAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void EnterGameAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  roleinfo_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnterGameAck::~EnterGameAck() {
  SharedDtor();
}

void EnterGameAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete roleinfo_;
  }
}

void EnterGameAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnterGameAck& EnterGameAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

EnterGameAck* EnterGameAck::default_instance_ = NULL;

EnterGameAck* EnterGameAck::New() const {
  return new EnterGameAck;
}

void EnterGameAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    if (has_roleinfo()) {
      if (roleinfo_ != NULL) roleinfo_->::msg::RoleInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool EnterGameAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_roleinfo;
        break;
      }

      // optional .msg.RoleInfo roleinfo = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_roleinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_roleinfo()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EnterGameAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional .msg.RoleInfo roleinfo = 2;
  if (has_roleinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->roleinfo(), output);
  }

}

int EnterGameAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional .msg.RoleInfo roleinfo = 2;
    if (has_roleinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->roleinfo());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnterGameAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnterGameAck*>(&from));
}

void EnterGameAck::MergeFrom(const EnterGameAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_roleinfo()) {
      mutable_roleinfo()->::msg::RoleInfo::MergeFrom(from.roleinfo());
    }
  }
}

void EnterGameAck::CopyFrom(const EnterGameAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnterGameAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_roleinfo()) {
    if (!this->roleinfo().IsInitialized()) return false;
  }
  return true;
}

void EnterGameAck::Swap(EnterGameAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(roleinfo_, other->roleinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string EnterGameAck::GetTypeName() const {
  return "msg.EnterGameAck";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateRoleReq::kOccupationFieldNumber;
const int CreateRoleReq::kNameFieldNumber;
#endif  // !_MSC_VER

CreateRoleReq::CreateRoleReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateRoleReq::InitAsDefaultInstance() {
}

CreateRoleReq::CreateRoleReq(const CreateRoleReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateRoleReq::SharedCtor() {
  _cached_size_ = 0;
  occupation_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateRoleReq::~CreateRoleReq() {
  SharedDtor();
}

void CreateRoleReq::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateRoleReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateRoleReq& CreateRoleReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

CreateRoleReq* CreateRoleReq::default_instance_ = NULL;

CreateRoleReq* CreateRoleReq::New() const {
  return new CreateRoleReq;
}

void CreateRoleReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    occupation_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateRoleReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 occupation = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &occupation_)));
          set_has_occupation();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateRoleReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 occupation = 1;
  if (has_occupation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->occupation(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

}

int CreateRoleReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 occupation = 1;
    if (has_occupation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->occupation());
    }

    // required string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateRoleReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateRoleReq*>(&from));
}

void CreateRoleReq::MergeFrom(const CreateRoleReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_occupation()) {
      set_occupation(from.occupation());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
  }
}

void CreateRoleReq::CopyFrom(const CreateRoleReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRoleReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CreateRoleReq::Swap(CreateRoleReq* other) {
  if (other != this) {
    std::swap(occupation_, other->occupation_);
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateRoleReq::GetTypeName() const {
  return "msg.CreateRoleReq";
}


// ===================================================================

#ifndef _MSC_VER
const int CreateRoleAck::kCodeFieldNumber;
const int CreateRoleAck::kRoleIDFieldNumber;
#endif  // !_MSC_VER

CreateRoleAck::CreateRoleAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void CreateRoleAck::InitAsDefaultInstance() {
}

CreateRoleAck::CreateRoleAck(const CreateRoleAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void CreateRoleAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  roleid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CreateRoleAck::~CreateRoleAck() {
  SharedDtor();
}

void CreateRoleAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CreateRoleAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CreateRoleAck& CreateRoleAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

CreateRoleAck* CreateRoleAck::default_instance_ = NULL;

CreateRoleAck* CreateRoleAck::New() const {
  return new CreateRoleAck;
}

void CreateRoleAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    roleid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool CreateRoleAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_roleID;
        break;
      }

      // required int64 roleID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_roleID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &roleid_)));
          set_has_roleid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CreateRoleAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // required int64 roleID = 2;
  if (has_roleid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->roleid(), output);
  }

}

int CreateRoleAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // required int64 roleID = 2;
    if (has_roleid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->roleid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CreateRoleAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CreateRoleAck*>(&from));
}

void CreateRoleAck::MergeFrom(const CreateRoleAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_roleid()) {
      set_roleid(from.roleid());
    }
  }
}

void CreateRoleAck::CopyFrom(const CreateRoleAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CreateRoleAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CreateRoleAck::Swap(CreateRoleAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(roleid_, other->roleid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CreateRoleAck::GetTypeName() const {
  return "msg.CreateRoleAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ExitGameNtf::kCodeFieldNumber;
#endif  // !_MSC_VER

ExitGameNtf::ExitGameNtf()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExitGameNtf::InitAsDefaultInstance() {
}

ExitGameNtf::ExitGameNtf(const ExitGameNtf& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExitGameNtf::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitGameNtf::~ExitGameNtf() {
  SharedDtor();
}

void ExitGameNtf::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExitGameNtf::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExitGameNtf& ExitGameNtf::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

ExitGameNtf* ExitGameNtf::default_instance_ = NULL;

ExitGameNtf* ExitGameNtf::New() const {
  return new ExitGameNtf;
}

void ExitGameNtf::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExitGameNtf::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitGameNtf::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int ExitGameNtf::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitGameNtf::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExitGameNtf*>(&from));
}

void ExitGameNtf::MergeFrom(const ExitGameNtf& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void ExitGameNtf::CopyFrom(const ExitGameNtf& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitGameNtf::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExitGameNtf::Swap(ExitGameNtf* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExitGameNtf::GetTypeName() const {
  return "msg.ExitGameNtf";
}


// ===================================================================

#ifndef _MSC_VER
const int PVEFightPlayerInfo::kPidFieldNumber;
#endif  // !_MSC_VER

PVEFightPlayerInfo::PVEFightPlayerInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PVEFightPlayerInfo::InitAsDefaultInstance() {
}

PVEFightPlayerInfo::PVEFightPlayerInfo(const PVEFightPlayerInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PVEFightPlayerInfo::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PVEFightPlayerInfo::~PVEFightPlayerInfo() {
  SharedDtor();
}

void PVEFightPlayerInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PVEFightPlayerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PVEFightPlayerInfo& PVEFightPlayerInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PVEFightPlayerInfo* PVEFightPlayerInfo::default_instance_ = NULL;

PVEFightPlayerInfo* PVEFightPlayerInfo::New() const {
  return new PVEFightPlayerInfo;
}

void PVEFightPlayerInfo::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PVEFightPlayerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PVEFightPlayerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->pid(), output);
  }

}

int PVEFightPlayerInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PVEFightPlayerInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PVEFightPlayerInfo*>(&from));
}

void PVEFightPlayerInfo::MergeFrom(const PVEFightPlayerInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
}

void PVEFightPlayerInfo::CopyFrom(const PVEFightPlayerInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PVEFightPlayerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PVEFightPlayerInfo::Swap(PVEFightPlayerInfo* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PVEFightPlayerInfo::GetTypeName() const {
  return "msg.PVEFightPlayerInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVEFightReq::kCarbonIdFieldNumber;
const int StartPVEFightReq::kInfosFieldNumber;
#endif  // !_MSC_VER

StartPVEFightReq::StartPVEFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVEFightReq::InitAsDefaultInstance() {
}

StartPVEFightReq::StartPVEFightReq(const StartPVEFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVEFightReq::SharedCtor() {
  _cached_size_ = 0;
  carbonid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVEFightReq::~StartPVEFightReq() {
  SharedDtor();
}

void StartPVEFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVEFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVEFightReq& StartPVEFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVEFightReq* StartPVEFightReq::default_instance_ = NULL;

StartPVEFightReq* StartPVEFightReq::New() const {
  return new StartPVEFightReq;
}

void StartPVEFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    carbonid_ = 0;
  }
  infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVEFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 carbonId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &carbonid_)));
          set_has_carbonid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_infos;
        break;
      }

      // repeated .msg.PVEFightPlayerInfo infos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_infos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_infos;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVEFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 carbonId = 1;
  if (has_carbonid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->carbonid(), output);
  }

  // repeated .msg.PVEFightPlayerInfo infos = 2;
  for (int i = 0; i < this->infos_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->infos(i), output);
  }

}

int StartPVEFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 carbonId = 1;
    if (has_carbonid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->carbonid());
    }

  }
  // repeated .msg.PVEFightPlayerInfo infos = 2;
  total_size += 1 * this->infos_size();
  for (int i = 0; i < this->infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->infos(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVEFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVEFightReq*>(&from));
}

void StartPVEFightReq::MergeFrom(const StartPVEFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  infos_.MergeFrom(from.infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_carbonid()) {
      set_carbonid(from.carbonid());
    }
  }
}

void StartPVEFightReq::CopyFrom(const StartPVEFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVEFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < infos_size(); i++) {
    if (!this->infos(i).IsInitialized()) return false;
  }
  return true;
}

void StartPVEFightReq::Swap(StartPVEFightReq* other) {
  if (other != this) {
    std::swap(carbonid_, other->carbonid_);
    infos_.Swap(&other->infos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVEFightReq::GetTypeName() const {
  return "msg.StartPVEFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVEFightAck::kCodeFieldNumber;
#endif  // !_MSC_VER

StartPVEFightAck::StartPVEFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVEFightAck::InitAsDefaultInstance() {
}

StartPVEFightAck::StartPVEFightAck(const StartPVEFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVEFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVEFightAck::~StartPVEFightAck() {
  SharedDtor();
}

void StartPVEFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVEFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVEFightAck& StartPVEFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVEFightAck* StartPVEFightAck::default_instance_ = NULL;

StartPVEFightAck* StartPVEFightAck::New() const {
  return new StartPVEFightAck;
}

void StartPVEFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVEFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVEFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int StartPVEFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVEFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVEFightAck*>(&from));
}

void StartPVEFightAck::MergeFrom(const StartPVEFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void StartPVEFightAck::CopyFrom(const StartPVEFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVEFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartPVEFightAck::Swap(StartPVEFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVEFightAck::GetTypeName() const {
  return "msg.StartPVEFightAck";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVPFightReq::kFoeIdFieldNumber;
#endif  // !_MSC_VER

StartPVPFightReq::StartPVPFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVPFightReq::InitAsDefaultInstance() {
}

StartPVPFightReq::StartPVPFightReq(const StartPVPFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVPFightReq::SharedCtor() {
  _cached_size_ = 0;
  foeid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVPFightReq::~StartPVPFightReq() {
  SharedDtor();
}

void StartPVPFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVPFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVPFightReq& StartPVPFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVPFightReq* StartPVPFightReq::default_instance_ = NULL;

StartPVPFightReq* StartPVPFightReq::New() const {
  return new StartPVPFightReq;
}

void StartPVPFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    foeid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVPFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 foeId = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &foeid_)));
          set_has_foeid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVPFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 foeId = 1;
  if (has_foeid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->foeid(), output);
  }

}

int StartPVPFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 foeId = 1;
    if (has_foeid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->foeid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVPFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVPFightReq*>(&from));
}

void StartPVPFightReq::MergeFrom(const StartPVPFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_foeid()) {
      set_foeid(from.foeid());
    }
  }
}

void StartPVPFightReq::CopyFrom(const StartPVPFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVPFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartPVPFightReq::Swap(StartPVPFightReq* other) {
  if (other != this) {
    std::swap(foeid_, other->foeid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVPFightReq::GetTypeName() const {
  return "msg.StartPVPFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int StartPVPFightAck::kCodeFieldNumber;
#endif  // !_MSC_VER

StartPVPFightAck::StartPVPFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartPVPFightAck::InitAsDefaultInstance() {
}

StartPVPFightAck::StartPVPFightAck(const StartPVPFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartPVPFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartPVPFightAck::~StartPVPFightAck() {
  SharedDtor();
}

void StartPVPFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartPVPFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartPVPFightAck& StartPVPFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartPVPFightAck* StartPVPFightAck::default_instance_ = NULL;

StartPVPFightAck* StartPVPFightAck::New() const {
  return new StartPVPFightAck;
}

void StartPVPFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartPVPFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartPVPFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int StartPVPFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartPVPFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartPVPFightAck*>(&from));
}

void StartPVPFightAck::MergeFrom(const StartPVPFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void StartPVPFightAck::CopyFrom(const StartPVPFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPVPFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartPVPFightAck::Swap(StartPVPFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartPVPFightAck::GetTypeName() const {
  return "msg.StartPVPFightAck";
}


// ===================================================================

#ifndef _MSC_VER
const int StartFightNTF::kCodeFieldNumber;
const int StartFightNTF::kFightUUIDFieldNumber;
const int StartFightNTF::kFightIPFieldNumber;
const int StartFightNTF::kFightPortFieldNumber;
#endif  // !_MSC_VER

StartFightNTF::StartFightNTF()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void StartFightNTF::InitAsDefaultInstance() {
}

StartFightNTF::StartFightNTF(const StartFightNTF& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void StartFightNTF::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  fightuuid_ = 0;
  fightip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  fightport_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartFightNTF::~StartFightNTF() {
  SharedDtor();
}

void StartFightNTF::SharedDtor() {
  if (fightip_ != &::google::protobuf::internal::kEmptyString) {
    delete fightip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartFightNTF::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartFightNTF& StartFightNTF::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

StartFightNTF* StartFightNTF::default_instance_ = NULL;

StartFightNTF* StartFightNTF::New() const {
  return new StartFightNTF;
}

void StartFightNTF::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    fightuuid_ = 0;
    if (has_fightip()) {
      if (fightip_ != &::google::protobuf::internal::kEmptyString) {
        fightip_->clear();
      }
    }
    fightport_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool StartFightNTF::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fightUUID;
        break;
      }

      // optional int32 fightUUID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fightUUID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightuuid_)));
          set_has_fightuuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_fightIP;
        break;
      }

      // optional string fightIP = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fightIP:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fightip()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_fightPort;
        break;
      }

      // optional int32 fightPort = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fightPort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightport_)));
          set_has_fightport();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StartFightNTF::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional int32 fightUUID = 2;
  if (has_fightuuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->fightuuid(), output);
  }

  // optional string fightIP = 3;
  if (has_fightip()) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->fightip(), output);
  }

  // optional int32 fightPort = 4;
  if (has_fightport()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->fightport(), output);
  }

}

int StartFightNTF::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional int32 fightUUID = 2;
    if (has_fightuuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightuuid());
    }

    // optional string fightIP = 3;
    if (has_fightip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fightip());
    }

    // optional int32 fightPort = 4;
    if (has_fightport()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightport());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartFightNTF::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartFightNTF*>(&from));
}

void StartFightNTF::MergeFrom(const StartFightNTF& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_fightuuid()) {
      set_fightuuid(from.fightuuid());
    }
    if (from.has_fightip()) {
      set_fightip(from.fightip());
    }
    if (from.has_fightport()) {
      set_fightport(from.fightport());
    }
  }
}

void StartFightNTF::CopyFrom(const StartFightNTF& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartFightNTF::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void StartFightNTF::Swap(StartFightNTF* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(fightuuid_, other->fightuuid_);
    std::swap(fightip_, other->fightip_);
    std::swap(fightport_, other->fightport_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string StartFightNTF::GetTypeName() const {
  return "msg.StartFightNTF";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinFightReq::kFightUUIDFieldNumber;
const int JoinFightReq::kPlayerIDFieldNumber;
const int JoinFightReq::kFrameFieldNumber;
#endif  // !_MSC_VER

JoinFightReq::JoinFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinFightReq::InitAsDefaultInstance() {
}

JoinFightReq::JoinFightReq(const JoinFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinFightReq::SharedCtor() {
  _cached_size_ = 0;
  fightuuid_ = 0;
  playerid_ = GOOGLE_LONGLONG(0);
  frame_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinFightReq::~JoinFightReq() {
  SharedDtor();
}

void JoinFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JoinFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinFightReq& JoinFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

JoinFightReq* JoinFightReq::default_instance_ = NULL;

JoinFightReq* JoinFightReq::New() const {
  return new JoinFightReq;
}

void JoinFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fightuuid_ = 0;
    playerid_ = GOOGLE_LONGLONG(0);
    frame_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 fightUUID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightuuid_)));
          set_has_fightuuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_playerID;
        break;
      }

      // required int64 playerID = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_playerID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &playerid_)));
          set_has_playerid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_frame;
        break;
      }

      // required int32 frame = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 fightUUID = 1;
  if (has_fightuuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->fightuuid(), output);
  }

  // required int64 playerID = 2;
  if (has_playerid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->playerid(), output);
  }

  // required int32 frame = 3;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->frame(), output);
  }

}

int JoinFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 fightUUID = 1;
    if (has_fightuuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightuuid());
    }

    // required int64 playerID = 2;
    if (has_playerid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->playerid());
    }

    // required int32 frame = 3;
    if (has_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->frame());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinFightReq*>(&from));
}

void JoinFightReq::MergeFrom(const JoinFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fightuuid()) {
      set_fightuuid(from.fightuuid());
    }
    if (from.has_playerid()) {
      set_playerid(from.playerid());
    }
    if (from.has_frame()) {
      set_frame(from.frame());
    }
  }
}

void JoinFightReq::CopyFrom(const JoinFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void JoinFightReq::Swap(JoinFightReq* other) {
  if (other != this) {
    std::swap(fightuuid_, other->fightuuid_);
    std::swap(playerid_, other->playerid_);
    std::swap(frame_, other->frame_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinFightReq::GetTypeName() const {
  return "msg.JoinFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int JoinFightAck::kCodeFieldNumber;
const int JoinFightAck::kMapIdFieldNumber;
const int JoinFightAck::kRandomSeedFieldNumber;
const int JoinFightAck::kUuidSeedFieldNumber;
#endif  // !_MSC_VER

JoinFightAck::JoinFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void JoinFightAck::InitAsDefaultInstance() {
}

JoinFightAck::JoinFightAck(const JoinFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void JoinFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  mapid_ = 0;
  randomseed_ = 0u;
  uuidseed_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

JoinFightAck::~JoinFightAck() {
  SharedDtor();
}

void JoinFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void JoinFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const JoinFightAck& JoinFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

JoinFightAck* JoinFightAck::default_instance_ = NULL;

JoinFightAck* JoinFightAck::New() const {
  return new JoinFightAck;
}

void JoinFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
    mapid_ = 0;
    randomseed_ = 0u;
    uuidseed_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool JoinFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_mapId;
        break;
      }

      // optional int32 mapId = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_mapId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mapid_)));
          set_has_mapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_randomSeed;
        break;
      }

      // optional uint32 randomSeed = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_randomSeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &randomseed_)));
          set_has_randomseed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_uuidSeed;
        break;
      }

      // optional uint32 uuidSeed = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_uuidSeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &uuidseed_)));
          set_has_uuidseed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void JoinFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional int32 mapId = 2;
  if (has_mapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->mapid(), output);
  }

  // optional uint32 randomSeed = 3;
  if (has_randomseed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->randomseed(), output);
  }

  // optional uint32 uuidSeed = 4;
  if (has_uuidseed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->uuidseed(), output);
  }

}

int JoinFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

    // optional int32 mapId = 2;
    if (has_mapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->mapid());
    }

    // optional uint32 randomSeed = 3;
    if (has_randomseed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->randomseed());
    }

    // optional uint32 uuidSeed = 4;
    if (has_uuidseed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->uuidseed());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void JoinFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const JoinFightAck*>(&from));
}

void JoinFightAck::MergeFrom(const JoinFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_mapid()) {
      set_mapid(from.mapid());
    }
    if (from.has_randomseed()) {
      set_randomseed(from.randomseed());
    }
    if (from.has_uuidseed()) {
      set_uuidseed(from.uuidseed());
    }
  }
}

void JoinFightAck::CopyFrom(const JoinFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool JoinFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void JoinFightAck::Swap(JoinFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(mapid_, other->mapid_);
    std::swap(randomseed_, other->randomseed_);
    std::swap(uuidseed_, other->uuidseed_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string JoinFightAck::GetTypeName() const {
  return "msg.JoinFightAck";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerReadyNotify::kPidFieldNumber;
#endif  // !_MSC_VER

PlayerReadyNotify::PlayerReadyNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerReadyNotify::InitAsDefaultInstance() {
}

PlayerReadyNotify::PlayerReadyNotify(const PlayerReadyNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerReadyNotify::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerReadyNotify::~PlayerReadyNotify() {
  SharedDtor();
}

void PlayerReadyNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerReadyNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerReadyNotify& PlayerReadyNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerReadyNotify* PlayerReadyNotify::default_instance_ = NULL;

PlayerReadyNotify* PlayerReadyNotify::New() const {
  return new PlayerReadyNotify;
}

void PlayerReadyNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerReadyNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerReadyNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->pid(), output);
  }

}

int PlayerReadyNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerReadyNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerReadyNotify*>(&from));
}

void PlayerReadyNotify::MergeFrom(const PlayerReadyNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
}

void PlayerReadyNotify::CopyFrom(const PlayerReadyNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerReadyNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PlayerReadyNotify::Swap(PlayerReadyNotify* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerReadyNotify::GetTypeName() const {
  return "msg.PlayerReadyNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int PlayerExitFightNotify::kPidFieldNumber;
#endif  // !_MSC_VER

PlayerExitFightNotify::PlayerExitFightNotify()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void PlayerExitFightNotify::InitAsDefaultInstance() {
}

PlayerExitFightNotify::PlayerExitFightNotify(const PlayerExitFightNotify& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void PlayerExitFightNotify::SharedCtor() {
  _cached_size_ = 0;
  pid_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PlayerExitFightNotify::~PlayerExitFightNotify() {
  SharedDtor();
}

void PlayerExitFightNotify::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PlayerExitFightNotify::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PlayerExitFightNotify& PlayerExitFightNotify::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

PlayerExitFightNotify* PlayerExitFightNotify::default_instance_ = NULL;

PlayerExitFightNotify* PlayerExitFightNotify::New() const {
  return new PlayerExitFightNotify;
}

void PlayerExitFightNotify::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    pid_ = GOOGLE_LONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool PlayerExitFightNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 pid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pid_)));
          set_has_pid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PlayerExitFightNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int64 pid = 1;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->pid(), output);
  }

}

int PlayerExitFightNotify::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 pid = 1;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerExitFightNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PlayerExitFightNotify*>(&from));
}

void PlayerExitFightNotify::MergeFrom(const PlayerExitFightNotify& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pid()) {
      set_pid(from.pid());
    }
  }
}

void PlayerExitFightNotify::CopyFrom(const PlayerExitFightNotify& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerExitFightNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PlayerExitFightNotify::Swap(PlayerExitFightNotify* other) {
  if (other != this) {
    std::swap(pid_, other->pid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PlayerExitFightNotify::GetTypeName() const {
  return "msg.PlayerExitFightNotify";
}


// ===================================================================

#ifndef _MSC_VER
const int RunNextFrameReq::kFrameFieldNumber;
const int RunNextFrameReq::kInputFieldNumber;
#endif  // !_MSC_VER

RunNextFrameReq::RunNextFrameReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RunNextFrameReq::InitAsDefaultInstance() {
}

RunNextFrameReq::RunNextFrameReq(const RunNextFrameReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RunNextFrameReq::SharedCtor() {
  _cached_size_ = 0;
  frame_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunNextFrameReq::~RunNextFrameReq() {
  SharedDtor();
}

void RunNextFrameReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RunNextFrameReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RunNextFrameReq& RunNextFrameReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

RunNextFrameReq* RunNextFrameReq::default_instance_ = NULL;

RunNextFrameReq* RunNextFrameReq::New() const {
  return new RunNextFrameReq;
}

void RunNextFrameReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    frame_ = 0u;
  }
  input_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RunNextFrameReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 frame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_input;
        break;
      }

      // repeated string input = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_input()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_input;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RunNextFrameReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 frame = 1;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->frame(), output);
  }

  // repeated string input = 2;
  for (int i = 0; i < this->input_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->input(i), output);
  }

}

int RunNextFrameReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 frame = 1;
    if (has_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame());
    }

  }
  // repeated string input = 2;
  total_size += 1 * this->input_size();
  for (int i = 0; i < this->input_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->input(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunNextFrameReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RunNextFrameReq*>(&from));
}

void RunNextFrameReq::MergeFrom(const RunNextFrameReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  input_.MergeFrom(from.input_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame()) {
      set_frame(from.frame());
    }
  }
}

void RunNextFrameReq::CopyFrom(const RunNextFrameReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunNextFrameReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RunNextFrameReq::Swap(RunNextFrameReq* other) {
  if (other != this) {
    std::swap(frame_, other->frame_);
    input_.Swap(&other->input_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RunNextFrameReq::GetTypeName() const {
  return "msg.RunNextFrameReq";
}


// ===================================================================

#ifndef _MSC_VER
const int RunNextFrameAck::kFrameFieldNumber;
const int RunNextFrameAck::kInputsFieldNumber;
#endif  // !_MSC_VER

RunNextFrameAck::RunNextFrameAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void RunNextFrameAck::InitAsDefaultInstance() {
}

RunNextFrameAck::RunNextFrameAck(const RunNextFrameAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void RunNextFrameAck::SharedCtor() {
  _cached_size_ = 0;
  frame_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunNextFrameAck::~RunNextFrameAck() {
  SharedDtor();
}

void RunNextFrameAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RunNextFrameAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RunNextFrameAck& RunNextFrameAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

RunNextFrameAck* RunNextFrameAck::default_instance_ = NULL;

RunNextFrameAck* RunNextFrameAck::New() const {
  return new RunNextFrameAck;
}

void RunNextFrameAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    frame_ = 0u;
  }
  inputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool RunNextFrameAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 frame = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &frame_)));
          set_has_frame();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_inputs;
        break;
      }

      // repeated string inputs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_inputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_inputs;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RunNextFrameAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 frame = 1;
  if (has_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->frame(), output);
  }

  // repeated string inputs = 2;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->inputs(i), output);
  }

}

int RunNextFrameAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 frame = 1;
    if (has_frame()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->frame());
    }

  }
  // repeated string inputs = 2;
  total_size += 1 * this->inputs_size();
  for (int i = 0; i < this->inputs_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->inputs(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunNextFrameAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RunNextFrameAck*>(&from));
}

void RunNextFrameAck::MergeFrom(const RunNextFrameAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame()) {
      set_frame(from.frame());
    }
  }
}

void RunNextFrameAck::CopyFrom(const RunNextFrameAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunNextFrameAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RunNextFrameAck::Swap(RunNextFrameAck* other) {
  if (other != this) {
    std::swap(frame_, other->frame_);
    inputs_.Swap(&other->inputs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string RunNextFrameAck::GetTypeName() const {
  return "msg.RunNextFrameAck";
}


// ===================================================================

#ifndef _MSC_VER
const int ExitFightReq::kFightUUIDFieldNumber;
#endif  // !_MSC_VER

ExitFightReq::ExitFightReq()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExitFightReq::InitAsDefaultInstance() {
}

ExitFightReq::ExitFightReq(const ExitFightReq& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExitFightReq::SharedCtor() {
  _cached_size_ = 0;
  fightuuid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitFightReq::~ExitFightReq() {
  SharedDtor();
}

void ExitFightReq::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExitFightReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExitFightReq& ExitFightReq::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

ExitFightReq* ExitFightReq::default_instance_ = NULL;

ExitFightReq* ExitFightReq::New() const {
  return new ExitFightReq;
}

void ExitFightReq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    fightuuid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExitFightReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 fightUUID = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &fightuuid_)));
          set_has_fightuuid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitFightReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 fightUUID = 1;
  if (has_fightuuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->fightuuid(), output);
  }

}

int ExitFightReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 fightUUID = 1;
    if (has_fightuuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->fightuuid());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitFightReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExitFightReq*>(&from));
}

void ExitFightReq::MergeFrom(const ExitFightReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fightuuid()) {
      set_fightuuid(from.fightuuid());
    }
  }
}

void ExitFightReq::CopyFrom(const ExitFightReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitFightReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExitFightReq::Swap(ExitFightReq* other) {
  if (other != this) {
    std::swap(fightuuid_, other->fightuuid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExitFightReq::GetTypeName() const {
  return "msg.ExitFightReq";
}


// ===================================================================

#ifndef _MSC_VER
const int ExitFightAck::kCodeFieldNumber;
#endif  // !_MSC_VER

ExitFightAck::ExitFightAck()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void ExitFightAck::InitAsDefaultInstance() {
}

ExitFightAck::ExitFightAck(const ExitFightAck& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void ExitFightAck::SharedCtor() {
  _cached_size_ = 0;
  code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExitFightAck::~ExitFightAck() {
  SharedDtor();
}

void ExitFightAck::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExitFightAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExitFightAck& ExitFightAck::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_Msg_5fGame_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_Msg_5fGame_2eproto();
#endif
  return *default_instance_;
}

ExitFightAck* ExitFightAck::default_instance_ = NULL;

ExitFightAck* ExitFightAck::New() const {
  return new ExitFightAck;
}

void ExitFightAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool ExitFightAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ExitFightAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

}

int ExitFightAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->code());
    }

  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExitFightAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExitFightAck*>(&from));
}

void ExitFightAck::MergeFrom(const ExitFightAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
  }
}

void ExitFightAck::CopyFrom(const ExitFightAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExitFightAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExitFightAck::Swap(ExitFightAck* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ExitFightAck::GetTypeName() const {
  return "msg.ExitFightAck";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

// @@protoc_insertion_point(global_scope)
