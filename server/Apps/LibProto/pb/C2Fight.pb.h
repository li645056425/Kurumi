// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: C2Fight.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_C2Fight_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_C2Fight_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_C2Fight_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_C2Fight_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace msg {
class ExitFightAck;
class ExitFightAckDefaultTypeInternal;
extern ExitFightAckDefaultTypeInternal _ExitFightAck_default_instance_;
class ExitFightReq;
class ExitFightReqDefaultTypeInternal;
extern ExitFightReqDefaultTypeInternal _ExitFightReq_default_instance_;
class FightWorldInfo;
class FightWorldInfoDefaultTypeInternal;
extern FightWorldInfoDefaultTypeInternal _FightWorldInfo_default_instance_;
class FrameInputData;
class FrameInputDataDefaultTypeInternal;
extern FrameInputDataDefaultTypeInternal _FrameInputData_default_instance_;
class JoinFightAck;
class JoinFightAckDefaultTypeInternal;
extern JoinFightAckDefaultTypeInternal _JoinFightAck_default_instance_;
class JoinFightReq;
class JoinFightReqDefaultTypeInternal;
extern JoinFightReqDefaultTypeInternal _JoinFightReq_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PingInfo;
class PingInfoDefaultTypeInternal;
extern PingInfoDefaultTypeInternal _PingInfo_default_instance_;
class PlayerExitFightNotify;
class PlayerExitFightNotifyDefaultTypeInternal;
extern PlayerExitFightNotifyDefaultTypeInternal _PlayerExitFightNotify_default_instance_;
class PlayerFrameInput;
class PlayerFrameInputDefaultTypeInternal;
extern PlayerFrameInputDefaultTypeInternal _PlayerFrameInput_default_instance_;
class PlayerLoadingAck;
class PlayerLoadingAckDefaultTypeInternal;
extern PlayerLoadingAckDefaultTypeInternal _PlayerLoadingAck_default_instance_;
class PlayerLoadingReq;
class PlayerLoadingReqDefaultTypeInternal;
extern PlayerLoadingReqDefaultTypeInternal _PlayerLoadingReq_default_instance_;
class PlayerReadyNotify;
class PlayerReadyNotifyDefaultTypeInternal;
extern PlayerReadyNotifyDefaultTypeInternal _PlayerReadyNotify_default_instance_;
class PlayerRecords;
class PlayerRecordsDefaultTypeInternal;
extern PlayerRecordsDefaultTypeInternal _PlayerRecords_default_instance_;
class Pong;
class PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class PushFrameInput;
class PushFrameInputDefaultTypeInternal;
extern PushFrameInputDefaultTypeInternal _PushFrameInput_default_instance_;
class PushFrameInputBegin;
class PushFrameInputBeginDefaultTypeInternal;
extern PushFrameInputBeginDefaultTypeInternal _PushFrameInputBegin_default_instance_;
class PushFrameInputEnd;
class PushFrameInputEndDefaultTypeInternal;
extern PushFrameInputEndDefaultTypeInternal _PushFrameInputEnd_default_instance_;
class PushPingInfo;
class PushPingInfoDefaultTypeInternal;
extern PushPingInfoDefaultTypeInternal _PushPingInfo_default_instance_;
class RunNextFrameAck;
class RunNextFrameAckDefaultTypeInternal;
extern RunNextFrameAckDefaultTypeInternal _RunNextFrameAck_default_instance_;
class RunNextFrameReq;
class RunNextFrameReqDefaultTypeInternal;
extern RunNextFrameReqDefaultTypeInternal _RunNextFrameReq_default_instance_;
}  // namespace msg
PROTOBUF_NAMESPACE_OPEN
template<> ::msg::ExitFightAck* Arena::CreateMaybeMessage<::msg::ExitFightAck>(Arena*);
template<> ::msg::ExitFightReq* Arena::CreateMaybeMessage<::msg::ExitFightReq>(Arena*);
template<> ::msg::FightWorldInfo* Arena::CreateMaybeMessage<::msg::FightWorldInfo>(Arena*);
template<> ::msg::FrameInputData* Arena::CreateMaybeMessage<::msg::FrameInputData>(Arena*);
template<> ::msg::JoinFightAck* Arena::CreateMaybeMessage<::msg::JoinFightAck>(Arena*);
template<> ::msg::JoinFightReq* Arena::CreateMaybeMessage<::msg::JoinFightReq>(Arena*);
template<> ::msg::Ping* Arena::CreateMaybeMessage<::msg::Ping>(Arena*);
template<> ::msg::PingInfo* Arena::CreateMaybeMessage<::msg::PingInfo>(Arena*);
template<> ::msg::PlayerExitFightNotify* Arena::CreateMaybeMessage<::msg::PlayerExitFightNotify>(Arena*);
template<> ::msg::PlayerFrameInput* Arena::CreateMaybeMessage<::msg::PlayerFrameInput>(Arena*);
template<> ::msg::PlayerLoadingAck* Arena::CreateMaybeMessage<::msg::PlayerLoadingAck>(Arena*);
template<> ::msg::PlayerLoadingReq* Arena::CreateMaybeMessage<::msg::PlayerLoadingReq>(Arena*);
template<> ::msg::PlayerReadyNotify* Arena::CreateMaybeMessage<::msg::PlayerReadyNotify>(Arena*);
template<> ::msg::PlayerRecords* Arena::CreateMaybeMessage<::msg::PlayerRecords>(Arena*);
template<> ::msg::Pong* Arena::CreateMaybeMessage<::msg::Pong>(Arena*);
template<> ::msg::PushFrameInput* Arena::CreateMaybeMessage<::msg::PushFrameInput>(Arena*);
template<> ::msg::PushFrameInputBegin* Arena::CreateMaybeMessage<::msg::PushFrameInputBegin>(Arena*);
template<> ::msg::PushFrameInputEnd* Arena::CreateMaybeMessage<::msg::PushFrameInputEnd>(Arena*);
template<> ::msg::PushPingInfo* Arena::CreateMaybeMessage<::msg::PushPingInfo>(Arena*);
template<> ::msg::RunNextFrameAck* Arena::CreateMaybeMessage<::msg::RunNextFrameAck>(Arena*);
template<> ::msg::RunNextFrameReq* Arena::CreateMaybeMessage<::msg::RunNextFrameReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace msg {

enum JoinFightReq_MsgId : int {
  JoinFightReq_MsgId_None = 0,
  JoinFightReq_MsgId_Id = 300001,
  JoinFightReq_MsgId_JoinFightReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JoinFightReq_MsgId_JoinFightReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JoinFightReq_MsgId_IsValid(int value);
constexpr JoinFightReq_MsgId JoinFightReq_MsgId_MsgId_MIN = JoinFightReq_MsgId_None;
constexpr JoinFightReq_MsgId JoinFightReq_MsgId_MsgId_MAX = JoinFightReq_MsgId_Id;
constexpr int JoinFightReq_MsgId_MsgId_ARRAYSIZE = JoinFightReq_MsgId_MsgId_MAX + 1;

const std::string& JoinFightReq_MsgId_Name(JoinFightReq_MsgId value);
template<typename T>
inline const std::string& JoinFightReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JoinFightReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JoinFightReq_MsgId_Name.");
  return JoinFightReq_MsgId_Name(static_cast<JoinFightReq_MsgId>(enum_t_value));
}
bool JoinFightReq_MsgId_Parse(
    const std::string& name, JoinFightReq_MsgId* value);
enum JoinFightAck_MsgId : int {
  JoinFightAck_MsgId_None = 0,
  JoinFightAck_MsgId_Id = 300002,
  JoinFightAck_MsgId_JoinFightAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  JoinFightAck_MsgId_JoinFightAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool JoinFightAck_MsgId_IsValid(int value);
constexpr JoinFightAck_MsgId JoinFightAck_MsgId_MsgId_MIN = JoinFightAck_MsgId_None;
constexpr JoinFightAck_MsgId JoinFightAck_MsgId_MsgId_MAX = JoinFightAck_MsgId_Id;
constexpr int JoinFightAck_MsgId_MsgId_ARRAYSIZE = JoinFightAck_MsgId_MsgId_MAX + 1;

const std::string& JoinFightAck_MsgId_Name(JoinFightAck_MsgId value);
template<typename T>
inline const std::string& JoinFightAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, JoinFightAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function JoinFightAck_MsgId_Name.");
  return JoinFightAck_MsgId_Name(static_cast<JoinFightAck_MsgId>(enum_t_value));
}
bool JoinFightAck_MsgId_Parse(
    const std::string& name, JoinFightAck_MsgId* value);
enum PlayerLoadingReq_MsgId : int {
  PlayerLoadingReq_MsgId_None = 0,
  PlayerLoadingReq_MsgId_Id = 300003,
  PlayerLoadingReq_MsgId_PlayerLoadingReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayerLoadingReq_MsgId_PlayerLoadingReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayerLoadingReq_MsgId_IsValid(int value);
constexpr PlayerLoadingReq_MsgId PlayerLoadingReq_MsgId_MsgId_MIN = PlayerLoadingReq_MsgId_None;
constexpr PlayerLoadingReq_MsgId PlayerLoadingReq_MsgId_MsgId_MAX = PlayerLoadingReq_MsgId_Id;
constexpr int PlayerLoadingReq_MsgId_MsgId_ARRAYSIZE = PlayerLoadingReq_MsgId_MsgId_MAX + 1;

const std::string& PlayerLoadingReq_MsgId_Name(PlayerLoadingReq_MsgId value);
template<typename T>
inline const std::string& PlayerLoadingReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerLoadingReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerLoadingReq_MsgId_Name.");
  return PlayerLoadingReq_MsgId_Name(static_cast<PlayerLoadingReq_MsgId>(enum_t_value));
}
bool PlayerLoadingReq_MsgId_Parse(
    const std::string& name, PlayerLoadingReq_MsgId* value);
enum PlayerLoadingAck_MsgId : int {
  PlayerLoadingAck_MsgId_None = 0,
  PlayerLoadingAck_MsgId_Id = 300004,
  PlayerLoadingAck_MsgId_PlayerLoadingAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayerLoadingAck_MsgId_PlayerLoadingAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayerLoadingAck_MsgId_IsValid(int value);
constexpr PlayerLoadingAck_MsgId PlayerLoadingAck_MsgId_MsgId_MIN = PlayerLoadingAck_MsgId_None;
constexpr PlayerLoadingAck_MsgId PlayerLoadingAck_MsgId_MsgId_MAX = PlayerLoadingAck_MsgId_Id;
constexpr int PlayerLoadingAck_MsgId_MsgId_ARRAYSIZE = PlayerLoadingAck_MsgId_MsgId_MAX + 1;

const std::string& PlayerLoadingAck_MsgId_Name(PlayerLoadingAck_MsgId value);
template<typename T>
inline const std::string& PlayerLoadingAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerLoadingAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerLoadingAck_MsgId_Name.");
  return PlayerLoadingAck_MsgId_Name(static_cast<PlayerLoadingAck_MsgId>(enum_t_value));
}
bool PlayerLoadingAck_MsgId_Parse(
    const std::string& name, PlayerLoadingAck_MsgId* value);
enum PlayerReadyNotify_MsgId : int {
  PlayerReadyNotify_MsgId_None = 0,
  PlayerReadyNotify_MsgId_Id = 300006,
  PlayerReadyNotify_MsgId_PlayerReadyNotify_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayerReadyNotify_MsgId_PlayerReadyNotify_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayerReadyNotify_MsgId_IsValid(int value);
constexpr PlayerReadyNotify_MsgId PlayerReadyNotify_MsgId_MsgId_MIN = PlayerReadyNotify_MsgId_None;
constexpr PlayerReadyNotify_MsgId PlayerReadyNotify_MsgId_MsgId_MAX = PlayerReadyNotify_MsgId_Id;
constexpr int PlayerReadyNotify_MsgId_MsgId_ARRAYSIZE = PlayerReadyNotify_MsgId_MsgId_MAX + 1;

const std::string& PlayerReadyNotify_MsgId_Name(PlayerReadyNotify_MsgId value);
template<typename T>
inline const std::string& PlayerReadyNotify_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerReadyNotify_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerReadyNotify_MsgId_Name.");
  return PlayerReadyNotify_MsgId_Name(static_cast<PlayerReadyNotify_MsgId>(enum_t_value));
}
bool PlayerReadyNotify_MsgId_Parse(
    const std::string& name, PlayerReadyNotify_MsgId* value);
enum PlayerExitFightNotify_MsgId : int {
  PlayerExitFightNotify_MsgId_None = 0,
  PlayerExitFightNotify_MsgId_Id = 300008,
  PlayerExitFightNotify_MsgId_PlayerExitFightNotify_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PlayerExitFightNotify_MsgId_PlayerExitFightNotify_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PlayerExitFightNotify_MsgId_IsValid(int value);
constexpr PlayerExitFightNotify_MsgId PlayerExitFightNotify_MsgId_MsgId_MIN = PlayerExitFightNotify_MsgId_None;
constexpr PlayerExitFightNotify_MsgId PlayerExitFightNotify_MsgId_MsgId_MAX = PlayerExitFightNotify_MsgId_Id;
constexpr int PlayerExitFightNotify_MsgId_MsgId_ARRAYSIZE = PlayerExitFightNotify_MsgId_MsgId_MAX + 1;

const std::string& PlayerExitFightNotify_MsgId_Name(PlayerExitFightNotify_MsgId value);
template<typename T>
inline const std::string& PlayerExitFightNotify_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlayerExitFightNotify_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlayerExitFightNotify_MsgId_Name.");
  return PlayerExitFightNotify_MsgId_Name(static_cast<PlayerExitFightNotify_MsgId>(enum_t_value));
}
bool PlayerExitFightNotify_MsgId_Parse(
    const std::string& name, PlayerExitFightNotify_MsgId* value);
enum RunNextFrameReq_MsgId : int {
  RunNextFrameReq_MsgId_None = 0,
  RunNextFrameReq_MsgId_Id = 300009,
  RunNextFrameReq_MsgId_RunNextFrameReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RunNextFrameReq_MsgId_RunNextFrameReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RunNextFrameReq_MsgId_IsValid(int value);
constexpr RunNextFrameReq_MsgId RunNextFrameReq_MsgId_MsgId_MIN = RunNextFrameReq_MsgId_None;
constexpr RunNextFrameReq_MsgId RunNextFrameReq_MsgId_MsgId_MAX = RunNextFrameReq_MsgId_Id;
constexpr int RunNextFrameReq_MsgId_MsgId_ARRAYSIZE = RunNextFrameReq_MsgId_MsgId_MAX + 1;

const std::string& RunNextFrameReq_MsgId_Name(RunNextFrameReq_MsgId value);
template<typename T>
inline const std::string& RunNextFrameReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RunNextFrameReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RunNextFrameReq_MsgId_Name.");
  return RunNextFrameReq_MsgId_Name(static_cast<RunNextFrameReq_MsgId>(enum_t_value));
}
bool RunNextFrameReq_MsgId_Parse(
    const std::string& name, RunNextFrameReq_MsgId* value);
enum RunNextFrameAck_MsgId : int {
  RunNextFrameAck_MsgId_None = 0,
  RunNextFrameAck_MsgId_Id = 300010,
  RunNextFrameAck_MsgId_RunNextFrameAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RunNextFrameAck_MsgId_RunNextFrameAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RunNextFrameAck_MsgId_IsValid(int value);
constexpr RunNextFrameAck_MsgId RunNextFrameAck_MsgId_MsgId_MIN = RunNextFrameAck_MsgId_None;
constexpr RunNextFrameAck_MsgId RunNextFrameAck_MsgId_MsgId_MAX = RunNextFrameAck_MsgId_Id;
constexpr int RunNextFrameAck_MsgId_MsgId_ARRAYSIZE = RunNextFrameAck_MsgId_MsgId_MAX + 1;

const std::string& RunNextFrameAck_MsgId_Name(RunNextFrameAck_MsgId value);
template<typename T>
inline const std::string& RunNextFrameAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RunNextFrameAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RunNextFrameAck_MsgId_Name.");
  return RunNextFrameAck_MsgId_Name(static_cast<RunNextFrameAck_MsgId>(enum_t_value));
}
bool RunNextFrameAck_MsgId_Parse(
    const std::string& name, RunNextFrameAck_MsgId* value);
enum PushFrameInputBegin_MsgId : int {
  PushFrameInputBegin_MsgId_None = 0,
  PushFrameInputBegin_MsgId_Id = 300012,
  PushFrameInputBegin_MsgId_PushFrameInputBegin_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PushFrameInputBegin_MsgId_PushFrameInputBegin_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PushFrameInputBegin_MsgId_IsValid(int value);
constexpr PushFrameInputBegin_MsgId PushFrameInputBegin_MsgId_MsgId_MIN = PushFrameInputBegin_MsgId_None;
constexpr PushFrameInputBegin_MsgId PushFrameInputBegin_MsgId_MsgId_MAX = PushFrameInputBegin_MsgId_Id;
constexpr int PushFrameInputBegin_MsgId_MsgId_ARRAYSIZE = PushFrameInputBegin_MsgId_MsgId_MAX + 1;

const std::string& PushFrameInputBegin_MsgId_Name(PushFrameInputBegin_MsgId value);
template<typename T>
inline const std::string& PushFrameInputBegin_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushFrameInputBegin_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushFrameInputBegin_MsgId_Name.");
  return PushFrameInputBegin_MsgId_Name(static_cast<PushFrameInputBegin_MsgId>(enum_t_value));
}
bool PushFrameInputBegin_MsgId_Parse(
    const std::string& name, PushFrameInputBegin_MsgId* value);
enum PushFrameInputEnd_MsgId : int {
  PushFrameInputEnd_MsgId_None = 0,
  PushFrameInputEnd_MsgId_Id = 300014,
  PushFrameInputEnd_MsgId_PushFrameInputEnd_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PushFrameInputEnd_MsgId_PushFrameInputEnd_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PushFrameInputEnd_MsgId_IsValid(int value);
constexpr PushFrameInputEnd_MsgId PushFrameInputEnd_MsgId_MsgId_MIN = PushFrameInputEnd_MsgId_None;
constexpr PushFrameInputEnd_MsgId PushFrameInputEnd_MsgId_MsgId_MAX = PushFrameInputEnd_MsgId_Id;
constexpr int PushFrameInputEnd_MsgId_MsgId_ARRAYSIZE = PushFrameInputEnd_MsgId_MsgId_MAX + 1;

const std::string& PushFrameInputEnd_MsgId_Name(PushFrameInputEnd_MsgId value);
template<typename T>
inline const std::string& PushFrameInputEnd_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushFrameInputEnd_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushFrameInputEnd_MsgId_Name.");
  return PushFrameInputEnd_MsgId_Name(static_cast<PushFrameInputEnd_MsgId>(enum_t_value));
}
bool PushFrameInputEnd_MsgId_Parse(
    const std::string& name, PushFrameInputEnd_MsgId* value);
enum PushFrameInput_MsgId : int {
  PushFrameInput_MsgId_None = 0,
  PushFrameInput_MsgId_Id = 300016,
  PushFrameInput_MsgId_PushFrameInput_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PushFrameInput_MsgId_PushFrameInput_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PushFrameInput_MsgId_IsValid(int value);
constexpr PushFrameInput_MsgId PushFrameInput_MsgId_MsgId_MIN = PushFrameInput_MsgId_None;
constexpr PushFrameInput_MsgId PushFrameInput_MsgId_MsgId_MAX = PushFrameInput_MsgId_Id;
constexpr int PushFrameInput_MsgId_MsgId_ARRAYSIZE = PushFrameInput_MsgId_MsgId_MAX + 1;

const std::string& PushFrameInput_MsgId_Name(PushFrameInput_MsgId value);
template<typename T>
inline const std::string& PushFrameInput_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushFrameInput_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushFrameInput_MsgId_Name.");
  return PushFrameInput_MsgId_Name(static_cast<PushFrameInput_MsgId>(enum_t_value));
}
bool PushFrameInput_MsgId_Parse(
    const std::string& name, PushFrameInput_MsgId* value);
enum ExitFightReq_MsgId : int {
  ExitFightReq_MsgId_None = 0,
  ExitFightReq_MsgId_Id = 300017,
  ExitFightReq_MsgId_ExitFightReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ExitFightReq_MsgId_ExitFightReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ExitFightReq_MsgId_IsValid(int value);
constexpr ExitFightReq_MsgId ExitFightReq_MsgId_MsgId_MIN = ExitFightReq_MsgId_None;
constexpr ExitFightReq_MsgId ExitFightReq_MsgId_MsgId_MAX = ExitFightReq_MsgId_Id;
constexpr int ExitFightReq_MsgId_MsgId_ARRAYSIZE = ExitFightReq_MsgId_MsgId_MAX + 1;

const std::string& ExitFightReq_MsgId_Name(ExitFightReq_MsgId value);
template<typename T>
inline const std::string& ExitFightReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExitFightReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExitFightReq_MsgId_Name.");
  return ExitFightReq_MsgId_Name(static_cast<ExitFightReq_MsgId>(enum_t_value));
}
bool ExitFightReq_MsgId_Parse(
    const std::string& name, ExitFightReq_MsgId* value);
enum ExitFightAck_MsgId : int {
  ExitFightAck_MsgId_None = 0,
  ExitFightAck_MsgId_Id = 300018,
  ExitFightAck_MsgId_ExitFightAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ExitFightAck_MsgId_ExitFightAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ExitFightAck_MsgId_IsValid(int value);
constexpr ExitFightAck_MsgId ExitFightAck_MsgId_MsgId_MIN = ExitFightAck_MsgId_None;
constexpr ExitFightAck_MsgId ExitFightAck_MsgId_MsgId_MAX = ExitFightAck_MsgId_Id;
constexpr int ExitFightAck_MsgId_MsgId_ARRAYSIZE = ExitFightAck_MsgId_MsgId_MAX + 1;

const std::string& ExitFightAck_MsgId_Name(ExitFightAck_MsgId value);
template<typename T>
inline const std::string& ExitFightAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExitFightAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExitFightAck_MsgId_Name.");
  return ExitFightAck_MsgId_Name(static_cast<ExitFightAck_MsgId>(enum_t_value));
}
bool ExitFightAck_MsgId_Parse(
    const std::string& name, ExitFightAck_MsgId* value);
enum Ping_MsgId : int {
  Ping_MsgId_None = 0,
  Ping_MsgId_Id = 300019,
  Ping_MsgId_Ping_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Ping_MsgId_Ping_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Ping_MsgId_IsValid(int value);
constexpr Ping_MsgId Ping_MsgId_MsgId_MIN = Ping_MsgId_None;
constexpr Ping_MsgId Ping_MsgId_MsgId_MAX = Ping_MsgId_Id;
constexpr int Ping_MsgId_MsgId_ARRAYSIZE = Ping_MsgId_MsgId_MAX + 1;

const std::string& Ping_MsgId_Name(Ping_MsgId value);
template<typename T>
inline const std::string& Ping_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Ping_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Ping_MsgId_Name.");
  return Ping_MsgId_Name(static_cast<Ping_MsgId>(enum_t_value));
}
bool Ping_MsgId_Parse(
    const std::string& name, Ping_MsgId* value);
enum Pong_MsgId : int {
  Pong_MsgId_None = 0,
  Pong_MsgId_Id = 300020,
  Pong_MsgId_Pong_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Pong_MsgId_Pong_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Pong_MsgId_IsValid(int value);
constexpr Pong_MsgId Pong_MsgId_MsgId_MIN = Pong_MsgId_None;
constexpr Pong_MsgId Pong_MsgId_MsgId_MAX = Pong_MsgId_Id;
constexpr int Pong_MsgId_MsgId_ARRAYSIZE = Pong_MsgId_MsgId_MAX + 1;

const std::string& Pong_MsgId_Name(Pong_MsgId value);
template<typename T>
inline const std::string& Pong_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Pong_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Pong_MsgId_Name.");
  return Pong_MsgId_Name(static_cast<Pong_MsgId>(enum_t_value));
}
bool Pong_MsgId_Parse(
    const std::string& name, Pong_MsgId* value);
enum PushPingInfo_MsgId : int {
  PushPingInfo_MsgId_None = 0,
  PushPingInfo_MsgId_Id = 300022,
  PushPingInfo_MsgId_PushPingInfo_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PushPingInfo_MsgId_PushPingInfo_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PushPingInfo_MsgId_IsValid(int value);
constexpr PushPingInfo_MsgId PushPingInfo_MsgId_MsgId_MIN = PushPingInfo_MsgId_None;
constexpr PushPingInfo_MsgId PushPingInfo_MsgId_MsgId_MAX = PushPingInfo_MsgId_Id;
constexpr int PushPingInfo_MsgId_MsgId_ARRAYSIZE = PushPingInfo_MsgId_MsgId_MAX + 1;

const std::string& PushPingInfo_MsgId_Name(PushPingInfo_MsgId value);
template<typename T>
inline const std::string& PushPingInfo_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushPingInfo_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushPingInfo_MsgId_Name.");
  return PushPingInfo_MsgId_Name(static_cast<PushPingInfo_MsgId>(enum_t_value));
}
bool PushPingInfo_MsgId_Parse(
    const std::string& name, PushPingInfo_MsgId* value);
// ===================================================================

class JoinFightReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.JoinFightReq) */ {
 public:
  JoinFightReq();
  virtual ~JoinFightReq();

  JoinFightReq(const JoinFightReq& from);
  JoinFightReq(JoinFightReq&& from) noexcept
    : JoinFightReq() {
    *this = ::std::move(from);
  }

  inline JoinFightReq& operator=(const JoinFightReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinFightReq& operator=(JoinFightReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const JoinFightReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinFightReq* internal_default_instance() {
    return reinterpret_cast<const JoinFightReq*>(
               &_JoinFightReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(JoinFightReq& a, JoinFightReq& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinFightReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinFightReq* New() const final {
    return CreateMaybeMessage<JoinFightReq>(nullptr);
  }

  JoinFightReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinFightReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const JoinFightReq& from);
  void MergeFrom(const JoinFightReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinFightReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.JoinFightReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef JoinFightReq_MsgId MsgId;
  static constexpr MsgId None =
    JoinFightReq_MsgId_None;
  static constexpr MsgId Id =
    JoinFightReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return JoinFightReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    JoinFightReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    JoinFightReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    JoinFightReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return JoinFightReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return JoinFightReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIDFieldNumber = 2,
    kFightUUIDFieldNumber = 1,
    kFrameFieldNumber = 3,
  };
  // int64 playerID = 2;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 fightUUID = 1;
  void clear_fightuuid();
  ::PROTOBUF_NAMESPACE_ID::int32 fightuuid() const;
  void set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fightuuid() const;
  void _internal_set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 frame = 3;
  void clear_frame();
  ::PROTOBUF_NAMESPACE_ID::int32 frame() const;
  void set_frame(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_frame() const;
  void _internal_set_frame(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.JoinFightReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 playerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 fightuuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class FightWorldInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.FightWorldInfo) */ {
 public:
  FightWorldInfo();
  virtual ~FightWorldInfo();

  FightWorldInfo(const FightWorldInfo& from);
  FightWorldInfo(FightWorldInfo&& from) noexcept
    : FightWorldInfo() {
    *this = ::std::move(from);
  }

  inline FightWorldInfo& operator=(const FightWorldInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FightWorldInfo& operator=(FightWorldInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FightWorldInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FightWorldInfo* internal_default_instance() {
    return reinterpret_cast<const FightWorldInfo*>(
               &_FightWorldInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FightWorldInfo& a, FightWorldInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FightWorldInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FightWorldInfo* New() const final {
    return CreateMaybeMessage<FightWorldInfo>(nullptr);
  }

  FightWorldInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FightWorldInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FightWorldInfo& from);
  void MergeFrom(const FightWorldInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FightWorldInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.FightWorldInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 7,
    kFrameFieldNumber = 1,
    kSvrStatusFieldNumber = 2,
    kMapIdFieldNumber = 3,
    kRandomSeedFieldNumber = 4,
    kUuidSeedFieldNumber = 5,
    kIsOfflineModeFieldNumber = 6,
  };
  // repeated int64 roles = 7;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_roles() const;
  void _internal_add_roles(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_roles();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 roles(int index) const;
  void set_roles(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_roles(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      roles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_roles();

  // int32 frame = 1;
  void clear_frame();
  ::PROTOBUF_NAMESPACE_ID::int32 frame() const;
  void set_frame(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_frame() const;
  void _internal_set_frame(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 svr_status = 2;
  void clear_svr_status();
  ::PROTOBUF_NAMESPACE_ID::int32 svr_status() const;
  void set_svr_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_svr_status() const;
  void _internal_set_svr_status(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 mapId = 3;
  void clear_mapid();
  ::PROTOBUF_NAMESPACE_ID::int32 mapid() const;
  void set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mapid() const;
  void _internal_set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 randomSeed = 4;
  void clear_randomseed();
  ::PROTOBUF_NAMESPACE_ID::uint32 randomseed() const;
  void set_randomseed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_randomseed() const;
  void _internal_set_randomseed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 uuidSeed = 5;
  void clear_uuidseed();
  ::PROTOBUF_NAMESPACE_ID::uint32 uuidseed() const;
  void set_uuidseed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_uuidseed() const;
  void _internal_set_uuidseed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool isOfflineMode = 6;
  void clear_isofflinemode();
  bool isofflinemode() const;
  void set_isofflinemode(bool value);
  private:
  bool _internal_isofflinemode() const;
  void _internal_set_isofflinemode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.FightWorldInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > roles_;
  mutable std::atomic<int> _roles_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 frame_;
  ::PROTOBUF_NAMESPACE_ID::int32 svr_status_;
  ::PROTOBUF_NAMESPACE_ID::int32 mapid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 randomseed_;
  ::PROTOBUF_NAMESPACE_ID::uint32 uuidseed_;
  bool isofflinemode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class JoinFightAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.JoinFightAck) */ {
 public:
  JoinFightAck();
  virtual ~JoinFightAck();

  JoinFightAck(const JoinFightAck& from);
  JoinFightAck(JoinFightAck&& from) noexcept
    : JoinFightAck() {
    *this = ::std::move(from);
  }

  inline JoinFightAck& operator=(const JoinFightAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinFightAck& operator=(JoinFightAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const JoinFightAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinFightAck* internal_default_instance() {
    return reinterpret_cast<const JoinFightAck*>(
               &_JoinFightAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(JoinFightAck& a, JoinFightAck& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinFightAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JoinFightAck* New() const final {
    return CreateMaybeMessage<JoinFightAck>(nullptr);
  }

  JoinFightAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JoinFightAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const JoinFightAck& from);
  void MergeFrom(const JoinFightAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinFightAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.JoinFightAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef JoinFightAck_MsgId MsgId;
  static constexpr MsgId None =
    JoinFightAck_MsgId_None;
  static constexpr MsgId Id =
    JoinFightAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return JoinFightAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    JoinFightAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    JoinFightAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    JoinFightAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return JoinFightAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return JoinFightAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWorldInfoFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // .msg.FightWorldInfo worldInfo = 2;
  bool has_worldinfo() const;
  private:
  bool _internal_has_worldinfo() const;
  public:
  void clear_worldinfo();
  const ::msg::FightWorldInfo& worldinfo() const;
  ::msg::FightWorldInfo* release_worldinfo();
  ::msg::FightWorldInfo* mutable_worldinfo();
  void set_allocated_worldinfo(::msg::FightWorldInfo* worldinfo);
  private:
  const ::msg::FightWorldInfo& _internal_worldinfo() const;
  ::msg::FightWorldInfo* _internal_mutable_worldinfo();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.JoinFightAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::msg::FightWorldInfo* worldinfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PlayerLoadingReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PlayerLoadingReq) */ {
 public:
  PlayerLoadingReq();
  virtual ~PlayerLoadingReq();

  PlayerLoadingReq(const PlayerLoadingReq& from);
  PlayerLoadingReq(PlayerLoadingReq&& from) noexcept
    : PlayerLoadingReq() {
    *this = ::std::move(from);
  }

  inline PlayerLoadingReq& operator=(const PlayerLoadingReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLoadingReq& operator=(PlayerLoadingReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PlayerLoadingReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLoadingReq* internal_default_instance() {
    return reinterpret_cast<const PlayerLoadingReq*>(
               &_PlayerLoadingReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlayerLoadingReq& a, PlayerLoadingReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerLoadingReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerLoadingReq* New() const final {
    return CreateMaybeMessage<PlayerLoadingReq>(nullptr);
  }

  PlayerLoadingReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerLoadingReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PlayerLoadingReq& from);
  void MergeFrom(const PlayerLoadingReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerLoadingReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerLoadingReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerLoadingReq_MsgId MsgId;
  static constexpr MsgId None =
    PlayerLoadingReq_MsgId_None;
  static constexpr MsgId Id =
    PlayerLoadingReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PlayerLoadingReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PlayerLoadingReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PlayerLoadingReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PlayerLoadingReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PlayerLoadingReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PlayerLoadingReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPercentFieldNumber = 1,
    kFinishFieldNumber = 2,
  };
  // float percent = 1;
  void clear_percent();
  float percent() const;
  void set_percent(float value);
  private:
  float _internal_percent() const;
  void _internal_set_percent(float value);
  public:

  // bool finish = 2;
  void clear_finish();
  bool finish() const;
  void set_finish(bool value);
  private:
  bool _internal_finish() const;
  void _internal_set_finish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PlayerLoadingReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  float percent_;
  bool finish_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PlayerLoadingAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PlayerLoadingAck) */ {
 public:
  PlayerLoadingAck();
  virtual ~PlayerLoadingAck();

  PlayerLoadingAck(const PlayerLoadingAck& from);
  PlayerLoadingAck(PlayerLoadingAck&& from) noexcept
    : PlayerLoadingAck() {
    *this = ::std::move(from);
  }

  inline PlayerLoadingAck& operator=(const PlayerLoadingAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLoadingAck& operator=(PlayerLoadingAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PlayerLoadingAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLoadingAck* internal_default_instance() {
    return reinterpret_cast<const PlayerLoadingAck*>(
               &_PlayerLoadingAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerLoadingAck& a, PlayerLoadingAck& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerLoadingAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerLoadingAck* New() const final {
    return CreateMaybeMessage<PlayerLoadingAck>(nullptr);
  }

  PlayerLoadingAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerLoadingAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PlayerLoadingAck& from);
  void MergeFrom(const PlayerLoadingAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerLoadingAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerLoadingAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerLoadingAck_MsgId MsgId;
  static constexpr MsgId None =
    PlayerLoadingAck_MsgId_None;
  static constexpr MsgId Id =
    PlayerLoadingAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PlayerLoadingAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PlayerLoadingAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PlayerLoadingAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PlayerLoadingAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PlayerLoadingAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PlayerLoadingAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kPercentFieldNumber = 2,
    kFinishFieldNumber = 3,
  };
  // repeated int64 pid = 1;
  int pid_size() const;
  private:
  int _internal_pid_size() const;
  public:
  void clear_pid();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_pid() const;
  void _internal_add_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_pid();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 pid(int index) const;
  void set_pid(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      pid() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_pid();

  // repeated float percent = 2;
  int percent_size() const;
  private:
  int _internal_percent_size() const;
  public:
  void clear_percent();
  private:
  float _internal_percent(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_percent() const;
  void _internal_add_percent(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_percent();
  public:
  float percent(int index) const;
  void set_percent(int index, float value);
  void add_percent(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      percent() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_percent();

  // bool finish = 3;
  void clear_finish();
  bool finish() const;
  void set_finish(bool value);
  private:
  bool _internal_finish() const;
  void _internal_set_finish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PlayerLoadingAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > pid_;
  mutable std::atomic<int> _pid_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > percent_;
  mutable std::atomic<int> _percent_cached_byte_size_;
  bool finish_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PlayerReadyNotify :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PlayerReadyNotify) */ {
 public:
  PlayerReadyNotify();
  virtual ~PlayerReadyNotify();

  PlayerReadyNotify(const PlayerReadyNotify& from);
  PlayerReadyNotify(PlayerReadyNotify&& from) noexcept
    : PlayerReadyNotify() {
    *this = ::std::move(from);
  }

  inline PlayerReadyNotify& operator=(const PlayerReadyNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReadyNotify& operator=(PlayerReadyNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PlayerReadyNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerReadyNotify* internal_default_instance() {
    return reinterpret_cast<const PlayerReadyNotify*>(
               &_PlayerReadyNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerReadyNotify& a, PlayerReadyNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReadyNotify* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerReadyNotify* New() const final {
    return CreateMaybeMessage<PlayerReadyNotify>(nullptr);
  }

  PlayerReadyNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerReadyNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PlayerReadyNotify& from);
  void MergeFrom(const PlayerReadyNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerReadyNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerReadyNotify";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerReadyNotify_MsgId MsgId;
  static constexpr MsgId None =
    PlayerReadyNotify_MsgId_None;
  static constexpr MsgId Id =
    PlayerReadyNotify_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PlayerReadyNotify_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PlayerReadyNotify_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PlayerReadyNotify_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PlayerReadyNotify_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PlayerReadyNotify_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PlayerReadyNotify_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // int64 pid = 1;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PlayerReadyNotify)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PlayerExitFightNotify :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PlayerExitFightNotify) */ {
 public:
  PlayerExitFightNotify();
  virtual ~PlayerExitFightNotify();

  PlayerExitFightNotify(const PlayerExitFightNotify& from);
  PlayerExitFightNotify(PlayerExitFightNotify&& from) noexcept
    : PlayerExitFightNotify() {
    *this = ::std::move(from);
  }

  inline PlayerExitFightNotify& operator=(const PlayerExitFightNotify& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerExitFightNotify& operator=(PlayerExitFightNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PlayerExitFightNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerExitFightNotify* internal_default_instance() {
    return reinterpret_cast<const PlayerExitFightNotify*>(
               &_PlayerExitFightNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PlayerExitFightNotify& a, PlayerExitFightNotify& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerExitFightNotify* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerExitFightNotify* New() const final {
    return CreateMaybeMessage<PlayerExitFightNotify>(nullptr);
  }

  PlayerExitFightNotify* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerExitFightNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PlayerExitFightNotify& from);
  void MergeFrom(const PlayerExitFightNotify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerExitFightNotify* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerExitFightNotify";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PlayerExitFightNotify_MsgId MsgId;
  static constexpr MsgId None =
    PlayerExitFightNotify_MsgId_None;
  static constexpr MsgId Id =
    PlayerExitFightNotify_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PlayerExitFightNotify_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PlayerExitFightNotify_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PlayerExitFightNotify_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PlayerExitFightNotify_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PlayerExitFightNotify_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PlayerExitFightNotify_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
  };
  // int64 pid = 1;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PlayerExitFightNotify)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class FrameInputData :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.FrameInputData) */ {
 public:
  FrameInputData();
  virtual ~FrameInputData();

  FrameInputData(const FrameInputData& from);
  FrameInputData(FrameInputData&& from) noexcept
    : FrameInputData() {
    *this = ::std::move(from);
  }

  inline FrameInputData& operator=(const FrameInputData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameInputData& operator=(FrameInputData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FrameInputData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FrameInputData* internal_default_instance() {
    return reinterpret_cast<const FrameInputData*>(
               &_FrameInputData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FrameInputData& a, FrameInputData& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameInputData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FrameInputData* New() const final {
    return CreateMaybeMessage<FrameInputData>(nullptr);
  }

  FrameInputData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FrameInputData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FrameInputData& from);
  void MergeFrom(const FrameInputData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FrameInputData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.FrameInputData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyDownFieldNumber = 1,
  };
  // uint32 key_down = 1;
  void clear_key_down();
  ::PROTOBUF_NAMESPACE_ID::uint32 key_down() const;
  void set_key_down(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key_down() const;
  void _internal_set_key_down(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.FrameInputData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_down_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PlayerFrameInput :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PlayerFrameInput) */ {
 public:
  PlayerFrameInput();
  virtual ~PlayerFrameInput();

  PlayerFrameInput(const PlayerFrameInput& from);
  PlayerFrameInput(PlayerFrameInput&& from) noexcept
    : PlayerFrameInput() {
    *this = ::std::move(from);
  }

  inline PlayerFrameInput& operator=(const PlayerFrameInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerFrameInput& operator=(PlayerFrameInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PlayerFrameInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerFrameInput* internal_default_instance() {
    return reinterpret_cast<const PlayerFrameInput*>(
               &_PlayerFrameInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerFrameInput& a, PlayerFrameInput& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerFrameInput* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerFrameInput* New() const final {
    return CreateMaybeMessage<PlayerFrameInput>(nullptr);
  }

  PlayerFrameInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerFrameInput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PlayerFrameInput& from);
  void MergeFrom(const PlayerFrameInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerFrameInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerFrameInput";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 3,
    kPidFieldNumber = 1,
    kFrameFieldNumber = 2,
  };
  // .msg.FrameInputData input = 3;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::msg::FrameInputData& input() const;
  ::msg::FrameInputData* release_input();
  ::msg::FrameInputData* mutable_input();
  void set_allocated_input(::msg::FrameInputData* input);
  private:
  const ::msg::FrameInputData& _internal_input() const;
  ::msg::FrameInputData* _internal_mutable_input();
  public:

  // int64 pid = 1;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint32 frame = 2;
  void clear_frame();
  ::PROTOBUF_NAMESPACE_ID::uint32 frame() const;
  void set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_frame() const;
  void _internal_set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PlayerFrameInput)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::msg::FrameInputData* input_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class RunNextFrameReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.RunNextFrameReq) */ {
 public:
  RunNextFrameReq();
  virtual ~RunNextFrameReq();

  RunNextFrameReq(const RunNextFrameReq& from);
  RunNextFrameReq(RunNextFrameReq&& from) noexcept
    : RunNextFrameReq() {
    *this = ::std::move(from);
  }

  inline RunNextFrameReq& operator=(const RunNextFrameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunNextFrameReq& operator=(RunNextFrameReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RunNextFrameReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunNextFrameReq* internal_default_instance() {
    return reinterpret_cast<const RunNextFrameReq*>(
               &_RunNextFrameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RunNextFrameReq& a, RunNextFrameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(RunNextFrameReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunNextFrameReq* New() const final {
    return CreateMaybeMessage<RunNextFrameReq>(nullptr);
  }

  RunNextFrameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunNextFrameReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RunNextFrameReq& from);
  void MergeFrom(const RunNextFrameReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunNextFrameReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RunNextFrameReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RunNextFrameReq_MsgId MsgId;
  static constexpr MsgId None =
    RunNextFrameReq_MsgId_None;
  static constexpr MsgId Id =
    RunNextFrameReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return RunNextFrameReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    RunNextFrameReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    RunNextFrameReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    RunNextFrameReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return RunNextFrameReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return RunNextFrameReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 2,
    kFrameFieldNumber = 1,
  };
  // .msg.FrameInputData input = 2;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::msg::FrameInputData& input() const;
  ::msg::FrameInputData* release_input();
  ::msg::FrameInputData* mutable_input();
  void set_allocated_input(::msg::FrameInputData* input);
  private:
  const ::msg::FrameInputData& _internal_input() const;
  ::msg::FrameInputData* _internal_mutable_input();
  public:

  // uint32 frame = 1;
  void clear_frame();
  ::PROTOBUF_NAMESPACE_ID::uint32 frame() const;
  void set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_frame() const;
  void _internal_set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.RunNextFrameReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::msg::FrameInputData* input_;
  ::PROTOBUF_NAMESPACE_ID::uint32 frame_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class RunNextFrameAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.RunNextFrameAck) */ {
 public:
  RunNextFrameAck();
  virtual ~RunNextFrameAck();

  RunNextFrameAck(const RunNextFrameAck& from);
  RunNextFrameAck(RunNextFrameAck&& from) noexcept
    : RunNextFrameAck() {
    *this = ::std::move(from);
  }

  inline RunNextFrameAck& operator=(const RunNextFrameAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunNextFrameAck& operator=(RunNextFrameAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RunNextFrameAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunNextFrameAck* internal_default_instance() {
    return reinterpret_cast<const RunNextFrameAck*>(
               &_RunNextFrameAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RunNextFrameAck& a, RunNextFrameAck& b) {
    a.Swap(&b);
  }
  inline void Swap(RunNextFrameAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunNextFrameAck* New() const final {
    return CreateMaybeMessage<RunNextFrameAck>(nullptr);
  }

  RunNextFrameAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunNextFrameAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RunNextFrameAck& from);
  void MergeFrom(const RunNextFrameAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunNextFrameAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RunNextFrameAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RunNextFrameAck_MsgId MsgId;
  static constexpr MsgId None =
    RunNextFrameAck_MsgId_None;
  static constexpr MsgId Id =
    RunNextFrameAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return RunNextFrameAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    RunNextFrameAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    RunNextFrameAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    RunNextFrameAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return RunNextFrameAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return RunNextFrameAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 2,
    kNextFrameFieldNumber = 1,
  };
  // repeated .msg.PlayerFrameInput frames = 2;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::msg::PlayerFrameInput* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >*
      mutable_frames();
  private:
  const ::msg::PlayerFrameInput& _internal_frames(int index) const;
  ::msg::PlayerFrameInput* _internal_add_frames();
  public:
  const ::msg::PlayerFrameInput& frames(int index) const;
  ::msg::PlayerFrameInput* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >&
      frames() const;

  // uint32 nextFrame = 1;
  void clear_nextframe();
  ::PROTOBUF_NAMESPACE_ID::uint32 nextframe() const;
  void set_nextframe(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_nextframe() const;
  void _internal_set_nextframe(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.RunNextFrameAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput > frames_;
  ::PROTOBUF_NAMESPACE_ID::uint32 nextframe_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PushFrameInputBegin :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PushFrameInputBegin) */ {
 public:
  PushFrameInputBegin();
  virtual ~PushFrameInputBegin();

  PushFrameInputBegin(const PushFrameInputBegin& from);
  PushFrameInputBegin(PushFrameInputBegin&& from) noexcept
    : PushFrameInputBegin() {
    *this = ::std::move(from);
  }

  inline PushFrameInputBegin& operator=(const PushFrameInputBegin& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushFrameInputBegin& operator=(PushFrameInputBegin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PushFrameInputBegin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushFrameInputBegin* internal_default_instance() {
    return reinterpret_cast<const PushFrameInputBegin*>(
               &_PushFrameInputBegin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PushFrameInputBegin& a, PushFrameInputBegin& b) {
    a.Swap(&b);
  }
  inline void Swap(PushFrameInputBegin* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushFrameInputBegin* New() const final {
    return CreateMaybeMessage<PushFrameInputBegin>(nullptr);
  }

  PushFrameInputBegin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushFrameInputBegin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PushFrameInputBegin& from);
  void MergeFrom(const PushFrameInputBegin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushFrameInputBegin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushFrameInputBegin";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PushFrameInputBegin_MsgId MsgId;
  static constexpr MsgId None =
    PushFrameInputBegin_MsgId_None;
  static constexpr MsgId Id =
    PushFrameInputBegin_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PushFrameInputBegin_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PushFrameInputBegin_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PushFrameInputBegin_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PushFrameInputBegin_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PushFrameInputBegin_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PushFrameInputBegin_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlaceholderFieldNumber = 1,
  };
  // int32 placeholder = 1;
  void clear_placeholder();
  ::PROTOBUF_NAMESPACE_ID::int32 placeholder() const;
  void set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_placeholder() const;
  void _internal_set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PushFrameInputBegin)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 placeholder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PushFrameInputEnd :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PushFrameInputEnd) */ {
 public:
  PushFrameInputEnd();
  virtual ~PushFrameInputEnd();

  PushFrameInputEnd(const PushFrameInputEnd& from);
  PushFrameInputEnd(PushFrameInputEnd&& from) noexcept
    : PushFrameInputEnd() {
    *this = ::std::move(from);
  }

  inline PushFrameInputEnd& operator=(const PushFrameInputEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushFrameInputEnd& operator=(PushFrameInputEnd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PushFrameInputEnd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushFrameInputEnd* internal_default_instance() {
    return reinterpret_cast<const PushFrameInputEnd*>(
               &_PushFrameInputEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PushFrameInputEnd& a, PushFrameInputEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(PushFrameInputEnd* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushFrameInputEnd* New() const final {
    return CreateMaybeMessage<PushFrameInputEnd>(nullptr);
  }

  PushFrameInputEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushFrameInputEnd>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PushFrameInputEnd& from);
  void MergeFrom(const PushFrameInputEnd& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushFrameInputEnd* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushFrameInputEnd";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PushFrameInputEnd_MsgId MsgId;
  static constexpr MsgId None =
    PushFrameInputEnd_MsgId_None;
  static constexpr MsgId Id =
    PushFrameInputEnd_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PushFrameInputEnd_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PushFrameInputEnd_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PushFrameInputEnd_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PushFrameInputEnd_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PushFrameInputEnd_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PushFrameInputEnd_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPlaceholderFieldNumber = 1,
  };
  // int32 placeholder = 1;
  void clear_placeholder();
  ::PROTOBUF_NAMESPACE_ID::int32 placeholder() const;
  void set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_placeholder() const;
  void _internal_set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PushFrameInputEnd)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 placeholder_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PushFrameInput :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PushFrameInput) */ {
 public:
  PushFrameInput();
  virtual ~PushFrameInput();

  PushFrameInput(const PushFrameInput& from);
  PushFrameInput(PushFrameInput&& from) noexcept
    : PushFrameInput() {
    *this = ::std::move(from);
  }

  inline PushFrameInput& operator=(const PushFrameInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushFrameInput& operator=(PushFrameInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PushFrameInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushFrameInput* internal_default_instance() {
    return reinterpret_cast<const PushFrameInput*>(
               &_PushFrameInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PushFrameInput& a, PushFrameInput& b) {
    a.Swap(&b);
  }
  inline void Swap(PushFrameInput* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushFrameInput* New() const final {
    return CreateMaybeMessage<PushFrameInput>(nullptr);
  }

  PushFrameInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushFrameInput>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PushFrameInput& from);
  void MergeFrom(const PushFrameInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushFrameInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushFrameInput";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PushFrameInput_MsgId MsgId;
  static constexpr MsgId None =
    PushFrameInput_MsgId_None;
  static constexpr MsgId Id =
    PushFrameInput_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PushFrameInput_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PushFrameInput_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PushFrameInput_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PushFrameInput_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PushFrameInput_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PushFrameInput_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 2,
    kLastFrameFieldNumber = 1,
  };
  // repeated .msg.PlayerFrameInput frames = 2;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::msg::PlayerFrameInput* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >*
      mutable_frames();
  private:
  const ::msg::PlayerFrameInput& _internal_frames(int index) const;
  ::msg::PlayerFrameInput* _internal_add_frames();
  public:
  const ::msg::PlayerFrameInput& frames(int index) const;
  ::msg::PlayerFrameInput* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >&
      frames() const;

  // uint32 lastFrame = 1;
  void clear_lastframe();
  ::PROTOBUF_NAMESPACE_ID::uint32 lastframe() const;
  void set_lastframe(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lastframe() const;
  void _internal_set_lastframe(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PushFrameInput)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput > frames_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lastframe_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PlayerRecords :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PlayerRecords) */ {
 public:
  PlayerRecords();
  virtual ~PlayerRecords();

  PlayerRecords(const PlayerRecords& from);
  PlayerRecords(PlayerRecords&& from) noexcept
    : PlayerRecords() {
    *this = ::std::move(from);
  }

  inline PlayerRecords& operator=(const PlayerRecords& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerRecords& operator=(PlayerRecords&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PlayerRecords& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerRecords* internal_default_instance() {
    return reinterpret_cast<const PlayerRecords*>(
               &_PlayerRecords_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PlayerRecords& a, PlayerRecords& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerRecords* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerRecords* New() const final {
    return CreateMaybeMessage<PlayerRecords>(nullptr);
  }

  PlayerRecords* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerRecords>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PlayerRecords& from);
  void MergeFrom(const PlayerRecords& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerRecords* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerRecords";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 1,
  };
  // repeated .msg.PlayerFrameInput frames = 1;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::msg::PlayerFrameInput* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >*
      mutable_frames();
  private:
  const ::msg::PlayerFrameInput& _internal_frames(int index) const;
  ::msg::PlayerFrameInput* _internal_add_frames();
  public:
  const ::msg::PlayerFrameInput& frames(int index) const;
  ::msg::PlayerFrameInput* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >&
      frames() const;

  // @@protoc_insertion_point(class_scope:msg.PlayerRecords)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput > frames_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class ExitFightReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.ExitFightReq) */ {
 public:
  ExitFightReq();
  virtual ~ExitFightReq();

  ExitFightReq(const ExitFightReq& from);
  ExitFightReq(ExitFightReq&& from) noexcept
    : ExitFightReq() {
    *this = ::std::move(from);
  }

  inline ExitFightReq& operator=(const ExitFightReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitFightReq& operator=(ExitFightReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ExitFightReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExitFightReq* internal_default_instance() {
    return reinterpret_cast<const ExitFightReq*>(
               &_ExitFightReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ExitFightReq& a, ExitFightReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitFightReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExitFightReq* New() const final {
    return CreateMaybeMessage<ExitFightReq>(nullptr);
  }

  ExitFightReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExitFightReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ExitFightReq& from);
  void MergeFrom(const ExitFightReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExitFightReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ExitFightReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExitFightReq_MsgId MsgId;
  static constexpr MsgId None =
    ExitFightReq_MsgId_None;
  static constexpr MsgId Id =
    ExitFightReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return ExitFightReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    ExitFightReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    ExitFightReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    ExitFightReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return ExitFightReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return ExitFightReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFightUUIDFieldNumber = 1,
  };
  // int32 fightUUID = 1;
  void clear_fightuuid();
  ::PROTOBUF_NAMESPACE_ID::int32 fightuuid() const;
  void set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fightuuid() const;
  void _internal_set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ExitFightReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 fightuuid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class ExitFightAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.ExitFightAck) */ {
 public:
  ExitFightAck();
  virtual ~ExitFightAck();

  ExitFightAck(const ExitFightAck& from);
  ExitFightAck(ExitFightAck&& from) noexcept
    : ExitFightAck() {
    *this = ::std::move(from);
  }

  inline ExitFightAck& operator=(const ExitFightAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitFightAck& operator=(ExitFightAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ExitFightAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExitFightAck* internal_default_instance() {
    return reinterpret_cast<const ExitFightAck*>(
               &_ExitFightAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ExitFightAck& a, ExitFightAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitFightAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExitFightAck* New() const final {
    return CreateMaybeMessage<ExitFightAck>(nullptr);
  }

  ExitFightAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExitFightAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ExitFightAck& from);
  void MergeFrom(const ExitFightAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExitFightAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ExitFightAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExitFightAck_MsgId MsgId;
  static constexpr MsgId None =
    ExitFightAck_MsgId_None;
  static constexpr MsgId Id =
    ExitFightAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return ExitFightAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    ExitFightAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    ExitFightAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    ExitFightAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return ExitFightAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return ExitFightAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ExitFightAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class Ping :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Ping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ping* New() const final {
    return CreateMaybeMessage<Ping>(nullptr);
  }

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ping* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.Ping";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Ping_MsgId MsgId;
  static constexpr MsgId None =
    Ping_MsgId_None;
  static constexpr MsgId Id =
    Ping_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return Ping_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    Ping_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    Ping_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    Ping_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return Ping_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return Ping_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
    kPingFieldNumber = 2,
  };
  // uint32 timestamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // int32 ping = 2;
  void clear_ping();
  ::PROTOBUF_NAMESPACE_ID::int32 ping() const;
  void set_ping(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ping() const;
  void _internal_set_ping(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.Ping)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  ::PROTOBUF_NAMESPACE_ID::int32 ping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class Pong :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.Pong) */ {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Pong& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pong* New() const final {
    return CreateMaybeMessage<Pong>(nullptr);
  }

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pong* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.Pong";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Pong_MsgId MsgId;
  static constexpr MsgId None =
    Pong_MsgId_None;
  static constexpr MsgId Id =
    Pong_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return Pong_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    Pong_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    Pong_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    Pong_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return Pong_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return Pong_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 1,
  };
  // uint32 timestamp = 1;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.Pong)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PingInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PingInfo) */ {
 public:
  PingInfo();
  virtual ~PingInfo();

  PingInfo(const PingInfo& from);
  PingInfo(PingInfo&& from) noexcept
    : PingInfo() {
    *this = ::std::move(from);
  }

  inline PingInfo& operator=(const PingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingInfo& operator=(PingInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PingInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingInfo* internal_default_instance() {
    return reinterpret_cast<const PingInfo*>(
               &_PingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PingInfo& a, PingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PingInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingInfo* New() const final {
    return CreateMaybeMessage<PingInfo>(nullptr);
  }

  PingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PingInfo& from);
  void MergeFrom(const PingInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PingInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PingInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPidFieldNumber = 1,
    kPingFieldNumber = 2,
  };
  // int64 pid = 1;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 ping = 2;
  void clear_ping();
  ::PROTOBUF_NAMESPACE_ID::int32 ping() const;
  void set_ping(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ping() const;
  void _internal_set_ping(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PingInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 ping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// -------------------------------------------------------------------

class PushPingInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PushPingInfo) */ {
 public:
  PushPingInfo();
  virtual ~PushPingInfo();

  PushPingInfo(const PushPingInfo& from);
  PushPingInfo(PushPingInfo&& from) noexcept
    : PushPingInfo() {
    *this = ::std::move(from);
  }

  inline PushPingInfo& operator=(const PushPingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushPingInfo& operator=(PushPingInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PushPingInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushPingInfo* internal_default_instance() {
    return reinterpret_cast<const PushPingInfo*>(
               &_PushPingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PushPingInfo& a, PushPingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PushPingInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushPingInfo* New() const final {
    return CreateMaybeMessage<PushPingInfo>(nullptr);
  }

  PushPingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushPingInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PushPingInfo& from);
  void MergeFrom(const PushPingInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushPingInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushPingInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PushPingInfo_MsgId MsgId;
  static constexpr MsgId None =
    PushPingInfo_MsgId_None;
  static constexpr MsgId Id =
    PushPingInfo_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PushPingInfo_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PushPingInfo_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PushPingInfo_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PushPingInfo_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PushPingInfo_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PushPingInfo_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 1,
  };
  // repeated .msg.PingInfo infos = 1;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  ::msg::PingInfo* mutable_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PingInfo >*
      mutable_infos();
  private:
  const ::msg::PingInfo& _internal_infos(int index) const;
  ::msg::PingInfo* _internal_add_infos();
  public:
  const ::msg::PingInfo& infos(int index) const;
  ::msg::PingInfo* add_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PingInfo >&
      infos() const;

  // @@protoc_insertion_point(class_scope:msg.PushPingInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PingInfo > infos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Fight_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JoinFightReq

// int32 fightUUID = 1;
inline void JoinFightReq::clear_fightuuid() {
  fightuuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinFightReq::_internal_fightuuid() const {
  return fightuuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinFightReq::fightuuid() const {
  // @@protoc_insertion_point(field_get:msg.JoinFightReq.fightUUID)
  return _internal_fightuuid();
}
inline void JoinFightReq::_internal_set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fightuuid_ = value;
}
inline void JoinFightReq::set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fightuuid(value);
  // @@protoc_insertion_point(field_set:msg.JoinFightReq.fightUUID)
}

// int64 playerID = 2;
inline void JoinFightReq::clear_playerid() {
  playerid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JoinFightReq::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 JoinFightReq::playerid() const {
  // @@protoc_insertion_point(field_get:msg.JoinFightReq.playerID)
  return _internal_playerid();
}
inline void JoinFightReq::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  playerid_ = value;
}
inline void JoinFightReq::set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:msg.JoinFightReq.playerID)
}

// int32 frame = 3;
inline void JoinFightReq::clear_frame() {
  frame_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinFightReq::_internal_frame() const {
  return frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinFightReq::frame() const {
  // @@protoc_insertion_point(field_get:msg.JoinFightReq.frame)
  return _internal_frame();
}
inline void JoinFightReq::_internal_set_frame(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  frame_ = value;
}
inline void JoinFightReq::set_frame(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:msg.JoinFightReq.frame)
}

// -------------------------------------------------------------------

// FightWorldInfo

// int32 frame = 1;
inline void FightWorldInfo::clear_frame() {
  frame_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightWorldInfo::_internal_frame() const {
  return frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightWorldInfo::frame() const {
  // @@protoc_insertion_point(field_get:msg.FightWorldInfo.frame)
  return _internal_frame();
}
inline void FightWorldInfo::_internal_set_frame(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  frame_ = value;
}
inline void FightWorldInfo::set_frame(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:msg.FightWorldInfo.frame)
}

// int32 svr_status = 2;
inline void FightWorldInfo::clear_svr_status() {
  svr_status_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightWorldInfo::_internal_svr_status() const {
  return svr_status_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightWorldInfo::svr_status() const {
  // @@protoc_insertion_point(field_get:msg.FightWorldInfo.svr_status)
  return _internal_svr_status();
}
inline void FightWorldInfo::_internal_set_svr_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  svr_status_ = value;
}
inline void FightWorldInfo::set_svr_status(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_svr_status(value);
  // @@protoc_insertion_point(field_set:msg.FightWorldInfo.svr_status)
}

// int32 mapId = 3;
inline void FightWorldInfo::clear_mapid() {
  mapid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightWorldInfo::_internal_mapid() const {
  return mapid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightWorldInfo::mapid() const {
  // @@protoc_insertion_point(field_get:msg.FightWorldInfo.mapId)
  return _internal_mapid();
}
inline void FightWorldInfo::_internal_set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mapid_ = value;
}
inline void FightWorldInfo::set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:msg.FightWorldInfo.mapId)
}

// uint32 randomSeed = 4;
inline void FightWorldInfo::clear_randomseed() {
  randomseed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FightWorldInfo::_internal_randomseed() const {
  return randomseed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FightWorldInfo::randomseed() const {
  // @@protoc_insertion_point(field_get:msg.FightWorldInfo.randomSeed)
  return _internal_randomseed();
}
inline void FightWorldInfo::_internal_set_randomseed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  randomseed_ = value;
}
inline void FightWorldInfo::set_randomseed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_randomseed(value);
  // @@protoc_insertion_point(field_set:msg.FightWorldInfo.randomSeed)
}

// uint32 uuidSeed = 5;
inline void FightWorldInfo::clear_uuidseed() {
  uuidseed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FightWorldInfo::_internal_uuidseed() const {
  return uuidseed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FightWorldInfo::uuidseed() const {
  // @@protoc_insertion_point(field_get:msg.FightWorldInfo.uuidSeed)
  return _internal_uuidseed();
}
inline void FightWorldInfo::_internal_set_uuidseed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  uuidseed_ = value;
}
inline void FightWorldInfo::set_uuidseed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_uuidseed(value);
  // @@protoc_insertion_point(field_set:msg.FightWorldInfo.uuidSeed)
}

// bool isOfflineMode = 6;
inline void FightWorldInfo::clear_isofflinemode() {
  isofflinemode_ = false;
}
inline bool FightWorldInfo::_internal_isofflinemode() const {
  return isofflinemode_;
}
inline bool FightWorldInfo::isofflinemode() const {
  // @@protoc_insertion_point(field_get:msg.FightWorldInfo.isOfflineMode)
  return _internal_isofflinemode();
}
inline void FightWorldInfo::_internal_set_isofflinemode(bool value) {
  
  isofflinemode_ = value;
}
inline void FightWorldInfo::set_isofflinemode(bool value) {
  _internal_set_isofflinemode(value);
  // @@protoc_insertion_point(field_set:msg.FightWorldInfo.isOfflineMode)
}

// repeated int64 roles = 7;
inline int FightWorldInfo::_internal_roles_size() const {
  return roles_.size();
}
inline int FightWorldInfo::roles_size() const {
  return _internal_roles_size();
}
inline void FightWorldInfo::clear_roles() {
  roles_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FightWorldInfo::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FightWorldInfo::roles(int index) const {
  // @@protoc_insertion_point(field_get:msg.FightWorldInfo.roles)
  return _internal_roles(index);
}
inline void FightWorldInfo::set_roles(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  roles_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.FightWorldInfo.roles)
}
inline void FightWorldInfo::_internal_add_roles(::PROTOBUF_NAMESPACE_ID::int64 value) {
  roles_.Add(value);
}
inline void FightWorldInfo::add_roles(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_roles(value);
  // @@protoc_insertion_point(field_add:msg.FightWorldInfo.roles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
FightWorldInfo::_internal_roles() const {
  return roles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
FightWorldInfo::roles() const {
  // @@protoc_insertion_point(field_list:msg.FightWorldInfo.roles)
  return _internal_roles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
FightWorldInfo::_internal_mutable_roles() {
  return &roles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
FightWorldInfo::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:msg.FightWorldInfo.roles)
  return _internal_mutable_roles();
}

// -------------------------------------------------------------------

// JoinFightAck

// int32 code = 1;
inline void JoinFightAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinFightAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 JoinFightAck::code() const {
  // @@protoc_insertion_point(field_get:msg.JoinFightAck.code)
  return _internal_code();
}
inline void JoinFightAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void JoinFightAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.JoinFightAck.code)
}

// .msg.FightWorldInfo worldInfo = 2;
inline bool JoinFightAck::_internal_has_worldinfo() const {
  return this != internal_default_instance() && worldinfo_ != nullptr;
}
inline bool JoinFightAck::has_worldinfo() const {
  return _internal_has_worldinfo();
}
inline void JoinFightAck::clear_worldinfo() {
  if (GetArenaNoVirtual() == nullptr && worldinfo_ != nullptr) {
    delete worldinfo_;
  }
  worldinfo_ = nullptr;
}
inline const ::msg::FightWorldInfo& JoinFightAck::_internal_worldinfo() const {
  const ::msg::FightWorldInfo* p = worldinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::msg::FightWorldInfo*>(
      &::msg::_FightWorldInfo_default_instance_);
}
inline const ::msg::FightWorldInfo& JoinFightAck::worldinfo() const {
  // @@protoc_insertion_point(field_get:msg.JoinFightAck.worldInfo)
  return _internal_worldinfo();
}
inline ::msg::FightWorldInfo* JoinFightAck::release_worldinfo() {
  // @@protoc_insertion_point(field_release:msg.JoinFightAck.worldInfo)
  
  ::msg::FightWorldInfo* temp = worldinfo_;
  worldinfo_ = nullptr;
  return temp;
}
inline ::msg::FightWorldInfo* JoinFightAck::_internal_mutable_worldinfo() {
  
  if (worldinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::FightWorldInfo>(GetArenaNoVirtual());
    worldinfo_ = p;
  }
  return worldinfo_;
}
inline ::msg::FightWorldInfo* JoinFightAck::mutable_worldinfo() {
  // @@protoc_insertion_point(field_mutable:msg.JoinFightAck.worldInfo)
  return _internal_mutable_worldinfo();
}
inline void JoinFightAck::set_allocated_worldinfo(::msg::FightWorldInfo* worldinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete worldinfo_;
  }
  if (worldinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      worldinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, worldinfo, submessage_arena);
    }
    
  } else {
    
  }
  worldinfo_ = worldinfo;
  // @@protoc_insertion_point(field_set_allocated:msg.JoinFightAck.worldInfo)
}

// -------------------------------------------------------------------

// PlayerLoadingReq

// float percent = 1;
inline void PlayerLoadingReq::clear_percent() {
  percent_ = 0;
}
inline float PlayerLoadingReq::_internal_percent() const {
  return percent_;
}
inline float PlayerLoadingReq::percent() const {
  // @@protoc_insertion_point(field_get:msg.PlayerLoadingReq.percent)
  return _internal_percent();
}
inline void PlayerLoadingReq::_internal_set_percent(float value) {
  
  percent_ = value;
}
inline void PlayerLoadingReq::set_percent(float value) {
  _internal_set_percent(value);
  // @@protoc_insertion_point(field_set:msg.PlayerLoadingReq.percent)
}

// bool finish = 2;
inline void PlayerLoadingReq::clear_finish() {
  finish_ = false;
}
inline bool PlayerLoadingReq::_internal_finish() const {
  return finish_;
}
inline bool PlayerLoadingReq::finish() const {
  // @@protoc_insertion_point(field_get:msg.PlayerLoadingReq.finish)
  return _internal_finish();
}
inline void PlayerLoadingReq::_internal_set_finish(bool value) {
  
  finish_ = value;
}
inline void PlayerLoadingReq::set_finish(bool value) {
  _internal_set_finish(value);
  // @@protoc_insertion_point(field_set:msg.PlayerLoadingReq.finish)
}

// -------------------------------------------------------------------

// PlayerLoadingAck

// repeated int64 pid = 1;
inline int PlayerLoadingAck::_internal_pid_size() const {
  return pid_.size();
}
inline int PlayerLoadingAck::pid_size() const {
  return _internal_pid_size();
}
inline void PlayerLoadingAck::clear_pid() {
  pid_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerLoadingAck::_internal_pid(int index) const {
  return pid_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerLoadingAck::pid(int index) const {
  // @@protoc_insertion_point(field_get:msg.PlayerLoadingAck.pid)
  return _internal_pid(index);
}
inline void PlayerLoadingAck::set_pid(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  pid_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.PlayerLoadingAck.pid)
}
inline void PlayerLoadingAck::_internal_add_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  pid_.Add(value);
}
inline void PlayerLoadingAck::add_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_pid(value);
  // @@protoc_insertion_point(field_add:msg.PlayerLoadingAck.pid)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlayerLoadingAck::_internal_pid() const {
  return pid_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlayerLoadingAck::pid() const {
  // @@protoc_insertion_point(field_list:msg.PlayerLoadingAck.pid)
  return _internal_pid();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlayerLoadingAck::_internal_mutable_pid() {
  return &pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlayerLoadingAck::mutable_pid() {
  // @@protoc_insertion_point(field_mutable_list:msg.PlayerLoadingAck.pid)
  return _internal_mutable_pid();
}

// repeated float percent = 2;
inline int PlayerLoadingAck::_internal_percent_size() const {
  return percent_.size();
}
inline int PlayerLoadingAck::percent_size() const {
  return _internal_percent_size();
}
inline void PlayerLoadingAck::clear_percent() {
  percent_.Clear();
}
inline float PlayerLoadingAck::_internal_percent(int index) const {
  return percent_.Get(index);
}
inline float PlayerLoadingAck::percent(int index) const {
  // @@protoc_insertion_point(field_get:msg.PlayerLoadingAck.percent)
  return _internal_percent(index);
}
inline void PlayerLoadingAck::set_percent(int index, float value) {
  percent_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.PlayerLoadingAck.percent)
}
inline void PlayerLoadingAck::_internal_add_percent(float value) {
  percent_.Add(value);
}
inline void PlayerLoadingAck::add_percent(float value) {
  _internal_add_percent(value);
  // @@protoc_insertion_point(field_add:msg.PlayerLoadingAck.percent)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PlayerLoadingAck::_internal_percent() const {
  return percent_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
PlayerLoadingAck::percent() const {
  // @@protoc_insertion_point(field_list:msg.PlayerLoadingAck.percent)
  return _internal_percent();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PlayerLoadingAck::_internal_mutable_percent() {
  return &percent_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
PlayerLoadingAck::mutable_percent() {
  // @@protoc_insertion_point(field_mutable_list:msg.PlayerLoadingAck.percent)
  return _internal_mutable_percent();
}

// bool finish = 3;
inline void PlayerLoadingAck::clear_finish() {
  finish_ = false;
}
inline bool PlayerLoadingAck::_internal_finish() const {
  return finish_;
}
inline bool PlayerLoadingAck::finish() const {
  // @@protoc_insertion_point(field_get:msg.PlayerLoadingAck.finish)
  return _internal_finish();
}
inline void PlayerLoadingAck::_internal_set_finish(bool value) {
  
  finish_ = value;
}
inline void PlayerLoadingAck::set_finish(bool value) {
  _internal_set_finish(value);
  // @@protoc_insertion_point(field_set:msg.PlayerLoadingAck.finish)
}

// -------------------------------------------------------------------

// PlayerReadyNotify

// int64 pid = 1;
inline void PlayerReadyNotify::clear_pid() {
  pid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerReadyNotify::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerReadyNotify::pid() const {
  // @@protoc_insertion_point(field_get:msg.PlayerReadyNotify.pid)
  return _internal_pid();
}
inline void PlayerReadyNotify::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void PlayerReadyNotify::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:msg.PlayerReadyNotify.pid)
}

// -------------------------------------------------------------------

// PlayerExitFightNotify

// int64 pid = 1;
inline void PlayerExitFightNotify::clear_pid() {
  pid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerExitFightNotify::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerExitFightNotify::pid() const {
  // @@protoc_insertion_point(field_get:msg.PlayerExitFightNotify.pid)
  return _internal_pid();
}
inline void PlayerExitFightNotify::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void PlayerExitFightNotify::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:msg.PlayerExitFightNotify.pid)
}

// -------------------------------------------------------------------

// FrameInputData

// uint32 key_down = 1;
inline void FrameInputData::clear_key_down() {
  key_down_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameInputData::_internal_key_down() const {
  return key_down_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FrameInputData::key_down() const {
  // @@protoc_insertion_point(field_get:msg.FrameInputData.key_down)
  return _internal_key_down();
}
inline void FrameInputData::_internal_set_key_down(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  key_down_ = value;
}
inline void FrameInputData::set_key_down(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key_down(value);
  // @@protoc_insertion_point(field_set:msg.FrameInputData.key_down)
}

// -------------------------------------------------------------------

// PlayerFrameInput

// int64 pid = 1;
inline void PlayerFrameInput::clear_pid() {
  pid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerFrameInput::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerFrameInput::pid() const {
  // @@protoc_insertion_point(field_get:msg.PlayerFrameInput.pid)
  return _internal_pid();
}
inline void PlayerFrameInput::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void PlayerFrameInput::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:msg.PlayerFrameInput.pid)
}

// uint32 frame = 2;
inline void PlayerFrameInput::clear_frame() {
  frame_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerFrameInput::_internal_frame() const {
  return frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PlayerFrameInput::frame() const {
  // @@protoc_insertion_point(field_get:msg.PlayerFrameInput.frame)
  return _internal_frame();
}
inline void PlayerFrameInput::_internal_set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frame_ = value;
}
inline void PlayerFrameInput::set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:msg.PlayerFrameInput.frame)
}

// .msg.FrameInputData input = 3;
inline bool PlayerFrameInput::_internal_has_input() const {
  return this != internal_default_instance() && input_ != nullptr;
}
inline bool PlayerFrameInput::has_input() const {
  return _internal_has_input();
}
inline void PlayerFrameInput::clear_input() {
  if (GetArenaNoVirtual() == nullptr && input_ != nullptr) {
    delete input_;
  }
  input_ = nullptr;
}
inline const ::msg::FrameInputData& PlayerFrameInput::_internal_input() const {
  const ::msg::FrameInputData* p = input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::msg::FrameInputData*>(
      &::msg::_FrameInputData_default_instance_);
}
inline const ::msg::FrameInputData& PlayerFrameInput::input() const {
  // @@protoc_insertion_point(field_get:msg.PlayerFrameInput.input)
  return _internal_input();
}
inline ::msg::FrameInputData* PlayerFrameInput::release_input() {
  // @@protoc_insertion_point(field_release:msg.PlayerFrameInput.input)
  
  ::msg::FrameInputData* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::msg::FrameInputData* PlayerFrameInput::_internal_mutable_input() {
  
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::FrameInputData>(GetArenaNoVirtual());
    input_ = p;
  }
  return input_;
}
inline ::msg::FrameInputData* PlayerFrameInput::mutable_input() {
  // @@protoc_insertion_point(field_mutable:msg.PlayerFrameInput.input)
  return _internal_mutable_input();
}
inline void PlayerFrameInput::set_allocated_input(::msg::FrameInputData* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:msg.PlayerFrameInput.input)
}

// -------------------------------------------------------------------

// RunNextFrameReq

// uint32 frame = 1;
inline void RunNextFrameReq::clear_frame() {
  frame_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RunNextFrameReq::_internal_frame() const {
  return frame_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RunNextFrameReq::frame() const {
  // @@protoc_insertion_point(field_get:msg.RunNextFrameReq.frame)
  return _internal_frame();
}
inline void RunNextFrameReq::_internal_set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  frame_ = value;
}
inline void RunNextFrameReq::set_frame(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:msg.RunNextFrameReq.frame)
}

// .msg.FrameInputData input = 2;
inline bool RunNextFrameReq::_internal_has_input() const {
  return this != internal_default_instance() && input_ != nullptr;
}
inline bool RunNextFrameReq::has_input() const {
  return _internal_has_input();
}
inline void RunNextFrameReq::clear_input() {
  if (GetArenaNoVirtual() == nullptr && input_ != nullptr) {
    delete input_;
  }
  input_ = nullptr;
}
inline const ::msg::FrameInputData& RunNextFrameReq::_internal_input() const {
  const ::msg::FrameInputData* p = input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::msg::FrameInputData*>(
      &::msg::_FrameInputData_default_instance_);
}
inline const ::msg::FrameInputData& RunNextFrameReq::input() const {
  // @@protoc_insertion_point(field_get:msg.RunNextFrameReq.input)
  return _internal_input();
}
inline ::msg::FrameInputData* RunNextFrameReq::release_input() {
  // @@protoc_insertion_point(field_release:msg.RunNextFrameReq.input)
  
  ::msg::FrameInputData* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::msg::FrameInputData* RunNextFrameReq::_internal_mutable_input() {
  
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::FrameInputData>(GetArenaNoVirtual());
    input_ = p;
  }
  return input_;
}
inline ::msg::FrameInputData* RunNextFrameReq::mutable_input() {
  // @@protoc_insertion_point(field_mutable:msg.RunNextFrameReq.input)
  return _internal_mutable_input();
}
inline void RunNextFrameReq::set_allocated_input(::msg::FrameInputData* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:msg.RunNextFrameReq.input)
}

// -------------------------------------------------------------------

// RunNextFrameAck

// uint32 nextFrame = 1;
inline void RunNextFrameAck::clear_nextframe() {
  nextframe_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RunNextFrameAck::_internal_nextframe() const {
  return nextframe_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RunNextFrameAck::nextframe() const {
  // @@protoc_insertion_point(field_get:msg.RunNextFrameAck.nextFrame)
  return _internal_nextframe();
}
inline void RunNextFrameAck::_internal_set_nextframe(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  nextframe_ = value;
}
inline void RunNextFrameAck::set_nextframe(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_nextframe(value);
  // @@protoc_insertion_point(field_set:msg.RunNextFrameAck.nextFrame)
}

// repeated .msg.PlayerFrameInput frames = 2;
inline int RunNextFrameAck::_internal_frames_size() const {
  return frames_.size();
}
inline int RunNextFrameAck::frames_size() const {
  return _internal_frames_size();
}
inline void RunNextFrameAck::clear_frames() {
  frames_.Clear();
}
inline ::msg::PlayerFrameInput* RunNextFrameAck::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:msg.RunNextFrameAck.frames)
  return frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >*
RunNextFrameAck::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:msg.RunNextFrameAck.frames)
  return &frames_;
}
inline const ::msg::PlayerFrameInput& RunNextFrameAck::_internal_frames(int index) const {
  return frames_.Get(index);
}
inline const ::msg::PlayerFrameInput& RunNextFrameAck::frames(int index) const {
  // @@protoc_insertion_point(field_get:msg.RunNextFrameAck.frames)
  return _internal_frames(index);
}
inline ::msg::PlayerFrameInput* RunNextFrameAck::_internal_add_frames() {
  return frames_.Add();
}
inline ::msg::PlayerFrameInput* RunNextFrameAck::add_frames() {
  // @@protoc_insertion_point(field_add:msg.RunNextFrameAck.frames)
  return _internal_add_frames();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >&
RunNextFrameAck::frames() const {
  // @@protoc_insertion_point(field_list:msg.RunNextFrameAck.frames)
  return frames_;
}

// -------------------------------------------------------------------

// PushFrameInputBegin

// int32 placeholder = 1;
inline void PushFrameInputBegin::clear_placeholder() {
  placeholder_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushFrameInputBegin::_internal_placeholder() const {
  return placeholder_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushFrameInputBegin::placeholder() const {
  // @@protoc_insertion_point(field_get:msg.PushFrameInputBegin.placeholder)
  return _internal_placeholder();
}
inline void PushFrameInputBegin::_internal_set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  placeholder_ = value;
}
inline void PushFrameInputBegin::set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_placeholder(value);
  // @@protoc_insertion_point(field_set:msg.PushFrameInputBegin.placeholder)
}

// -------------------------------------------------------------------

// PushFrameInputEnd

// int32 placeholder = 1;
inline void PushFrameInputEnd::clear_placeholder() {
  placeholder_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushFrameInputEnd::_internal_placeholder() const {
  return placeholder_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PushFrameInputEnd::placeholder() const {
  // @@protoc_insertion_point(field_get:msg.PushFrameInputEnd.placeholder)
  return _internal_placeholder();
}
inline void PushFrameInputEnd::_internal_set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  placeholder_ = value;
}
inline void PushFrameInputEnd::set_placeholder(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_placeholder(value);
  // @@protoc_insertion_point(field_set:msg.PushFrameInputEnd.placeholder)
}

// -------------------------------------------------------------------

// PushFrameInput

// uint32 lastFrame = 1;
inline void PushFrameInput::clear_lastframe() {
  lastframe_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushFrameInput::_internal_lastframe() const {
  return lastframe_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PushFrameInput::lastframe() const {
  // @@protoc_insertion_point(field_get:msg.PushFrameInput.lastFrame)
  return _internal_lastframe();
}
inline void PushFrameInput::_internal_set_lastframe(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  lastframe_ = value;
}
inline void PushFrameInput::set_lastframe(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lastframe(value);
  // @@protoc_insertion_point(field_set:msg.PushFrameInput.lastFrame)
}

// repeated .msg.PlayerFrameInput frames = 2;
inline int PushFrameInput::_internal_frames_size() const {
  return frames_.size();
}
inline int PushFrameInput::frames_size() const {
  return _internal_frames_size();
}
inline void PushFrameInput::clear_frames() {
  frames_.Clear();
}
inline ::msg::PlayerFrameInput* PushFrameInput::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:msg.PushFrameInput.frames)
  return frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >*
PushFrameInput::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:msg.PushFrameInput.frames)
  return &frames_;
}
inline const ::msg::PlayerFrameInput& PushFrameInput::_internal_frames(int index) const {
  return frames_.Get(index);
}
inline const ::msg::PlayerFrameInput& PushFrameInput::frames(int index) const {
  // @@protoc_insertion_point(field_get:msg.PushFrameInput.frames)
  return _internal_frames(index);
}
inline ::msg::PlayerFrameInput* PushFrameInput::_internal_add_frames() {
  return frames_.Add();
}
inline ::msg::PlayerFrameInput* PushFrameInput::add_frames() {
  // @@protoc_insertion_point(field_add:msg.PushFrameInput.frames)
  return _internal_add_frames();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >&
PushFrameInput::frames() const {
  // @@protoc_insertion_point(field_list:msg.PushFrameInput.frames)
  return frames_;
}

// -------------------------------------------------------------------

// PlayerRecords

// repeated .msg.PlayerFrameInput frames = 1;
inline int PlayerRecords::_internal_frames_size() const {
  return frames_.size();
}
inline int PlayerRecords::frames_size() const {
  return _internal_frames_size();
}
inline void PlayerRecords::clear_frames() {
  frames_.Clear();
}
inline ::msg::PlayerFrameInput* PlayerRecords::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:msg.PlayerRecords.frames)
  return frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >*
PlayerRecords::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:msg.PlayerRecords.frames)
  return &frames_;
}
inline const ::msg::PlayerFrameInput& PlayerRecords::_internal_frames(int index) const {
  return frames_.Get(index);
}
inline const ::msg::PlayerFrameInput& PlayerRecords::frames(int index) const {
  // @@protoc_insertion_point(field_get:msg.PlayerRecords.frames)
  return _internal_frames(index);
}
inline ::msg::PlayerFrameInput* PlayerRecords::_internal_add_frames() {
  return frames_.Add();
}
inline ::msg::PlayerFrameInput* PlayerRecords::add_frames() {
  // @@protoc_insertion_point(field_add:msg.PlayerRecords.frames)
  return _internal_add_frames();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerFrameInput >&
PlayerRecords::frames() const {
  // @@protoc_insertion_point(field_list:msg.PlayerRecords.frames)
  return frames_;
}

// -------------------------------------------------------------------

// ExitFightReq

// int32 fightUUID = 1;
inline void ExitFightReq::clear_fightuuid() {
  fightuuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExitFightReq::_internal_fightuuid() const {
  return fightuuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExitFightReq::fightuuid() const {
  // @@protoc_insertion_point(field_get:msg.ExitFightReq.fightUUID)
  return _internal_fightuuid();
}
inline void ExitFightReq::_internal_set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fightuuid_ = value;
}
inline void ExitFightReq::set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fightuuid(value);
  // @@protoc_insertion_point(field_set:msg.ExitFightReq.fightUUID)
}

// -------------------------------------------------------------------

// ExitFightAck

// int32 code = 1;
inline void ExitFightAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExitFightAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExitFightAck::code() const {
  // @@protoc_insertion_point(field_get:msg.ExitFightAck.code)
  return _internal_code();
}
inline void ExitFightAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void ExitFightAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.ExitFightAck.code)
}

// -------------------------------------------------------------------

// Ping

// uint32 timestamp = 1;
inline void Ping::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:msg.Ping.timestamp)
  return _internal_timestamp();
}
inline void Ping::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  timestamp_ = value;
}
inline void Ping::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:msg.Ping.timestamp)
}

// int32 ping = 2;
inline void Ping::clear_ping() {
  ping_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ping::_internal_ping() const {
  return ping_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Ping::ping() const {
  // @@protoc_insertion_point(field_get:msg.Ping.ping)
  return _internal_ping();
}
inline void Ping::_internal_set_ping(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ping_ = value;
}
inline void Ping::set_ping(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ping(value);
  // @@protoc_insertion_point(field_set:msg.Ping.ping)
}

// -------------------------------------------------------------------

// Pong

// uint32 timestamp = 1;
inline void Pong::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pong::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Pong::timestamp() const {
  // @@protoc_insertion_point(field_get:msg.Pong.timestamp)
  return _internal_timestamp();
}
inline void Pong::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  timestamp_ = value;
}
inline void Pong::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:msg.Pong.timestamp)
}

// -------------------------------------------------------------------

// PingInfo

// int64 pid = 1;
inline void PingInfo::clear_pid() {
  pid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PingInfo::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PingInfo::pid() const {
  // @@protoc_insertion_point(field_get:msg.PingInfo.pid)
  return _internal_pid();
}
inline void PingInfo::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void PingInfo::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:msg.PingInfo.pid)
}

// int32 ping = 2;
inline void PingInfo::clear_ping() {
  ping_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PingInfo::_internal_ping() const {
  return ping_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PingInfo::ping() const {
  // @@protoc_insertion_point(field_get:msg.PingInfo.ping)
  return _internal_ping();
}
inline void PingInfo::_internal_set_ping(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ping_ = value;
}
inline void PingInfo::set_ping(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ping(value);
  // @@protoc_insertion_point(field_set:msg.PingInfo.ping)
}

// -------------------------------------------------------------------

// PushPingInfo

// repeated .msg.PingInfo infos = 1;
inline int PushPingInfo::_internal_infos_size() const {
  return infos_.size();
}
inline int PushPingInfo::infos_size() const {
  return _internal_infos_size();
}
inline void PushPingInfo::clear_infos() {
  infos_.Clear();
}
inline ::msg::PingInfo* PushPingInfo::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:msg.PushPingInfo.infos)
  return infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PingInfo >*
PushPingInfo::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:msg.PushPingInfo.infos)
  return &infos_;
}
inline const ::msg::PingInfo& PushPingInfo::_internal_infos(int index) const {
  return infos_.Get(index);
}
inline const ::msg::PingInfo& PushPingInfo::infos(int index) const {
  // @@protoc_insertion_point(field_get:msg.PushPingInfo.infos)
  return _internal_infos(index);
}
inline ::msg::PingInfo* PushPingInfo::_internal_add_infos() {
  return infos_.Add();
}
inline ::msg::PingInfo* PushPingInfo::add_infos() {
  // @@protoc_insertion_point(field_add:msg.PushPingInfo.infos)
  return _internal_add_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PingInfo >&
PushPingInfo::infos() const {
  // @@protoc_insertion_point(field_list:msg.PushPingInfo.infos)
  return infos_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::msg::JoinFightReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::JoinFightAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PlayerLoadingReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PlayerLoadingAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PlayerReadyNotify_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PlayerExitFightNotify_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::RunNextFrameReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::RunNextFrameAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PushFrameInputBegin_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PushFrameInputEnd_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PushFrameInput_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::ExitFightReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::ExitFightAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::Ping_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::Pong_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PushPingInfo_MsgId> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_C2Fight_2eproto
