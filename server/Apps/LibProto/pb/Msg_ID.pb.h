// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_ID.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Msg_5fID_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Msg_5fID_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Msg_5fID_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Msg_5fID_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

enum MessageID : int {
  MSG_BEGIN = 0,
  MSG_LOGIN_GATE_ACK = 100001,
  MSG_NEW_FIGHT_REQ = 200001,
  MSG_NEW_FIGHT_ACK = 200002,
  MSG_CKECK_TOKEN_REQ = 300003,
  MSG_CKECK_TOKEN_ACK = 300004,
  MES_CHANGE_TOKEN_NTF = 300006,
  MSG_REG_SERVER_NODE_REQ = 600001,
  MSG_REG_SERVER_NODE_ACK = 600002,
  MSG_JOIN_FIGHT_REQ = 800001,
  MSG_JOIN_FIGHT_ACK = 800002,
  MSG_RUN_NEXT_FRAME_REQ = 800003,
  MSG_RUN_NEXT_FRAME_ACK = 800004,
  MSG_PLAYER_READY_NTF = 800005,
  MSG_PLAYER_EXIT_FIGHT_NTF = 800006,
  MSG_EXIT_FIGHT_REQ = 800007,
  MSG_EXIT_FIGHT_ACK = 800008,
  MSG_LOADING_PERCENT_REQ = 800009,
  MSG_LOADING_PERCENT_ACK = 800010,
  MSG_PUSH_FRAME_BEGIN = 800011,
  MSG_PUSH_FRAME_INPUT = 800012,
  MSG_PUSH_FRAME_END = 800013,
  MSG_PING_REQ = 800020,
  MSG_PING_ACK = 800021,
  MSG_PUSH_PING_NTF = 800023,
  MSG_LOGIN_REQ = 900001,
  MSG_LOGIN_ACK = 900002,
  MSG_CREATE_ROLE_REQ = 900303,
  MSG_CREATE_ROLE_ACK = 900304,
  MSG_ENTER_GAME_REQ = 900305,
  MSG_ENTER_GAME_ACK = 900306,
  MSG_MODIFY_ROLE_DATA_REQ = 900307,
  MSG_MODIFY_ROLE_DATA_ACK = 900308,
  MSG_EXIT_GAME_NTF = 900010,
  MSG_PUSH_ROLE_DATA = 900011,
  MSG_START_PVE_REQ = 900101,
  MSG_START_PVE_ACK = 900102,
  MSG_START_PVP_REQ = 900103,
  MSG_START_PVP_ACK = 900104,
  MSG_STOP_PVP_REQ = 900105,
  MSG_STOP_PVP_ACK = 900106,
  MSG_START_FIGHT_NTF = 900200,
  MessageID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MessageID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MessageID_IsValid(int value);
constexpr MessageID MessageID_MIN = MSG_BEGIN;
constexpr MessageID MessageID_MAX = MSG_MODIFY_ROLE_DATA_ACK;
constexpr int MessageID_ARRAYSIZE = MessageID_MAX + 1;

const std::string& MessageID_Name(MessageID value);
template<typename T>
inline const std::string& MessageID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageID_Name.");
  return MessageID_Name(static_cast<MessageID>(enum_t_value));
}
bool MessageID_Parse(
    const std::string& name, MessageID* value);
enum FightType : int {
  FIGHT_PVE = 0,
  FIGHT_PVP = 1,
  FightType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FightType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FightType_IsValid(int value);
constexpr FightType FightType_MIN = FIGHT_PVE;
constexpr FightType FightType_MAX = FIGHT_PVP;
constexpr int FightType_ARRAYSIZE = FightType_MAX + 1;

const std::string& FightType_Name(FightType value);
template<typename T>
inline const std::string& FightType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FightType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FightType_Name.");
  return FightType_Name(static_cast<FightType>(enum_t_value));
}
bool FightType_Parse(
    const std::string& name, FightType* value);
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MessageID> : ::std::true_type {};
template <> struct is_proto_enum< ::FightType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Msg_5fID_2eproto
