// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: C2Game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_C2Game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_C2Game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_C2Game_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_C2Game_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[21]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace msg {
class CreateRoleAck;
class CreateRoleAckDefaultTypeInternal;
extern CreateRoleAckDefaultTypeInternal _CreateRoleAck_default_instance_;
class CreateRoleReq;
class CreateRoleReqDefaultTypeInternal;
extern CreateRoleReqDefaultTypeInternal _CreateRoleReq_default_instance_;
class EnterGameAck;
class EnterGameAckDefaultTypeInternal;
extern EnterGameAckDefaultTypeInternal _EnterGameAck_default_instance_;
class EnterGameReq;
class EnterGameReqDefaultTypeInternal;
extern EnterGameReqDefaultTypeInternal _EnterGameReq_default_instance_;
class ExitGameNtf;
class ExitGameNtfDefaultTypeInternal;
extern ExitGameNtfDefaultTypeInternal _ExitGameNtf_default_instance_;
class LoginAck;
class LoginAckDefaultTypeInternal;
extern LoginAckDefaultTypeInternal _LoginAck_default_instance_;
class LoginReq;
class LoginReqDefaultTypeInternal;
extern LoginReqDefaultTypeInternal _LoginReq_default_instance_;
class ModifyRoleDataAck;
class ModifyRoleDataAckDefaultTypeInternal;
extern ModifyRoleDataAckDefaultTypeInternal _ModifyRoleDataAck_default_instance_;
class ModifyRoleDataReq;
class ModifyRoleDataReqDefaultTypeInternal;
extern ModifyRoleDataReqDefaultTypeInternal _ModifyRoleDataReq_default_instance_;
class PVEFightInfo;
class PVEFightInfoDefaultTypeInternal;
extern PVEFightInfoDefaultTypeInternal _PVEFightInfo_default_instance_;
class PlayerAccountInfo;
class PlayerAccountInfoDefaultTypeInternal;
extern PlayerAccountInfoDefaultTypeInternal _PlayerAccountInfo_default_instance_;
class PushRoleData;
class PushRoleDataDefaultTypeInternal;
extern PushRoleDataDefaultTypeInternal _PushRoleData_default_instance_;
class RoleDetailedInfo;
class RoleDetailedInfoDefaultTypeInternal;
extern RoleDetailedInfoDefaultTypeInternal _RoleDetailedInfo_default_instance_;
class RoleSimpleInfo;
class RoleSimpleInfoDefaultTypeInternal;
extern RoleSimpleInfoDefaultTypeInternal _RoleSimpleInfo_default_instance_;
class StartFightNTF;
class StartFightNTFDefaultTypeInternal;
extern StartFightNTFDefaultTypeInternal _StartFightNTF_default_instance_;
class StartPVEFightAck;
class StartPVEFightAckDefaultTypeInternal;
extern StartPVEFightAckDefaultTypeInternal _StartPVEFightAck_default_instance_;
class StartPVEFightReq;
class StartPVEFightReqDefaultTypeInternal;
extern StartPVEFightReqDefaultTypeInternal _StartPVEFightReq_default_instance_;
class StartPVPFightAck;
class StartPVPFightAckDefaultTypeInternal;
extern StartPVPFightAckDefaultTypeInternal _StartPVPFightAck_default_instance_;
class StartPVPFightReq;
class StartPVPFightReqDefaultTypeInternal;
extern StartPVPFightReqDefaultTypeInternal _StartPVPFightReq_default_instance_;
class StopPVPMatchAck;
class StopPVPMatchAckDefaultTypeInternal;
extern StopPVPMatchAckDefaultTypeInternal _StopPVPMatchAck_default_instance_;
class StopPVPMatchReq;
class StopPVPMatchReqDefaultTypeInternal;
extern StopPVPMatchReqDefaultTypeInternal _StopPVPMatchReq_default_instance_;
}  // namespace msg
PROTOBUF_NAMESPACE_OPEN
template<> ::msg::CreateRoleAck* Arena::CreateMaybeMessage<::msg::CreateRoleAck>(Arena*);
template<> ::msg::CreateRoleReq* Arena::CreateMaybeMessage<::msg::CreateRoleReq>(Arena*);
template<> ::msg::EnterGameAck* Arena::CreateMaybeMessage<::msg::EnterGameAck>(Arena*);
template<> ::msg::EnterGameReq* Arena::CreateMaybeMessage<::msg::EnterGameReq>(Arena*);
template<> ::msg::ExitGameNtf* Arena::CreateMaybeMessage<::msg::ExitGameNtf>(Arena*);
template<> ::msg::LoginAck* Arena::CreateMaybeMessage<::msg::LoginAck>(Arena*);
template<> ::msg::LoginReq* Arena::CreateMaybeMessage<::msg::LoginReq>(Arena*);
template<> ::msg::ModifyRoleDataAck* Arena::CreateMaybeMessage<::msg::ModifyRoleDataAck>(Arena*);
template<> ::msg::ModifyRoleDataReq* Arena::CreateMaybeMessage<::msg::ModifyRoleDataReq>(Arena*);
template<> ::msg::PVEFightInfo* Arena::CreateMaybeMessage<::msg::PVEFightInfo>(Arena*);
template<> ::msg::PlayerAccountInfo* Arena::CreateMaybeMessage<::msg::PlayerAccountInfo>(Arena*);
template<> ::msg::PushRoleData* Arena::CreateMaybeMessage<::msg::PushRoleData>(Arena*);
template<> ::msg::RoleDetailedInfo* Arena::CreateMaybeMessage<::msg::RoleDetailedInfo>(Arena*);
template<> ::msg::RoleSimpleInfo* Arena::CreateMaybeMessage<::msg::RoleSimpleInfo>(Arena*);
template<> ::msg::StartFightNTF* Arena::CreateMaybeMessage<::msg::StartFightNTF>(Arena*);
template<> ::msg::StartPVEFightAck* Arena::CreateMaybeMessage<::msg::StartPVEFightAck>(Arena*);
template<> ::msg::StartPVEFightReq* Arena::CreateMaybeMessage<::msg::StartPVEFightReq>(Arena*);
template<> ::msg::StartPVPFightAck* Arena::CreateMaybeMessage<::msg::StartPVPFightAck>(Arena*);
template<> ::msg::StartPVPFightReq* Arena::CreateMaybeMessage<::msg::StartPVPFightReq>(Arena*);
template<> ::msg::StopPVPMatchAck* Arena::CreateMaybeMessage<::msg::StopPVPMatchAck>(Arena*);
template<> ::msg::StopPVPMatchReq* Arena::CreateMaybeMessage<::msg::StopPVPMatchReq>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace msg {

enum LoginReq_MsgId : int {
  LoginReq_MsgId_None = 0,
  LoginReq_MsgId_Id = 200001,
  LoginReq_MsgId_LoginReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoginReq_MsgId_LoginReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoginReq_MsgId_IsValid(int value);
constexpr LoginReq_MsgId LoginReq_MsgId_MsgId_MIN = LoginReq_MsgId_None;
constexpr LoginReq_MsgId LoginReq_MsgId_MsgId_MAX = LoginReq_MsgId_Id;
constexpr int LoginReq_MsgId_MsgId_ARRAYSIZE = LoginReq_MsgId_MsgId_MAX + 1;

const std::string& LoginReq_MsgId_Name(LoginReq_MsgId value);
template<typename T>
inline const std::string& LoginReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginReq_MsgId_Name.");
  return LoginReq_MsgId_Name(static_cast<LoginReq_MsgId>(enum_t_value));
}
bool LoginReq_MsgId_Parse(
    const std::string& name, LoginReq_MsgId* value);
enum LoginAck_MsgId : int {
  LoginAck_MsgId_None = 0,
  LoginAck_MsgId_Id = 200002,
  LoginAck_MsgId_LoginAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LoginAck_MsgId_LoginAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LoginAck_MsgId_IsValid(int value);
constexpr LoginAck_MsgId LoginAck_MsgId_MsgId_MIN = LoginAck_MsgId_None;
constexpr LoginAck_MsgId LoginAck_MsgId_MsgId_MAX = LoginAck_MsgId_Id;
constexpr int LoginAck_MsgId_MsgId_ARRAYSIZE = LoginAck_MsgId_MsgId_MAX + 1;

const std::string& LoginAck_MsgId_Name(LoginAck_MsgId value);
template<typename T>
inline const std::string& LoginAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoginAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoginAck_MsgId_Name.");
  return LoginAck_MsgId_Name(static_cast<LoginAck_MsgId>(enum_t_value));
}
bool LoginAck_MsgId_Parse(
    const std::string& name, LoginAck_MsgId* value);
enum EnterGameReq_MsgId : int {
  EnterGameReq_MsgId_None = 0,
  EnterGameReq_MsgId_Id = 200003,
  EnterGameReq_MsgId_EnterGameReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EnterGameReq_MsgId_EnterGameReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EnterGameReq_MsgId_IsValid(int value);
constexpr EnterGameReq_MsgId EnterGameReq_MsgId_MsgId_MIN = EnterGameReq_MsgId_None;
constexpr EnterGameReq_MsgId EnterGameReq_MsgId_MsgId_MAX = EnterGameReq_MsgId_Id;
constexpr int EnterGameReq_MsgId_MsgId_ARRAYSIZE = EnterGameReq_MsgId_MsgId_MAX + 1;

const std::string& EnterGameReq_MsgId_Name(EnterGameReq_MsgId value);
template<typename T>
inline const std::string& EnterGameReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnterGameReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnterGameReq_MsgId_Name.");
  return EnterGameReq_MsgId_Name(static_cast<EnterGameReq_MsgId>(enum_t_value));
}
bool EnterGameReq_MsgId_Parse(
    const std::string& name, EnterGameReq_MsgId* value);
enum EnterGameAck_MsgId : int {
  EnterGameAck_MsgId_None = 0,
  EnterGameAck_MsgId_Id = 200004,
  EnterGameAck_MsgId_EnterGameAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EnterGameAck_MsgId_EnterGameAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EnterGameAck_MsgId_IsValid(int value);
constexpr EnterGameAck_MsgId EnterGameAck_MsgId_MsgId_MIN = EnterGameAck_MsgId_None;
constexpr EnterGameAck_MsgId EnterGameAck_MsgId_MsgId_MAX = EnterGameAck_MsgId_Id;
constexpr int EnterGameAck_MsgId_MsgId_ARRAYSIZE = EnterGameAck_MsgId_MsgId_MAX + 1;

const std::string& EnterGameAck_MsgId_Name(EnterGameAck_MsgId value);
template<typename T>
inline const std::string& EnterGameAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EnterGameAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EnterGameAck_MsgId_Name.");
  return EnterGameAck_MsgId_Name(static_cast<EnterGameAck_MsgId>(enum_t_value));
}
bool EnterGameAck_MsgId_Parse(
    const std::string& name, EnterGameAck_MsgId* value);
enum CreateRoleReq_MsgId : int {
  CreateRoleReq_MsgId_None = 0,
  CreateRoleReq_MsgId_Id = 200005,
  CreateRoleReq_MsgId_CreateRoleReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CreateRoleReq_MsgId_CreateRoleReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CreateRoleReq_MsgId_IsValid(int value);
constexpr CreateRoleReq_MsgId CreateRoleReq_MsgId_MsgId_MIN = CreateRoleReq_MsgId_None;
constexpr CreateRoleReq_MsgId CreateRoleReq_MsgId_MsgId_MAX = CreateRoleReq_MsgId_Id;
constexpr int CreateRoleReq_MsgId_MsgId_ARRAYSIZE = CreateRoleReq_MsgId_MsgId_MAX + 1;

const std::string& CreateRoleReq_MsgId_Name(CreateRoleReq_MsgId value);
template<typename T>
inline const std::string& CreateRoleReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreateRoleReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreateRoleReq_MsgId_Name.");
  return CreateRoleReq_MsgId_Name(static_cast<CreateRoleReq_MsgId>(enum_t_value));
}
bool CreateRoleReq_MsgId_Parse(
    const std::string& name, CreateRoleReq_MsgId* value);
enum CreateRoleAck_MsgId : int {
  CreateRoleAck_MsgId_None = 0,
  CreateRoleAck_MsgId_Id = 200006,
  CreateRoleAck_MsgId_CreateRoleAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CreateRoleAck_MsgId_CreateRoleAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CreateRoleAck_MsgId_IsValid(int value);
constexpr CreateRoleAck_MsgId CreateRoleAck_MsgId_MsgId_MIN = CreateRoleAck_MsgId_None;
constexpr CreateRoleAck_MsgId CreateRoleAck_MsgId_MsgId_MAX = CreateRoleAck_MsgId_Id;
constexpr int CreateRoleAck_MsgId_MsgId_ARRAYSIZE = CreateRoleAck_MsgId_MsgId_MAX + 1;

const std::string& CreateRoleAck_MsgId_Name(CreateRoleAck_MsgId value);
template<typename T>
inline const std::string& CreateRoleAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreateRoleAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreateRoleAck_MsgId_Name.");
  return CreateRoleAck_MsgId_Name(static_cast<CreateRoleAck_MsgId>(enum_t_value));
}
bool CreateRoleAck_MsgId_Parse(
    const std::string& name, CreateRoleAck_MsgId* value);
enum ModifyRoleDataReq_MsgId : int {
  ModifyRoleDataReq_MsgId_None = 0,
  ModifyRoleDataReq_MsgId_Id = 200007,
  ModifyRoleDataReq_MsgId_ModifyRoleDataReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModifyRoleDataReq_MsgId_ModifyRoleDataReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModifyRoleDataReq_MsgId_IsValid(int value);
constexpr ModifyRoleDataReq_MsgId ModifyRoleDataReq_MsgId_MsgId_MIN = ModifyRoleDataReq_MsgId_None;
constexpr ModifyRoleDataReq_MsgId ModifyRoleDataReq_MsgId_MsgId_MAX = ModifyRoleDataReq_MsgId_Id;
constexpr int ModifyRoleDataReq_MsgId_MsgId_ARRAYSIZE = ModifyRoleDataReq_MsgId_MsgId_MAX + 1;

const std::string& ModifyRoleDataReq_MsgId_Name(ModifyRoleDataReq_MsgId value);
template<typename T>
inline const std::string& ModifyRoleDataReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModifyRoleDataReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModifyRoleDataReq_MsgId_Name.");
  return ModifyRoleDataReq_MsgId_Name(static_cast<ModifyRoleDataReq_MsgId>(enum_t_value));
}
bool ModifyRoleDataReq_MsgId_Parse(
    const std::string& name, ModifyRoleDataReq_MsgId* value);
enum ModifyRoleDataAck_MsgId : int {
  ModifyRoleDataAck_MsgId_None = 0,
  ModifyRoleDataAck_MsgId_Id = 200008,
  ModifyRoleDataAck_MsgId_ModifyRoleDataAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ModifyRoleDataAck_MsgId_ModifyRoleDataAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ModifyRoleDataAck_MsgId_IsValid(int value);
constexpr ModifyRoleDataAck_MsgId ModifyRoleDataAck_MsgId_MsgId_MIN = ModifyRoleDataAck_MsgId_None;
constexpr ModifyRoleDataAck_MsgId ModifyRoleDataAck_MsgId_MsgId_MAX = ModifyRoleDataAck_MsgId_Id;
constexpr int ModifyRoleDataAck_MsgId_MsgId_ARRAYSIZE = ModifyRoleDataAck_MsgId_MsgId_MAX + 1;

const std::string& ModifyRoleDataAck_MsgId_Name(ModifyRoleDataAck_MsgId value);
template<typename T>
inline const std::string& ModifyRoleDataAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModifyRoleDataAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModifyRoleDataAck_MsgId_Name.");
  return ModifyRoleDataAck_MsgId_Name(static_cast<ModifyRoleDataAck_MsgId>(enum_t_value));
}
bool ModifyRoleDataAck_MsgId_Parse(
    const std::string& name, ModifyRoleDataAck_MsgId* value);
enum ExitGameNtf_MsgId : int {
  ExitGameNtf_MsgId_None = 0,
  ExitGameNtf_MsgId_Id = 200010,
  ExitGameNtf_MsgId_ExitGameNtf_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ExitGameNtf_MsgId_ExitGameNtf_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ExitGameNtf_MsgId_IsValid(int value);
constexpr ExitGameNtf_MsgId ExitGameNtf_MsgId_MsgId_MIN = ExitGameNtf_MsgId_None;
constexpr ExitGameNtf_MsgId ExitGameNtf_MsgId_MsgId_MAX = ExitGameNtf_MsgId_Id;
constexpr int ExitGameNtf_MsgId_MsgId_ARRAYSIZE = ExitGameNtf_MsgId_MsgId_MAX + 1;

const std::string& ExitGameNtf_MsgId_Name(ExitGameNtf_MsgId value);
template<typename T>
inline const std::string& ExitGameNtf_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExitGameNtf_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExitGameNtf_MsgId_Name.");
  return ExitGameNtf_MsgId_Name(static_cast<ExitGameNtf_MsgId>(enum_t_value));
}
bool ExitGameNtf_MsgId_Parse(
    const std::string& name, ExitGameNtf_MsgId* value);
enum StartPVEFightReq_MsgId : int {
  StartPVEFightReq_MsgId_None = 0,
  StartPVEFightReq_MsgId_Id = 200011,
  StartPVEFightReq_MsgId_StartPVEFightReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StartPVEFightReq_MsgId_StartPVEFightReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StartPVEFightReq_MsgId_IsValid(int value);
constexpr StartPVEFightReq_MsgId StartPVEFightReq_MsgId_MsgId_MIN = StartPVEFightReq_MsgId_None;
constexpr StartPVEFightReq_MsgId StartPVEFightReq_MsgId_MsgId_MAX = StartPVEFightReq_MsgId_Id;
constexpr int StartPVEFightReq_MsgId_MsgId_ARRAYSIZE = StartPVEFightReq_MsgId_MsgId_MAX + 1;

const std::string& StartPVEFightReq_MsgId_Name(StartPVEFightReq_MsgId value);
template<typename T>
inline const std::string& StartPVEFightReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartPVEFightReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartPVEFightReq_MsgId_Name.");
  return StartPVEFightReq_MsgId_Name(static_cast<StartPVEFightReq_MsgId>(enum_t_value));
}
bool StartPVEFightReq_MsgId_Parse(
    const std::string& name, StartPVEFightReq_MsgId* value);
enum StartPVEFightAck_MsgId : int {
  StartPVEFightAck_MsgId_None = 0,
  StartPVEFightAck_MsgId_Id = 200012,
  StartPVEFightAck_MsgId_StartPVEFightAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StartPVEFightAck_MsgId_StartPVEFightAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StartPVEFightAck_MsgId_IsValid(int value);
constexpr StartPVEFightAck_MsgId StartPVEFightAck_MsgId_MsgId_MIN = StartPVEFightAck_MsgId_None;
constexpr StartPVEFightAck_MsgId StartPVEFightAck_MsgId_MsgId_MAX = StartPVEFightAck_MsgId_Id;
constexpr int StartPVEFightAck_MsgId_MsgId_ARRAYSIZE = StartPVEFightAck_MsgId_MsgId_MAX + 1;

const std::string& StartPVEFightAck_MsgId_Name(StartPVEFightAck_MsgId value);
template<typename T>
inline const std::string& StartPVEFightAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartPVEFightAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartPVEFightAck_MsgId_Name.");
  return StartPVEFightAck_MsgId_Name(static_cast<StartPVEFightAck_MsgId>(enum_t_value));
}
bool StartPVEFightAck_MsgId_Parse(
    const std::string& name, StartPVEFightAck_MsgId* value);
enum StartPVPFightReq_MsgId : int {
  StartPVPFightReq_MsgId_None = 0,
  StartPVPFightReq_MsgId_Id = 200013,
  StartPVPFightReq_MsgId_StartPVPFightReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StartPVPFightReq_MsgId_StartPVPFightReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StartPVPFightReq_MsgId_IsValid(int value);
constexpr StartPVPFightReq_MsgId StartPVPFightReq_MsgId_MsgId_MIN = StartPVPFightReq_MsgId_None;
constexpr StartPVPFightReq_MsgId StartPVPFightReq_MsgId_MsgId_MAX = StartPVPFightReq_MsgId_Id;
constexpr int StartPVPFightReq_MsgId_MsgId_ARRAYSIZE = StartPVPFightReq_MsgId_MsgId_MAX + 1;

const std::string& StartPVPFightReq_MsgId_Name(StartPVPFightReq_MsgId value);
template<typename T>
inline const std::string& StartPVPFightReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartPVPFightReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartPVPFightReq_MsgId_Name.");
  return StartPVPFightReq_MsgId_Name(static_cast<StartPVPFightReq_MsgId>(enum_t_value));
}
bool StartPVPFightReq_MsgId_Parse(
    const std::string& name, StartPVPFightReq_MsgId* value);
enum StartPVPFightAck_MsgId : int {
  StartPVPFightAck_MsgId_None = 0,
  StartPVPFightAck_MsgId_Id = 200014,
  StartPVPFightAck_MsgId_StartPVPFightAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StartPVPFightAck_MsgId_StartPVPFightAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StartPVPFightAck_MsgId_IsValid(int value);
constexpr StartPVPFightAck_MsgId StartPVPFightAck_MsgId_MsgId_MIN = StartPVPFightAck_MsgId_None;
constexpr StartPVPFightAck_MsgId StartPVPFightAck_MsgId_MsgId_MAX = StartPVPFightAck_MsgId_Id;
constexpr int StartPVPFightAck_MsgId_MsgId_ARRAYSIZE = StartPVPFightAck_MsgId_MsgId_MAX + 1;

const std::string& StartPVPFightAck_MsgId_Name(StartPVPFightAck_MsgId value);
template<typename T>
inline const std::string& StartPVPFightAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartPVPFightAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartPVPFightAck_MsgId_Name.");
  return StartPVPFightAck_MsgId_Name(static_cast<StartPVPFightAck_MsgId>(enum_t_value));
}
bool StartPVPFightAck_MsgId_Parse(
    const std::string& name, StartPVPFightAck_MsgId* value);
enum StopPVPMatchReq_MsgId : int {
  StopPVPMatchReq_MsgId_None = 0,
  StopPVPMatchReq_MsgId_Id = 200015,
  StopPVPMatchReq_MsgId_StopPVPMatchReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StopPVPMatchReq_MsgId_StopPVPMatchReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StopPVPMatchReq_MsgId_IsValid(int value);
constexpr StopPVPMatchReq_MsgId StopPVPMatchReq_MsgId_MsgId_MIN = StopPVPMatchReq_MsgId_None;
constexpr StopPVPMatchReq_MsgId StopPVPMatchReq_MsgId_MsgId_MAX = StopPVPMatchReq_MsgId_Id;
constexpr int StopPVPMatchReq_MsgId_MsgId_ARRAYSIZE = StopPVPMatchReq_MsgId_MsgId_MAX + 1;

const std::string& StopPVPMatchReq_MsgId_Name(StopPVPMatchReq_MsgId value);
template<typename T>
inline const std::string& StopPVPMatchReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopPVPMatchReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopPVPMatchReq_MsgId_Name.");
  return StopPVPMatchReq_MsgId_Name(static_cast<StopPVPMatchReq_MsgId>(enum_t_value));
}
bool StopPVPMatchReq_MsgId_Parse(
    const std::string& name, StopPVPMatchReq_MsgId* value);
enum StopPVPMatchAck_MsgId : int {
  StopPVPMatchAck_MsgId_None = 0,
  StopPVPMatchAck_MsgId_Id = 200016,
  StopPVPMatchAck_MsgId_StopPVPMatchAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StopPVPMatchAck_MsgId_StopPVPMatchAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StopPVPMatchAck_MsgId_IsValid(int value);
constexpr StopPVPMatchAck_MsgId StopPVPMatchAck_MsgId_MsgId_MIN = StopPVPMatchAck_MsgId_None;
constexpr StopPVPMatchAck_MsgId StopPVPMatchAck_MsgId_MsgId_MAX = StopPVPMatchAck_MsgId_Id;
constexpr int StopPVPMatchAck_MsgId_MsgId_ARRAYSIZE = StopPVPMatchAck_MsgId_MsgId_MAX + 1;

const std::string& StopPVPMatchAck_MsgId_Name(StopPVPMatchAck_MsgId value);
template<typename T>
inline const std::string& StopPVPMatchAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StopPVPMatchAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StopPVPMatchAck_MsgId_Name.");
  return StopPVPMatchAck_MsgId_Name(static_cast<StopPVPMatchAck_MsgId>(enum_t_value));
}
bool StopPVPMatchAck_MsgId_Parse(
    const std::string& name, StopPVPMatchAck_MsgId* value);
enum StartFightNTF_MsgId : int {
  StartFightNTF_MsgId_None = 0,
  StartFightNTF_MsgId_Id = 200018,
  StartFightNTF_MsgId_StartFightNTF_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StartFightNTF_MsgId_StartFightNTF_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StartFightNTF_MsgId_IsValid(int value);
constexpr StartFightNTF_MsgId StartFightNTF_MsgId_MsgId_MIN = StartFightNTF_MsgId_None;
constexpr StartFightNTF_MsgId StartFightNTF_MsgId_MsgId_MAX = StartFightNTF_MsgId_Id;
constexpr int StartFightNTF_MsgId_MsgId_ARRAYSIZE = StartFightNTF_MsgId_MsgId_MAX + 1;

const std::string& StartFightNTF_MsgId_Name(StartFightNTF_MsgId value);
template<typename T>
inline const std::string& StartFightNTF_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartFightNTF_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartFightNTF_MsgId_Name.");
  return StartFightNTF_MsgId_Name(static_cast<StartFightNTF_MsgId>(enum_t_value));
}
bool StartFightNTF_MsgId_Parse(
    const std::string& name, StartFightNTF_MsgId* value);
enum PushRoleData_MsgId : int {
  PushRoleData_MsgId_None = 0,
  PushRoleData_MsgId_Id = 200020,
  PushRoleData_MsgId_PushRoleData_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PushRoleData_MsgId_PushRoleData_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PushRoleData_MsgId_IsValid(int value);
constexpr PushRoleData_MsgId PushRoleData_MsgId_MsgId_MIN = PushRoleData_MsgId_None;
constexpr PushRoleData_MsgId PushRoleData_MsgId_MsgId_MAX = PushRoleData_MsgId_Id;
constexpr int PushRoleData_MsgId_MsgId_ARRAYSIZE = PushRoleData_MsgId_MsgId_MAX + 1;

const std::string& PushRoleData_MsgId_Name(PushRoleData_MsgId value);
template<typename T>
inline const std::string& PushRoleData_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushRoleData_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushRoleData_MsgId_Name.");
  return PushRoleData_MsgId_Name(static_cast<PushRoleData_MsgId>(enum_t_value));
}
bool PushRoleData_MsgId_Parse(
    const std::string& name, PushRoleData_MsgId* value);
// ===================================================================

class PlayerAccountInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PlayerAccountInfo) */ {
 public:
  PlayerAccountInfo();
  virtual ~PlayerAccountInfo();

  PlayerAccountInfo(const PlayerAccountInfo& from);
  PlayerAccountInfo(PlayerAccountInfo&& from) noexcept
    : PlayerAccountInfo() {
    *this = ::std::move(from);
  }

  inline PlayerAccountInfo& operator=(const PlayerAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerAccountInfo& operator=(PlayerAccountInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PlayerAccountInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerAccountInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerAccountInfo*>(
               &_PlayerAccountInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerAccountInfo& a, PlayerAccountInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerAccountInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerAccountInfo* New() const final {
    return CreateMaybeMessage<PlayerAccountInfo>(nullptr);
  }

  PlayerAccountInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerAccountInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PlayerAccountInfo& from);
  void MergeFrom(const PlayerAccountInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerAccountInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PlayerAccountInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArrRoleIdsFieldNumber = 3,
    kNameFieldNumber = 2,
    kPlayerIDFieldNumber = 1,
  };
  // repeated int64 arrRoleIds = 3;
  int arrroleids_size() const;
  private:
  int _internal_arrroleids_size() const;
  public:
  void clear_arrroleids();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_arrroleids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_arrroleids() const;
  void _internal_add_arrroleids(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_arrroleids();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 arrroleids(int index) const;
  void set_arrroleids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_arrroleids(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      arrroleids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_arrroleids();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 playerID = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PlayerAccountInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > arrroleids_;
  mutable std::atomic<int> _arrroleids_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class RoleDetailedInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.RoleDetailedInfo) */ {
 public:
  RoleDetailedInfo();
  virtual ~RoleDetailedInfo();

  RoleDetailedInfo(const RoleDetailedInfo& from);
  RoleDetailedInfo(RoleDetailedInfo&& from) noexcept
    : RoleDetailedInfo() {
    *this = ::std::move(from);
  }

  inline RoleDetailedInfo& operator=(const RoleDetailedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleDetailedInfo& operator=(RoleDetailedInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RoleDetailedInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoleDetailedInfo* internal_default_instance() {
    return reinterpret_cast<const RoleDetailedInfo*>(
               &_RoleDetailedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RoleDetailedInfo& a, RoleDetailedInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleDetailedInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoleDetailedInfo* New() const final {
    return CreateMaybeMessage<RoleDetailedInfo>(nullptr);
  }

  RoleDetailedInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoleDetailedInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RoleDetailedInfo& from);
  void MergeFrom(const RoleDetailedInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoleDetailedInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RoleDetailedInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kJsonDataFieldNumber = 5,
    kRoleIdFieldNumber = 1,
    kLvFieldNumber = 3,
    kOccupationFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string jsonData = 5;
  void clear_jsondata();
  const std::string& jsondata() const;
  void set_jsondata(const std::string& value);
  void set_jsondata(std::string&& value);
  void set_jsondata(const char* value);
  void set_jsondata(const char* value, size_t size);
  std::string* mutable_jsondata();
  std::string* release_jsondata();
  void set_allocated_jsondata(std::string* jsondata);
  private:
  const std::string& _internal_jsondata() const;
  void _internal_set_jsondata(const std::string& value);
  std::string* _internal_mutable_jsondata();
  public:

  // int64 roleId = 1;
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int64 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 lv = 3;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 occupation = 4;
  void clear_occupation();
  ::PROTOBUF_NAMESPACE_ID::int32 occupation() const;
  void set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_occupation() const;
  void _internal_set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.RoleDetailedInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsondata_;
  ::PROTOBUF_NAMESPACE_ID::int64 roleid_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  ::PROTOBUF_NAMESPACE_ID::int32 occupation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class RoleSimpleInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.RoleSimpleInfo) */ {
 public:
  RoleSimpleInfo();
  virtual ~RoleSimpleInfo();

  RoleSimpleInfo(const RoleSimpleInfo& from);
  RoleSimpleInfo(RoleSimpleInfo&& from) noexcept
    : RoleSimpleInfo() {
    *this = ::std::move(from);
  }

  inline RoleSimpleInfo& operator=(const RoleSimpleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoleSimpleInfo& operator=(RoleSimpleInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RoleSimpleInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoleSimpleInfo* internal_default_instance() {
    return reinterpret_cast<const RoleSimpleInfo*>(
               &_RoleSimpleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RoleSimpleInfo& a, RoleSimpleInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoleSimpleInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RoleSimpleInfo* New() const final {
    return CreateMaybeMessage<RoleSimpleInfo>(nullptr);
  }

  RoleSimpleInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RoleSimpleInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const RoleSimpleInfo& from);
  void MergeFrom(const RoleSimpleInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoleSimpleInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.RoleSimpleInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kJsonDataFieldNumber = 5,
    kRoleIdFieldNumber = 1,
    kLvFieldNumber = 3,
    kOccupationFieldNumber = 4,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string jsonData = 5;
  void clear_jsondata();
  const std::string& jsondata() const;
  void set_jsondata(const std::string& value);
  void set_jsondata(std::string&& value);
  void set_jsondata(const char* value);
  void set_jsondata(const char* value, size_t size);
  std::string* mutable_jsondata();
  std::string* release_jsondata();
  void set_allocated_jsondata(std::string* jsondata);
  private:
  const std::string& _internal_jsondata() const;
  void _internal_set_jsondata(const std::string& value);
  std::string* _internal_mutable_jsondata();
  public:

  // int64 roleId = 1;
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int64 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 lv = 3;
  void clear_lv();
  ::PROTOBUF_NAMESPACE_ID::int32 lv() const;
  void set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lv() const;
  void _internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 occupation = 4;
  void clear_occupation();
  ::PROTOBUF_NAMESPACE_ID::int32 occupation() const;
  void set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_occupation() const;
  void _internal_set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.RoleSimpleInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsondata_;
  ::PROTOBUF_NAMESPACE_ID::int64 roleid_;
  ::PROTOBUF_NAMESPACE_ID::int32 lv_;
  ::PROTOBUF_NAMESPACE_ID::int32 occupation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class LoginReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.LoginReq) */ {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);
  LoginReq(LoginReq&& from) noexcept
    : LoginReq() {
    *this = ::std::move(from);
  }

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginReq& operator=(LoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReq* internal_default_instance() {
    return reinterpret_cast<const LoginReq*>(
               &_LoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginReq& a, LoginReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginReq* New() const final {
    return CreateMaybeMessage<LoginReq>(nullptr);
  }

  LoginReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.LoginReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LoginReq_MsgId MsgId;
  static constexpr MsgId None =
    LoginReq_MsgId_None;
  static constexpr MsgId Id =
    LoginReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return LoginReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    LoginReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    LoginReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    LoginReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return LoginReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return LoginReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kAccountFieldNumber = 2,
    kPlayerIDFieldNumber = 3,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string account = 2;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // int64 playerID = 3;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.LoginReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::int64 playerid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class LoginAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.LoginAck) */ {
 public:
  LoginAck();
  virtual ~LoginAck();

  LoginAck(const LoginAck& from);
  LoginAck(LoginAck&& from) noexcept
    : LoginAck() {
    *this = ::std::move(from);
  }

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginAck& operator=(LoginAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const LoginAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginAck* internal_default_instance() {
    return reinterpret_cast<const LoginAck*>(
               &_LoginAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginAck& a, LoginAck& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoginAck* New() const final {
    return CreateMaybeMessage<LoginAck>(nullptr);
  }

  LoginAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoginAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const LoginAck& from);
  void MergeFrom(const LoginAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.LoginAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef LoginAck_MsgId MsgId;
  static constexpr MsgId None =
    LoginAck_MsgId_None;
  static constexpr MsgId Id =
    LoginAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return LoginAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    LoginAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    LoginAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    LoginAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return LoginAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return LoginAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // repeated .msg.PlayerAccountInfo infos = 2;
  int infos_size() const;
  private:
  int _internal_infos_size() const;
  public:
  void clear_infos();
  ::msg::PlayerAccountInfo* mutable_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerAccountInfo >*
      mutable_infos();
  private:
  const ::msg::PlayerAccountInfo& _internal_infos(int index) const;
  ::msg::PlayerAccountInfo* _internal_add_infos();
  public:
  const ::msg::PlayerAccountInfo& infos(int index) const;
  ::msg::PlayerAccountInfo* add_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerAccountInfo >&
      infos() const;

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.LoginAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerAccountInfo > infos_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class EnterGameReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.EnterGameReq) */ {
 public:
  EnterGameReq();
  virtual ~EnterGameReq();

  EnterGameReq(const EnterGameReq& from);
  EnterGameReq(EnterGameReq&& from) noexcept
    : EnterGameReq() {
    *this = ::std::move(from);
  }

  inline EnterGameReq& operator=(const EnterGameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterGameReq& operator=(EnterGameReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EnterGameReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterGameReq* internal_default_instance() {
    return reinterpret_cast<const EnterGameReq*>(
               &_EnterGameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(EnterGameReq& a, EnterGameReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterGameReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterGameReq* New() const final {
    return CreateMaybeMessage<EnterGameReq>(nullptr);
  }

  EnterGameReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterGameReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const EnterGameReq& from);
  void MergeFrom(const EnterGameReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnterGameReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.EnterGameReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EnterGameReq_MsgId MsgId;
  static constexpr MsgId None =
    EnterGameReq_MsgId_None;
  static constexpr MsgId Id =
    EnterGameReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return EnterGameReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    EnterGameReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    EnterGameReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    EnterGameReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return EnterGameReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return EnterGameReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPlayerIDFieldNumber = 2,
    kRoleIDFieldNumber = 3,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 playerID = 2;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int64 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 roleID = 3;
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int64 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.EnterGameReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::int64 playerid_;
  ::PROTOBUF_NAMESPACE_ID::int64 roleid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class EnterGameAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.EnterGameAck) */ {
 public:
  EnterGameAck();
  virtual ~EnterGameAck();

  EnterGameAck(const EnterGameAck& from);
  EnterGameAck(EnterGameAck&& from) noexcept
    : EnterGameAck() {
    *this = ::std::move(from);
  }

  inline EnterGameAck& operator=(const EnterGameAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnterGameAck& operator=(EnterGameAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const EnterGameAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterGameAck* internal_default_instance() {
    return reinterpret_cast<const EnterGameAck*>(
               &_EnterGameAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EnterGameAck& a, EnterGameAck& b) {
    a.Swap(&b);
  }
  inline void Swap(EnterGameAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnterGameAck* New() const final {
    return CreateMaybeMessage<EnterGameAck>(nullptr);
  }

  EnterGameAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnterGameAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const EnterGameAck& from);
  void MergeFrom(const EnterGameAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnterGameAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.EnterGameAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EnterGameAck_MsgId MsgId;
  static constexpr MsgId None =
    EnterGameAck_MsgId_None;
  static constexpr MsgId Id =
    EnterGameAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return EnterGameAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    EnterGameAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    EnterGameAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    EnterGameAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return EnterGameAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return EnterGameAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoleinfoFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // .msg.RoleDetailedInfo roleinfo = 2;
  bool has_roleinfo() const;
  private:
  bool _internal_has_roleinfo() const;
  public:
  void clear_roleinfo();
  const ::msg::RoleDetailedInfo& roleinfo() const;
  ::msg::RoleDetailedInfo* release_roleinfo();
  ::msg::RoleDetailedInfo* mutable_roleinfo();
  void set_allocated_roleinfo(::msg::RoleDetailedInfo* roleinfo);
  private:
  const ::msg::RoleDetailedInfo& _internal_roleinfo() const;
  ::msg::RoleDetailedInfo* _internal_mutable_roleinfo();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.EnterGameAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::msg::RoleDetailedInfo* roleinfo_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class CreateRoleReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.CreateRoleReq) */ {
 public:
  CreateRoleReq();
  virtual ~CreateRoleReq();

  CreateRoleReq(const CreateRoleReq& from);
  CreateRoleReq(CreateRoleReq&& from) noexcept
    : CreateRoleReq() {
    *this = ::std::move(from);
  }

  inline CreateRoleReq& operator=(const CreateRoleReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoleReq& operator=(CreateRoleReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CreateRoleReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoleReq* internal_default_instance() {
    return reinterpret_cast<const CreateRoleReq*>(
               &_CreateRoleReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreateRoleReq& a, CreateRoleReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoleReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRoleReq* New() const final {
    return CreateMaybeMessage<CreateRoleReq>(nullptr);
  }

  CreateRoleReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRoleReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CreateRoleReq& from);
  void MergeFrom(const CreateRoleReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateRoleReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.CreateRoleReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CreateRoleReq_MsgId MsgId;
  static constexpr MsgId None =
    CreateRoleReq_MsgId_None;
  static constexpr MsgId Id =
    CreateRoleReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return CreateRoleReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    CreateRoleReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    CreateRoleReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    CreateRoleReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return CreateRoleReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return CreateRoleReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kOccupationFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 occupation = 1;
  void clear_occupation();
  ::PROTOBUF_NAMESPACE_ID::int32 occupation() const;
  void set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_occupation() const;
  void _internal_set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.CreateRoleReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 occupation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class CreateRoleAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.CreateRoleAck) */ {
 public:
  CreateRoleAck();
  virtual ~CreateRoleAck();

  CreateRoleAck(const CreateRoleAck& from);
  CreateRoleAck(CreateRoleAck&& from) noexcept
    : CreateRoleAck() {
    *this = ::std::move(from);
  }

  inline CreateRoleAck& operator=(const CreateRoleAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateRoleAck& operator=(CreateRoleAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CreateRoleAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoleAck* internal_default_instance() {
    return reinterpret_cast<const CreateRoleAck*>(
               &_CreateRoleAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CreateRoleAck& a, CreateRoleAck& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateRoleAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateRoleAck* New() const final {
    return CreateMaybeMessage<CreateRoleAck>(nullptr);
  }

  CreateRoleAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateRoleAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CreateRoleAck& from);
  void MergeFrom(const CreateRoleAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateRoleAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.CreateRoleAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CreateRoleAck_MsgId MsgId;
  static constexpr MsgId None =
    CreateRoleAck_MsgId_None;
  static constexpr MsgId Id =
    CreateRoleAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return CreateRoleAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    CreateRoleAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    CreateRoleAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    CreateRoleAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return CreateRoleAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return CreateRoleAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIDFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // int64 roleID = 2;
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int64 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.CreateRoleAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 roleid_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class ModifyRoleDataReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.ModifyRoleDataReq) */ {
 public:
  ModifyRoleDataReq();
  virtual ~ModifyRoleDataReq();

  ModifyRoleDataReq(const ModifyRoleDataReq& from);
  ModifyRoleDataReq(ModifyRoleDataReq&& from) noexcept
    : ModifyRoleDataReq() {
    *this = ::std::move(from);
  }

  inline ModifyRoleDataReq& operator=(const ModifyRoleDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyRoleDataReq& operator=(ModifyRoleDataReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ModifyRoleDataReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModifyRoleDataReq* internal_default_instance() {
    return reinterpret_cast<const ModifyRoleDataReq*>(
               &_ModifyRoleDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ModifyRoleDataReq& a, ModifyRoleDataReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyRoleDataReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModifyRoleDataReq* New() const final {
    return CreateMaybeMessage<ModifyRoleDataReq>(nullptr);
  }

  ModifyRoleDataReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModifyRoleDataReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ModifyRoleDataReq& from);
  void MergeFrom(const ModifyRoleDataReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModifyRoleDataReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ModifyRoleDataReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ModifyRoleDataReq_MsgId MsgId;
  static constexpr MsgId None =
    ModifyRoleDataReq_MsgId_None;
  static constexpr MsgId Id =
    ModifyRoleDataReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return ModifyRoleDataReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    ModifyRoleDataReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    ModifyRoleDataReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    ModifyRoleDataReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return ModifyRoleDataReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return ModifyRoleDataReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kJsonDataFieldNumber = 2,
    kNameFieldNumber = 3,
    kRoleIdFieldNumber = 1,
  };
  // string jsonData = 2;
  void clear_jsondata();
  const std::string& jsondata() const;
  void set_jsondata(const std::string& value);
  void set_jsondata(std::string&& value);
  void set_jsondata(const char* value);
  void set_jsondata(const char* value, size_t size);
  std::string* mutable_jsondata();
  std::string* release_jsondata();
  void set_allocated_jsondata(std::string* jsondata);
  private:
  const std::string& _internal_jsondata() const;
  void _internal_set_jsondata(const std::string& value);
  std::string* _internal_mutable_jsondata();
  public:

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 roleId = 1;
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int64 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ModifyRoleDataReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsondata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 roleid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class ModifyRoleDataAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.ModifyRoleDataAck) */ {
 public:
  ModifyRoleDataAck();
  virtual ~ModifyRoleDataAck();

  ModifyRoleDataAck(const ModifyRoleDataAck& from);
  ModifyRoleDataAck(ModifyRoleDataAck&& from) noexcept
    : ModifyRoleDataAck() {
    *this = ::std::move(from);
  }

  inline ModifyRoleDataAck& operator=(const ModifyRoleDataAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModifyRoleDataAck& operator=(ModifyRoleDataAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ModifyRoleDataAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModifyRoleDataAck* internal_default_instance() {
    return reinterpret_cast<const ModifyRoleDataAck*>(
               &_ModifyRoleDataAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ModifyRoleDataAck& a, ModifyRoleDataAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ModifyRoleDataAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModifyRoleDataAck* New() const final {
    return CreateMaybeMessage<ModifyRoleDataAck>(nullptr);
  }

  ModifyRoleDataAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModifyRoleDataAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ModifyRoleDataAck& from);
  void MergeFrom(const ModifyRoleDataAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModifyRoleDataAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ModifyRoleDataAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ModifyRoleDataAck_MsgId MsgId;
  static constexpr MsgId None =
    ModifyRoleDataAck_MsgId_None;
  static constexpr MsgId Id =
    ModifyRoleDataAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return ModifyRoleDataAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    ModifyRoleDataAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    ModifyRoleDataAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    ModifyRoleDataAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return ModifyRoleDataAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return ModifyRoleDataAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ModifyRoleDataAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class ExitGameNtf :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.ExitGameNtf) */ {
 public:
  ExitGameNtf();
  virtual ~ExitGameNtf();

  ExitGameNtf(const ExitGameNtf& from);
  ExitGameNtf(ExitGameNtf&& from) noexcept
    : ExitGameNtf() {
    *this = ::std::move(from);
  }

  inline ExitGameNtf& operator=(const ExitGameNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExitGameNtf& operator=(ExitGameNtf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ExitGameNtf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExitGameNtf* internal_default_instance() {
    return reinterpret_cast<const ExitGameNtf*>(
               &_ExitGameNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ExitGameNtf& a, ExitGameNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(ExitGameNtf* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExitGameNtf* New() const final {
    return CreateMaybeMessage<ExitGameNtf>(nullptr);
  }

  ExitGameNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExitGameNtf>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const ExitGameNtf& from);
  void MergeFrom(const ExitGameNtf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExitGameNtf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.ExitGameNtf";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ExitGameNtf_MsgId MsgId;
  static constexpr MsgId None =
    ExitGameNtf_MsgId_None;
  static constexpr MsgId Id =
    ExitGameNtf_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return ExitGameNtf_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    ExitGameNtf_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    ExitGameNtf_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    ExitGameNtf_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return ExitGameNtf_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return ExitGameNtf_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.ExitGameNtf)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class PVEFightInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PVEFightInfo) */ {
 public:
  PVEFightInfo();
  virtual ~PVEFightInfo();

  PVEFightInfo(const PVEFightInfo& from);
  PVEFightInfo(PVEFightInfo&& from) noexcept
    : PVEFightInfo() {
    *this = ::std::move(from);
  }

  inline PVEFightInfo& operator=(const PVEFightInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PVEFightInfo& operator=(PVEFightInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PVEFightInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PVEFightInfo* internal_default_instance() {
    return reinterpret_cast<const PVEFightInfo*>(
               &_PVEFightInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PVEFightInfo& a, PVEFightInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PVEFightInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PVEFightInfo* New() const final {
    return CreateMaybeMessage<PVEFightInfo>(nullptr);
  }

  PVEFightInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PVEFightInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PVEFightInfo& from);
  void MergeFrom(const PVEFightInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PVEFightInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PVEFightInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
  };
  // int64 roleId = 1;
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int64 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.PVEFightInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 roleid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class StartPVEFightReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.StartPVEFightReq) */ {
 public:
  StartPVEFightReq();
  virtual ~StartPVEFightReq();

  StartPVEFightReq(const StartPVEFightReq& from);
  StartPVEFightReq(StartPVEFightReq&& from) noexcept
    : StartPVEFightReq() {
    *this = ::std::move(from);
  }

  inline StartPVEFightReq& operator=(const StartPVEFightReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartPVEFightReq& operator=(StartPVEFightReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StartPVEFightReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartPVEFightReq* internal_default_instance() {
    return reinterpret_cast<const StartPVEFightReq*>(
               &_StartPVEFightReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StartPVEFightReq& a, StartPVEFightReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StartPVEFightReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartPVEFightReq* New() const final {
    return CreateMaybeMessage<StartPVEFightReq>(nullptr);
  }

  StartPVEFightReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartPVEFightReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StartPVEFightReq& from);
  void MergeFrom(const StartPVEFightReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartPVEFightReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.StartPVEFightReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StartPVEFightReq_MsgId MsgId;
  static constexpr MsgId None =
    StartPVEFightReq_MsgId_None;
  static constexpr MsgId Id =
    StartPVEFightReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return StartPVEFightReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    StartPVEFightReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    StartPVEFightReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    StartPVEFightReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return StartPVEFightReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return StartPVEFightReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 3,
    kCarbonIdFieldNumber = 1,
    kIsOfflineModeFieldNumber = 2,
  };
  // repeated .msg.PVEFightInfo roles = 3;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::msg::PVEFightInfo* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PVEFightInfo >*
      mutable_roles();
  private:
  const ::msg::PVEFightInfo& _internal_roles(int index) const;
  ::msg::PVEFightInfo* _internal_add_roles();
  public:
  const ::msg::PVEFightInfo& roles(int index) const;
  ::msg::PVEFightInfo* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PVEFightInfo >&
      roles() const;

  // int32 carbonId = 1;
  void clear_carbonid();
  ::PROTOBUF_NAMESPACE_ID::int32 carbonid() const;
  void set_carbonid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_carbonid() const;
  void _internal_set_carbonid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isOfflineMode = 2;
  void clear_isofflinemode();
  bool isofflinemode() const;
  void set_isofflinemode(bool value);
  private:
  bool _internal_isofflinemode() const;
  void _internal_set_isofflinemode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:msg.StartPVEFightReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PVEFightInfo > roles_;
  ::PROTOBUF_NAMESPACE_ID::int32 carbonid_;
  bool isofflinemode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class StartPVEFightAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.StartPVEFightAck) */ {
 public:
  StartPVEFightAck();
  virtual ~StartPVEFightAck();

  StartPVEFightAck(const StartPVEFightAck& from);
  StartPVEFightAck(StartPVEFightAck&& from) noexcept
    : StartPVEFightAck() {
    *this = ::std::move(from);
  }

  inline StartPVEFightAck& operator=(const StartPVEFightAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartPVEFightAck& operator=(StartPVEFightAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StartPVEFightAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartPVEFightAck* internal_default_instance() {
    return reinterpret_cast<const StartPVEFightAck*>(
               &_StartPVEFightAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StartPVEFightAck& a, StartPVEFightAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StartPVEFightAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartPVEFightAck* New() const final {
    return CreateMaybeMessage<StartPVEFightAck>(nullptr);
  }

  StartPVEFightAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartPVEFightAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StartPVEFightAck& from);
  void MergeFrom(const StartPVEFightAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartPVEFightAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.StartPVEFightAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StartPVEFightAck_MsgId MsgId;
  static constexpr MsgId None =
    StartPVEFightAck_MsgId_None;
  static constexpr MsgId Id =
    StartPVEFightAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return StartPVEFightAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    StartPVEFightAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    StartPVEFightAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    StartPVEFightAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return StartPVEFightAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return StartPVEFightAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.StartPVEFightAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class StartPVPFightReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.StartPVPFightReq) */ {
 public:
  StartPVPFightReq();
  virtual ~StartPVPFightReq();

  StartPVPFightReq(const StartPVPFightReq& from);
  StartPVPFightReq(StartPVPFightReq&& from) noexcept
    : StartPVPFightReq() {
    *this = ::std::move(from);
  }

  inline StartPVPFightReq& operator=(const StartPVPFightReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartPVPFightReq& operator=(StartPVPFightReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StartPVPFightReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartPVPFightReq* internal_default_instance() {
    return reinterpret_cast<const StartPVPFightReq*>(
               &_StartPVPFightReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StartPVPFightReq& a, StartPVPFightReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StartPVPFightReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartPVPFightReq* New() const final {
    return CreateMaybeMessage<StartPVPFightReq>(nullptr);
  }

  StartPVPFightReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartPVPFightReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StartPVPFightReq& from);
  void MergeFrom(const StartPVPFightReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartPVPFightReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.StartPVPFightReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StartPVPFightReq_MsgId MsgId;
  static constexpr MsgId None =
    StartPVPFightReq_MsgId_None;
  static constexpr MsgId Id =
    StartPVPFightReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return StartPVPFightReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    StartPVPFightReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    StartPVPFightReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    StartPVPFightReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return StartPVPFightReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return StartPVPFightReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFoeIdFieldNumber = 1,
  };
  // int64 foeId = 1;
  void clear_foeid();
  ::PROTOBUF_NAMESPACE_ID::int64 foeid() const;
  void set_foeid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_foeid() const;
  void _internal_set_foeid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.StartPVPFightReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 foeid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class StartPVPFightAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.StartPVPFightAck) */ {
 public:
  StartPVPFightAck();
  virtual ~StartPVPFightAck();

  StartPVPFightAck(const StartPVPFightAck& from);
  StartPVPFightAck(StartPVPFightAck&& from) noexcept
    : StartPVPFightAck() {
    *this = ::std::move(from);
  }

  inline StartPVPFightAck& operator=(const StartPVPFightAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartPVPFightAck& operator=(StartPVPFightAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StartPVPFightAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartPVPFightAck* internal_default_instance() {
    return reinterpret_cast<const StartPVPFightAck*>(
               &_StartPVPFightAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StartPVPFightAck& a, StartPVPFightAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StartPVPFightAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartPVPFightAck* New() const final {
    return CreateMaybeMessage<StartPVPFightAck>(nullptr);
  }

  StartPVPFightAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartPVPFightAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StartPVPFightAck& from);
  void MergeFrom(const StartPVPFightAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartPVPFightAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.StartPVPFightAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StartPVPFightAck_MsgId MsgId;
  static constexpr MsgId None =
    StartPVPFightAck_MsgId_None;
  static constexpr MsgId Id =
    StartPVPFightAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return StartPVPFightAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    StartPVPFightAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    StartPVPFightAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    StartPVPFightAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return StartPVPFightAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return StartPVPFightAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.StartPVPFightAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class StopPVPMatchReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.StopPVPMatchReq) */ {
 public:
  StopPVPMatchReq();
  virtual ~StopPVPMatchReq();

  StopPVPMatchReq(const StopPVPMatchReq& from);
  StopPVPMatchReq(StopPVPMatchReq&& from) noexcept
    : StopPVPMatchReq() {
    *this = ::std::move(from);
  }

  inline StopPVPMatchReq& operator=(const StopPVPMatchReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPVPMatchReq& operator=(StopPVPMatchReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StopPVPMatchReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopPVPMatchReq* internal_default_instance() {
    return reinterpret_cast<const StopPVPMatchReq*>(
               &_StopPVPMatchReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StopPVPMatchReq& a, StopPVPMatchReq& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPVPMatchReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopPVPMatchReq* New() const final {
    return CreateMaybeMessage<StopPVPMatchReq>(nullptr);
  }

  StopPVPMatchReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopPVPMatchReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StopPVPMatchReq& from);
  void MergeFrom(const StopPVPMatchReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopPVPMatchReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.StopPVPMatchReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StopPVPMatchReq_MsgId MsgId;
  static constexpr MsgId None =
    StopPVPMatchReq_MsgId_None;
  static constexpr MsgId Id =
    StopPVPMatchReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return StopPVPMatchReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    StopPVPMatchReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    StopPVPMatchReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    StopPVPMatchReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return StopPVPMatchReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return StopPVPMatchReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.StopPVPMatchReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class StopPVPMatchAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.StopPVPMatchAck) */ {
 public:
  StopPVPMatchAck();
  virtual ~StopPVPMatchAck();

  StopPVPMatchAck(const StopPVPMatchAck& from);
  StopPVPMatchAck(StopPVPMatchAck&& from) noexcept
    : StopPVPMatchAck() {
    *this = ::std::move(from);
  }

  inline StopPVPMatchAck& operator=(const StopPVPMatchAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPVPMatchAck& operator=(StopPVPMatchAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StopPVPMatchAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopPVPMatchAck* internal_default_instance() {
    return reinterpret_cast<const StopPVPMatchAck*>(
               &_StopPVPMatchAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StopPVPMatchAck& a, StopPVPMatchAck& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPVPMatchAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopPVPMatchAck* New() const final {
    return CreateMaybeMessage<StopPVPMatchAck>(nullptr);
  }

  StopPVPMatchAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopPVPMatchAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StopPVPMatchAck& from);
  void MergeFrom(const StopPVPMatchAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopPVPMatchAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.StopPVPMatchAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StopPVPMatchAck_MsgId MsgId;
  static constexpr MsgId None =
    StopPVPMatchAck_MsgId_None;
  static constexpr MsgId Id =
    StopPVPMatchAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return StopPVPMatchAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    StopPVPMatchAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    StopPVPMatchAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    StopPVPMatchAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return StopPVPMatchAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return StopPVPMatchAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
  };
  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.StopPVPMatchAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class StartFightNTF :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.StartFightNTF) */ {
 public:
  StartFightNTF();
  virtual ~StartFightNTF();

  StartFightNTF(const StartFightNTF& from);
  StartFightNTF(StartFightNTF&& from) noexcept
    : StartFightNTF() {
    *this = ::std::move(from);
  }

  inline StartFightNTF& operator=(const StartFightNTF& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartFightNTF& operator=(StartFightNTF&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StartFightNTF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StartFightNTF* internal_default_instance() {
    return reinterpret_cast<const StartFightNTF*>(
               &_StartFightNTF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StartFightNTF& a, StartFightNTF& b) {
    a.Swap(&b);
  }
  inline void Swap(StartFightNTF* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StartFightNTF* New() const final {
    return CreateMaybeMessage<StartFightNTF>(nullptr);
  }

  StartFightNTF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StartFightNTF>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const StartFightNTF& from);
  void MergeFrom(const StartFightNTF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartFightNTF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.StartFightNTF";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StartFightNTF_MsgId MsgId;
  static constexpr MsgId None =
    StartFightNTF_MsgId_None;
  static constexpr MsgId Id =
    StartFightNTF_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return StartFightNTF_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    StartFightNTF_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    StartFightNTF_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    StartFightNTF_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return StartFightNTF_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return StartFightNTF_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFightIPFieldNumber = 3,
    kCodeFieldNumber = 1,
    kFightUUIDFieldNumber = 2,
    kFightPortFieldNumber = 4,
    kNetTypeFieldNumber = 5,
  };
  // string fightIP = 3;
  void clear_fightip();
  const std::string& fightip() const;
  void set_fightip(const std::string& value);
  void set_fightip(std::string&& value);
  void set_fightip(const char* value);
  void set_fightip(const char* value, size_t size);
  std::string* mutable_fightip();
  std::string* release_fightip();
  void set_allocated_fightip(std::string* fightip);
  private:
  const std::string& _internal_fightip() const;
  void _internal_set_fightip(const std::string& value);
  std::string* _internal_mutable_fightip();
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 fightUUID = 2;
  void clear_fightuuid();
  ::PROTOBUF_NAMESPACE_ID::int32 fightuuid() const;
  void set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fightuuid() const;
  void _internal_set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 fightPort = 4;
  void clear_fightport();
  ::PROTOBUF_NAMESPACE_ID::int32 fightport() const;
  void set_fightport(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fightport() const;
  void _internal_set_fightport(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 netType = 5;
  void clear_nettype();
  ::PROTOBUF_NAMESPACE_ID::int32 nettype() const;
  void set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nettype() const;
  void _internal_set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:msg.StartFightNTF)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fightip_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 fightuuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 fightport_;
  ::PROTOBUF_NAMESPACE_ID::int32 nettype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// -------------------------------------------------------------------

class PushRoleData :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:msg.PushRoleData) */ {
 public:
  PushRoleData();
  virtual ~PushRoleData();

  PushRoleData(const PushRoleData& from);
  PushRoleData(PushRoleData&& from) noexcept
    : PushRoleData() {
    *this = ::std::move(from);
  }

  inline PushRoleData& operator=(const PushRoleData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushRoleData& operator=(PushRoleData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PushRoleData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PushRoleData* internal_default_instance() {
    return reinterpret_cast<const PushRoleData*>(
               &_PushRoleData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PushRoleData& a, PushRoleData& b) {
    a.Swap(&b);
  }
  inline void Swap(PushRoleData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PushRoleData* New() const final {
    return CreateMaybeMessage<PushRoleData>(nullptr);
  }

  PushRoleData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PushRoleData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const PushRoleData& from);
  void MergeFrom(const PushRoleData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushRoleData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "msg.PushRoleData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PushRoleData_MsgId MsgId;
  static constexpr MsgId None =
    PushRoleData_MsgId_None;
  static constexpr MsgId Id =
    PushRoleData_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return PushRoleData_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    PushRoleData_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    PushRoleData_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    PushRoleData_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return PushRoleData_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return PushRoleData_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // .msg.RoleSimpleInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::msg::RoleSimpleInfo& info() const;
  ::msg::RoleSimpleInfo* release_info();
  ::msg::RoleSimpleInfo* mutable_info();
  void set_allocated_info(::msg::RoleSimpleInfo* info);
  private:
  const ::msg::RoleSimpleInfo& _internal_info() const;
  ::msg::RoleSimpleInfo* _internal_mutable_info();
  public:

  // @@protoc_insertion_point(class_scope:msg.PushRoleData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::msg::RoleSimpleInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_C2Game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerAccountInfo

// int64 playerID = 1;
inline void PlayerAccountInfo::clear_playerid() {
  playerid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerAccountInfo::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerAccountInfo::playerid() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAccountInfo.playerID)
  return _internal_playerid();
}
inline void PlayerAccountInfo::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  playerid_ = value;
}
inline void PlayerAccountInfo::set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAccountInfo.playerID)
}

// string name = 2;
inline void PlayerAccountInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PlayerAccountInfo::name() const {
  // @@protoc_insertion_point(field_get:msg.PlayerAccountInfo.name)
  return _internal_name();
}
inline void PlayerAccountInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:msg.PlayerAccountInfo.name)
}
inline std::string* PlayerAccountInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:msg.PlayerAccountInfo.name)
  return _internal_mutable_name();
}
inline const std::string& PlayerAccountInfo::_internal_name() const {
  return name_.GetNoArena();
}
inline void PlayerAccountInfo::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PlayerAccountInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.PlayerAccountInfo.name)
}
inline void PlayerAccountInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.PlayerAccountInfo.name)
}
inline void PlayerAccountInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.PlayerAccountInfo.name)
}
inline std::string* PlayerAccountInfo::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PlayerAccountInfo::release_name() {
  // @@protoc_insertion_point(field_release:msg.PlayerAccountInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerAccountInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.PlayerAccountInfo.name)
}

// repeated int64 arrRoleIds = 3;
inline int PlayerAccountInfo::_internal_arrroleids_size() const {
  return arrroleids_.size();
}
inline int PlayerAccountInfo::arrroleids_size() const {
  return _internal_arrroleids_size();
}
inline void PlayerAccountInfo::clear_arrroleids() {
  arrroleids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerAccountInfo::_internal_arrroleids(int index) const {
  return arrroleids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PlayerAccountInfo::arrroleids(int index) const {
  // @@protoc_insertion_point(field_get:msg.PlayerAccountInfo.arrRoleIds)
  return _internal_arrroleids(index);
}
inline void PlayerAccountInfo::set_arrroleids(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  arrroleids_.Set(index, value);
  // @@protoc_insertion_point(field_set:msg.PlayerAccountInfo.arrRoleIds)
}
inline void PlayerAccountInfo::_internal_add_arrroleids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  arrroleids_.Add(value);
}
inline void PlayerAccountInfo::add_arrroleids(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_arrroleids(value);
  // @@protoc_insertion_point(field_add:msg.PlayerAccountInfo.arrRoleIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlayerAccountInfo::_internal_arrroleids() const {
  return arrroleids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
PlayerAccountInfo::arrroleids() const {
  // @@protoc_insertion_point(field_list:msg.PlayerAccountInfo.arrRoleIds)
  return _internal_arrroleids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlayerAccountInfo::_internal_mutable_arrroleids() {
  return &arrroleids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
PlayerAccountInfo::mutable_arrroleids() {
  // @@protoc_insertion_point(field_mutable_list:msg.PlayerAccountInfo.arrRoleIds)
  return _internal_mutable_arrroleids();
}

// -------------------------------------------------------------------

// RoleDetailedInfo

// int64 roleId = 1;
inline void RoleDetailedInfo::clear_roleid() {
  roleid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RoleDetailedInfo::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RoleDetailedInfo::roleid() const {
  // @@protoc_insertion_point(field_get:msg.RoleDetailedInfo.roleId)
  return _internal_roleid();
}
inline void RoleDetailedInfo::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  roleid_ = value;
}
inline void RoleDetailedInfo::set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:msg.RoleDetailedInfo.roleId)
}

// string name = 2;
inline void RoleDetailedInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoleDetailedInfo::name() const {
  // @@protoc_insertion_point(field_get:msg.RoleDetailedInfo.name)
  return _internal_name();
}
inline void RoleDetailedInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:msg.RoleDetailedInfo.name)
}
inline std::string* RoleDetailedInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:msg.RoleDetailedInfo.name)
  return _internal_mutable_name();
}
inline const std::string& RoleDetailedInfo::_internal_name() const {
  return name_.GetNoArena();
}
inline void RoleDetailedInfo::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RoleDetailedInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.RoleDetailedInfo.name)
}
inline void RoleDetailedInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.RoleDetailedInfo.name)
}
inline void RoleDetailedInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.RoleDetailedInfo.name)
}
inline std::string* RoleDetailedInfo::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoleDetailedInfo::release_name() {
  // @@protoc_insertion_point(field_release:msg.RoleDetailedInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoleDetailedInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.RoleDetailedInfo.name)
}

// int32 lv = 3;
inline void RoleDetailedInfo::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleDetailedInfo::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleDetailedInfo::lv() const {
  // @@protoc_insertion_point(field_get:msg.RoleDetailedInfo.lv)
  return _internal_lv();
}
inline void RoleDetailedInfo::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void RoleDetailedInfo::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:msg.RoleDetailedInfo.lv)
}

// int32 occupation = 4;
inline void RoleDetailedInfo::clear_occupation() {
  occupation_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleDetailedInfo::_internal_occupation() const {
  return occupation_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleDetailedInfo::occupation() const {
  // @@protoc_insertion_point(field_get:msg.RoleDetailedInfo.occupation)
  return _internal_occupation();
}
inline void RoleDetailedInfo::_internal_set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  occupation_ = value;
}
inline void RoleDetailedInfo::set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_occupation(value);
  // @@protoc_insertion_point(field_set:msg.RoleDetailedInfo.occupation)
}

// string jsonData = 5;
inline void RoleDetailedInfo::clear_jsondata() {
  jsondata_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoleDetailedInfo::jsondata() const {
  // @@protoc_insertion_point(field_get:msg.RoleDetailedInfo.jsonData)
  return _internal_jsondata();
}
inline void RoleDetailedInfo::set_jsondata(const std::string& value) {
  _internal_set_jsondata(value);
  // @@protoc_insertion_point(field_set:msg.RoleDetailedInfo.jsonData)
}
inline std::string* RoleDetailedInfo::mutable_jsondata() {
  // @@protoc_insertion_point(field_mutable:msg.RoleDetailedInfo.jsonData)
  return _internal_mutable_jsondata();
}
inline const std::string& RoleDetailedInfo::_internal_jsondata() const {
  return jsondata_.GetNoArena();
}
inline void RoleDetailedInfo::_internal_set_jsondata(const std::string& value) {
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RoleDetailedInfo::set_jsondata(std::string&& value) {
  
  jsondata_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.RoleDetailedInfo.jsonData)
}
inline void RoleDetailedInfo::set_jsondata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.RoleDetailedInfo.jsonData)
}
inline void RoleDetailedInfo::set_jsondata(const char* value, size_t size) {
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.RoleDetailedInfo.jsonData)
}
inline std::string* RoleDetailedInfo::_internal_mutable_jsondata() {
  
  return jsondata_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoleDetailedInfo::release_jsondata() {
  // @@protoc_insertion_point(field_release:msg.RoleDetailedInfo.jsonData)
  
  return jsondata_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoleDetailedInfo::set_allocated_jsondata(std::string* jsondata) {
  if (jsondata != nullptr) {
    
  } else {
    
  }
  jsondata_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jsondata);
  // @@protoc_insertion_point(field_set_allocated:msg.RoleDetailedInfo.jsonData)
}

// -------------------------------------------------------------------

// RoleSimpleInfo

// int64 roleId = 1;
inline void RoleSimpleInfo::clear_roleid() {
  roleid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RoleSimpleInfo::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RoleSimpleInfo::roleid() const {
  // @@protoc_insertion_point(field_get:msg.RoleSimpleInfo.roleId)
  return _internal_roleid();
}
inline void RoleSimpleInfo::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  roleid_ = value;
}
inline void RoleSimpleInfo::set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:msg.RoleSimpleInfo.roleId)
}

// string name = 2;
inline void RoleSimpleInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoleSimpleInfo::name() const {
  // @@protoc_insertion_point(field_get:msg.RoleSimpleInfo.name)
  return _internal_name();
}
inline void RoleSimpleInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:msg.RoleSimpleInfo.name)
}
inline std::string* RoleSimpleInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:msg.RoleSimpleInfo.name)
  return _internal_mutable_name();
}
inline const std::string& RoleSimpleInfo::_internal_name() const {
  return name_.GetNoArena();
}
inline void RoleSimpleInfo::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RoleSimpleInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.RoleSimpleInfo.name)
}
inline void RoleSimpleInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.RoleSimpleInfo.name)
}
inline void RoleSimpleInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.RoleSimpleInfo.name)
}
inline std::string* RoleSimpleInfo::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoleSimpleInfo::release_name() {
  // @@protoc_insertion_point(field_release:msg.RoleSimpleInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoleSimpleInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.RoleSimpleInfo.name)
}

// int32 lv = 3;
inline void RoleSimpleInfo::clear_lv() {
  lv_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleSimpleInfo::_internal_lv() const {
  return lv_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleSimpleInfo::lv() const {
  // @@protoc_insertion_point(field_get:msg.RoleSimpleInfo.lv)
  return _internal_lv();
}
inline void RoleSimpleInfo::_internal_set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lv_ = value;
}
inline void RoleSimpleInfo::set_lv(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lv(value);
  // @@protoc_insertion_point(field_set:msg.RoleSimpleInfo.lv)
}

// int32 occupation = 4;
inline void RoleSimpleInfo::clear_occupation() {
  occupation_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleSimpleInfo::_internal_occupation() const {
  return occupation_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RoleSimpleInfo::occupation() const {
  // @@protoc_insertion_point(field_get:msg.RoleSimpleInfo.occupation)
  return _internal_occupation();
}
inline void RoleSimpleInfo::_internal_set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  occupation_ = value;
}
inline void RoleSimpleInfo::set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_occupation(value);
  // @@protoc_insertion_point(field_set:msg.RoleSimpleInfo.occupation)
}

// string jsonData = 5;
inline void RoleSimpleInfo::clear_jsondata() {
  jsondata_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& RoleSimpleInfo::jsondata() const {
  // @@protoc_insertion_point(field_get:msg.RoleSimpleInfo.jsonData)
  return _internal_jsondata();
}
inline void RoleSimpleInfo::set_jsondata(const std::string& value) {
  _internal_set_jsondata(value);
  // @@protoc_insertion_point(field_set:msg.RoleSimpleInfo.jsonData)
}
inline std::string* RoleSimpleInfo::mutable_jsondata() {
  // @@protoc_insertion_point(field_mutable:msg.RoleSimpleInfo.jsonData)
  return _internal_mutable_jsondata();
}
inline const std::string& RoleSimpleInfo::_internal_jsondata() const {
  return jsondata_.GetNoArena();
}
inline void RoleSimpleInfo::_internal_set_jsondata(const std::string& value) {
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void RoleSimpleInfo::set_jsondata(std::string&& value) {
  
  jsondata_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.RoleSimpleInfo.jsonData)
}
inline void RoleSimpleInfo::set_jsondata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.RoleSimpleInfo.jsonData)
}
inline void RoleSimpleInfo::set_jsondata(const char* value, size_t size) {
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.RoleSimpleInfo.jsonData)
}
inline std::string* RoleSimpleInfo::_internal_mutable_jsondata() {
  
  return jsondata_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RoleSimpleInfo::release_jsondata() {
  // @@protoc_insertion_point(field_release:msg.RoleSimpleInfo.jsonData)
  
  return jsondata_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RoleSimpleInfo::set_allocated_jsondata(std::string* jsondata) {
  if (jsondata != nullptr) {
    
  } else {
    
  }
  jsondata_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jsondata);
  // @@protoc_insertion_point(field_set_allocated:msg.RoleSimpleInfo.jsonData)
}

// -------------------------------------------------------------------

// LoginReq

// string token = 1;
inline void LoginReq::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginReq::token() const {
  // @@protoc_insertion_point(field_get:msg.LoginReq.token)
  return _internal_token();
}
inline void LoginReq::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:msg.LoginReq.token)
}
inline std::string* LoginReq::mutable_token() {
  // @@protoc_insertion_point(field_mutable:msg.LoginReq.token)
  return _internal_mutable_token();
}
inline const std::string& LoginReq::_internal_token() const {
  return token_.GetNoArena();
}
inline void LoginReq::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoginReq::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.LoginReq.token)
}
inline void LoginReq::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.LoginReq.token)
}
inline void LoginReq::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.LoginReq.token)
}
inline std::string* LoginReq::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginReq::release_token() {
  // @@protoc_insertion_point(field_release:msg.LoginReq.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:msg.LoginReq.token)
}

// string account = 2;
inline void LoginReq::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LoginReq::account() const {
  // @@protoc_insertion_point(field_get:msg.LoginReq.account)
  return _internal_account();
}
inline void LoginReq::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:msg.LoginReq.account)
}
inline std::string* LoginReq::mutable_account() {
  // @@protoc_insertion_point(field_mutable:msg.LoginReq.account)
  return _internal_mutable_account();
}
inline const std::string& LoginReq::_internal_account() const {
  return account_.GetNoArena();
}
inline void LoginReq::_internal_set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LoginReq::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.LoginReq.account)
}
inline void LoginReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.LoginReq.account)
}
inline void LoginReq::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.LoginReq.account)
}
inline std::string* LoginReq::_internal_mutable_account() {
  
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LoginReq::release_account() {
  // @@protoc_insertion_point(field_release:msg.LoginReq.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReq::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:msg.LoginReq.account)
}

// int64 playerID = 3;
inline void LoginReq::clear_playerid() {
  playerid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginReq::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LoginReq::playerid() const {
  // @@protoc_insertion_point(field_get:msg.LoginReq.playerID)
  return _internal_playerid();
}
inline void LoginReq::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  playerid_ = value;
}
inline void LoginReq::set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:msg.LoginReq.playerID)
}

// -------------------------------------------------------------------

// LoginAck

// int32 code = 1;
inline void LoginAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LoginAck::code() const {
  // @@protoc_insertion_point(field_get:msg.LoginAck.code)
  return _internal_code();
}
inline void LoginAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void LoginAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.LoginAck.code)
}

// repeated .msg.PlayerAccountInfo infos = 2;
inline int LoginAck::_internal_infos_size() const {
  return infos_.size();
}
inline int LoginAck::infos_size() const {
  return _internal_infos_size();
}
inline void LoginAck::clear_infos() {
  infos_.Clear();
}
inline ::msg::PlayerAccountInfo* LoginAck::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:msg.LoginAck.infos)
  return infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerAccountInfo >*
LoginAck::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:msg.LoginAck.infos)
  return &infos_;
}
inline const ::msg::PlayerAccountInfo& LoginAck::_internal_infos(int index) const {
  return infos_.Get(index);
}
inline const ::msg::PlayerAccountInfo& LoginAck::infos(int index) const {
  // @@protoc_insertion_point(field_get:msg.LoginAck.infos)
  return _internal_infos(index);
}
inline ::msg::PlayerAccountInfo* LoginAck::_internal_add_infos() {
  return infos_.Add();
}
inline ::msg::PlayerAccountInfo* LoginAck::add_infos() {
  // @@protoc_insertion_point(field_add:msg.LoginAck.infos)
  return _internal_add_infos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PlayerAccountInfo >&
LoginAck::infos() const {
  // @@protoc_insertion_point(field_list:msg.LoginAck.infos)
  return infos_;
}

// -------------------------------------------------------------------

// EnterGameReq

// string token = 1;
inline void EnterGameReq::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EnterGameReq::token() const {
  // @@protoc_insertion_point(field_get:msg.EnterGameReq.token)
  return _internal_token();
}
inline void EnterGameReq::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:msg.EnterGameReq.token)
}
inline std::string* EnterGameReq::mutable_token() {
  // @@protoc_insertion_point(field_mutable:msg.EnterGameReq.token)
  return _internal_mutable_token();
}
inline const std::string& EnterGameReq::_internal_token() const {
  return token_.GetNoArena();
}
inline void EnterGameReq::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EnterGameReq::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.EnterGameReq.token)
}
inline void EnterGameReq::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.EnterGameReq.token)
}
inline void EnterGameReq::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.EnterGameReq.token)
}
inline std::string* EnterGameReq::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EnterGameReq::release_token() {
  // @@protoc_insertion_point(field_release:msg.EnterGameReq.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EnterGameReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:msg.EnterGameReq.token)
}

// int64 playerID = 2;
inline void EnterGameReq::clear_playerid() {
  playerid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EnterGameReq::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EnterGameReq::playerid() const {
  // @@protoc_insertion_point(field_get:msg.EnterGameReq.playerID)
  return _internal_playerid();
}
inline void EnterGameReq::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  playerid_ = value;
}
inline void EnterGameReq::set_playerid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:msg.EnterGameReq.playerID)
}

// int64 roleID = 3;
inline void EnterGameReq::clear_roleid() {
  roleid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EnterGameReq::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EnterGameReq::roleid() const {
  // @@protoc_insertion_point(field_get:msg.EnterGameReq.roleID)
  return _internal_roleid();
}
inline void EnterGameReq::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  roleid_ = value;
}
inline void EnterGameReq::set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:msg.EnterGameReq.roleID)
}

// -------------------------------------------------------------------

// EnterGameAck

// int32 code = 1;
inline void EnterGameAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnterGameAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EnterGameAck::code() const {
  // @@protoc_insertion_point(field_get:msg.EnterGameAck.code)
  return _internal_code();
}
inline void EnterGameAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void EnterGameAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.EnterGameAck.code)
}

// .msg.RoleDetailedInfo roleinfo = 2;
inline bool EnterGameAck::_internal_has_roleinfo() const {
  return this != internal_default_instance() && roleinfo_ != nullptr;
}
inline bool EnterGameAck::has_roleinfo() const {
  return _internal_has_roleinfo();
}
inline void EnterGameAck::clear_roleinfo() {
  if (GetArenaNoVirtual() == nullptr && roleinfo_ != nullptr) {
    delete roleinfo_;
  }
  roleinfo_ = nullptr;
}
inline const ::msg::RoleDetailedInfo& EnterGameAck::_internal_roleinfo() const {
  const ::msg::RoleDetailedInfo* p = roleinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::msg::RoleDetailedInfo*>(
      &::msg::_RoleDetailedInfo_default_instance_);
}
inline const ::msg::RoleDetailedInfo& EnterGameAck::roleinfo() const {
  // @@protoc_insertion_point(field_get:msg.EnterGameAck.roleinfo)
  return _internal_roleinfo();
}
inline ::msg::RoleDetailedInfo* EnterGameAck::release_roleinfo() {
  // @@protoc_insertion_point(field_release:msg.EnterGameAck.roleinfo)
  
  ::msg::RoleDetailedInfo* temp = roleinfo_;
  roleinfo_ = nullptr;
  return temp;
}
inline ::msg::RoleDetailedInfo* EnterGameAck::_internal_mutable_roleinfo() {
  
  if (roleinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::RoleDetailedInfo>(GetArenaNoVirtual());
    roleinfo_ = p;
  }
  return roleinfo_;
}
inline ::msg::RoleDetailedInfo* EnterGameAck::mutable_roleinfo() {
  // @@protoc_insertion_point(field_mutable:msg.EnterGameAck.roleinfo)
  return _internal_mutable_roleinfo();
}
inline void EnterGameAck::set_allocated_roleinfo(::msg::RoleDetailedInfo* roleinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete roleinfo_;
  }
  if (roleinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      roleinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, roleinfo, submessage_arena);
    }
    
  } else {
    
  }
  roleinfo_ = roleinfo;
  // @@protoc_insertion_point(field_set_allocated:msg.EnterGameAck.roleinfo)
}

// -------------------------------------------------------------------

// CreateRoleReq

// int32 occupation = 1;
inline void CreateRoleReq::clear_occupation() {
  occupation_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateRoleReq::_internal_occupation() const {
  return occupation_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateRoleReq::occupation() const {
  // @@protoc_insertion_point(field_get:msg.CreateRoleReq.occupation)
  return _internal_occupation();
}
inline void CreateRoleReq::_internal_set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  occupation_ = value;
}
inline void CreateRoleReq::set_occupation(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_occupation(value);
  // @@protoc_insertion_point(field_set:msg.CreateRoleReq.occupation)
}

// string name = 2;
inline void CreateRoleReq::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CreateRoleReq::name() const {
  // @@protoc_insertion_point(field_get:msg.CreateRoleReq.name)
  return _internal_name();
}
inline void CreateRoleReq::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:msg.CreateRoleReq.name)
}
inline std::string* CreateRoleReq::mutable_name() {
  // @@protoc_insertion_point(field_mutable:msg.CreateRoleReq.name)
  return _internal_mutable_name();
}
inline const std::string& CreateRoleReq::_internal_name() const {
  return name_.GetNoArena();
}
inline void CreateRoleReq::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CreateRoleReq::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.CreateRoleReq.name)
}
inline void CreateRoleReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.CreateRoleReq.name)
}
inline void CreateRoleReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.CreateRoleReq.name)
}
inline std::string* CreateRoleReq::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CreateRoleReq::release_name() {
  // @@protoc_insertion_point(field_release:msg.CreateRoleReq.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoleReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.CreateRoleReq.name)
}

// -------------------------------------------------------------------

// CreateRoleAck

// int32 code = 1;
inline void CreateRoleAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateRoleAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CreateRoleAck::code() const {
  // @@protoc_insertion_point(field_get:msg.CreateRoleAck.code)
  return _internal_code();
}
inline void CreateRoleAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void CreateRoleAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.CreateRoleAck.code)
}

// int64 roleID = 2;
inline void CreateRoleAck::clear_roleid() {
  roleid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateRoleAck::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CreateRoleAck::roleid() const {
  // @@protoc_insertion_point(field_get:msg.CreateRoleAck.roleID)
  return _internal_roleid();
}
inline void CreateRoleAck::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  roleid_ = value;
}
inline void CreateRoleAck::set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:msg.CreateRoleAck.roleID)
}

// -------------------------------------------------------------------

// ModifyRoleDataReq

// int64 roleId = 1;
inline void ModifyRoleDataReq::clear_roleid() {
  roleid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModifyRoleDataReq::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModifyRoleDataReq::roleid() const {
  // @@protoc_insertion_point(field_get:msg.ModifyRoleDataReq.roleId)
  return _internal_roleid();
}
inline void ModifyRoleDataReq::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  roleid_ = value;
}
inline void ModifyRoleDataReq::set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:msg.ModifyRoleDataReq.roleId)
}

// string jsonData = 2;
inline void ModifyRoleDataReq::clear_jsondata() {
  jsondata_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModifyRoleDataReq::jsondata() const {
  // @@protoc_insertion_point(field_get:msg.ModifyRoleDataReq.jsonData)
  return _internal_jsondata();
}
inline void ModifyRoleDataReq::set_jsondata(const std::string& value) {
  _internal_set_jsondata(value);
  // @@protoc_insertion_point(field_set:msg.ModifyRoleDataReq.jsonData)
}
inline std::string* ModifyRoleDataReq::mutable_jsondata() {
  // @@protoc_insertion_point(field_mutable:msg.ModifyRoleDataReq.jsonData)
  return _internal_mutable_jsondata();
}
inline const std::string& ModifyRoleDataReq::_internal_jsondata() const {
  return jsondata_.GetNoArena();
}
inline void ModifyRoleDataReq::_internal_set_jsondata(const std::string& value) {
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModifyRoleDataReq::set_jsondata(std::string&& value) {
  
  jsondata_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.ModifyRoleDataReq.jsonData)
}
inline void ModifyRoleDataReq::set_jsondata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.ModifyRoleDataReq.jsonData)
}
inline void ModifyRoleDataReq::set_jsondata(const char* value, size_t size) {
  
  jsondata_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.ModifyRoleDataReq.jsonData)
}
inline std::string* ModifyRoleDataReq::_internal_mutable_jsondata() {
  
  return jsondata_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModifyRoleDataReq::release_jsondata() {
  // @@protoc_insertion_point(field_release:msg.ModifyRoleDataReq.jsonData)
  
  return jsondata_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModifyRoleDataReq::set_allocated_jsondata(std::string* jsondata) {
  if (jsondata != nullptr) {
    
  } else {
    
  }
  jsondata_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jsondata);
  // @@protoc_insertion_point(field_set_allocated:msg.ModifyRoleDataReq.jsonData)
}

// string name = 3;
inline void ModifyRoleDataReq::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& ModifyRoleDataReq::name() const {
  // @@protoc_insertion_point(field_get:msg.ModifyRoleDataReq.name)
  return _internal_name();
}
inline void ModifyRoleDataReq::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:msg.ModifyRoleDataReq.name)
}
inline std::string* ModifyRoleDataReq::mutable_name() {
  // @@protoc_insertion_point(field_mutable:msg.ModifyRoleDataReq.name)
  return _internal_mutable_name();
}
inline const std::string& ModifyRoleDataReq::_internal_name() const {
  return name_.GetNoArena();
}
inline void ModifyRoleDataReq::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void ModifyRoleDataReq::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.ModifyRoleDataReq.name)
}
inline void ModifyRoleDataReq::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.ModifyRoleDataReq.name)
}
inline void ModifyRoleDataReq::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.ModifyRoleDataReq.name)
}
inline std::string* ModifyRoleDataReq::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ModifyRoleDataReq::release_name() {
  // @@protoc_insertion_point(field_release:msg.ModifyRoleDataReq.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ModifyRoleDataReq::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:msg.ModifyRoleDataReq.name)
}

// -------------------------------------------------------------------

// ModifyRoleDataAck

// int32 code = 1;
inline void ModifyRoleDataAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModifyRoleDataAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ModifyRoleDataAck::code() const {
  // @@protoc_insertion_point(field_get:msg.ModifyRoleDataAck.code)
  return _internal_code();
}
inline void ModifyRoleDataAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void ModifyRoleDataAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.ModifyRoleDataAck.code)
}

// -------------------------------------------------------------------

// ExitGameNtf

// int32 code = 1;
inline void ExitGameNtf::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExitGameNtf::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExitGameNtf::code() const {
  // @@protoc_insertion_point(field_get:msg.ExitGameNtf.code)
  return _internal_code();
}
inline void ExitGameNtf::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void ExitGameNtf::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.ExitGameNtf.code)
}

// -------------------------------------------------------------------

// PVEFightInfo

// int64 roleId = 1;
inline void PVEFightInfo::clear_roleid() {
  roleid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PVEFightInfo::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PVEFightInfo::roleid() const {
  // @@protoc_insertion_point(field_get:msg.PVEFightInfo.roleId)
  return _internal_roleid();
}
inline void PVEFightInfo::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  roleid_ = value;
}
inline void PVEFightInfo::set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:msg.PVEFightInfo.roleId)
}

// -------------------------------------------------------------------

// StartPVEFightReq

// int32 carbonId = 1;
inline void StartPVEFightReq::clear_carbonid() {
  carbonid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartPVEFightReq::_internal_carbonid() const {
  return carbonid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartPVEFightReq::carbonid() const {
  // @@protoc_insertion_point(field_get:msg.StartPVEFightReq.carbonId)
  return _internal_carbonid();
}
inline void StartPVEFightReq::_internal_set_carbonid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  carbonid_ = value;
}
inline void StartPVEFightReq::set_carbonid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_carbonid(value);
  // @@protoc_insertion_point(field_set:msg.StartPVEFightReq.carbonId)
}

// bool isOfflineMode = 2;
inline void StartPVEFightReq::clear_isofflinemode() {
  isofflinemode_ = false;
}
inline bool StartPVEFightReq::_internal_isofflinemode() const {
  return isofflinemode_;
}
inline bool StartPVEFightReq::isofflinemode() const {
  // @@protoc_insertion_point(field_get:msg.StartPVEFightReq.isOfflineMode)
  return _internal_isofflinemode();
}
inline void StartPVEFightReq::_internal_set_isofflinemode(bool value) {
  
  isofflinemode_ = value;
}
inline void StartPVEFightReq::set_isofflinemode(bool value) {
  _internal_set_isofflinemode(value);
  // @@protoc_insertion_point(field_set:msg.StartPVEFightReq.isOfflineMode)
}

// repeated .msg.PVEFightInfo roles = 3;
inline int StartPVEFightReq::_internal_roles_size() const {
  return roles_.size();
}
inline int StartPVEFightReq::roles_size() const {
  return _internal_roles_size();
}
inline void StartPVEFightReq::clear_roles() {
  roles_.Clear();
}
inline ::msg::PVEFightInfo* StartPVEFightReq::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:msg.StartPVEFightReq.roles)
  return roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PVEFightInfo >*
StartPVEFightReq::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:msg.StartPVEFightReq.roles)
  return &roles_;
}
inline const ::msg::PVEFightInfo& StartPVEFightReq::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const ::msg::PVEFightInfo& StartPVEFightReq::roles(int index) const {
  // @@protoc_insertion_point(field_get:msg.StartPVEFightReq.roles)
  return _internal_roles(index);
}
inline ::msg::PVEFightInfo* StartPVEFightReq::_internal_add_roles() {
  return roles_.Add();
}
inline ::msg::PVEFightInfo* StartPVEFightReq::add_roles() {
  // @@protoc_insertion_point(field_add:msg.StartPVEFightReq.roles)
  return _internal_add_roles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::msg::PVEFightInfo >&
StartPVEFightReq::roles() const {
  // @@protoc_insertion_point(field_list:msg.StartPVEFightReq.roles)
  return roles_;
}

// -------------------------------------------------------------------

// StartPVEFightAck

// int32 code = 1;
inline void StartPVEFightAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartPVEFightAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartPVEFightAck::code() const {
  // @@protoc_insertion_point(field_get:msg.StartPVEFightAck.code)
  return _internal_code();
}
inline void StartPVEFightAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void StartPVEFightAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.StartPVEFightAck.code)
}

// -------------------------------------------------------------------

// StartPVPFightReq

// int64 foeId = 1;
inline void StartPVPFightReq::clear_foeid() {
  foeid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StartPVPFightReq::_internal_foeid() const {
  return foeid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 StartPVPFightReq::foeid() const {
  // @@protoc_insertion_point(field_get:msg.StartPVPFightReq.foeId)
  return _internal_foeid();
}
inline void StartPVPFightReq::_internal_set_foeid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  foeid_ = value;
}
inline void StartPVPFightReq::set_foeid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_foeid(value);
  // @@protoc_insertion_point(field_set:msg.StartPVPFightReq.foeId)
}

// -------------------------------------------------------------------

// StartPVPFightAck

// int32 code = 1;
inline void StartPVPFightAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartPVPFightAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartPVPFightAck::code() const {
  // @@protoc_insertion_point(field_get:msg.StartPVPFightAck.code)
  return _internal_code();
}
inline void StartPVPFightAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void StartPVPFightAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.StartPVPFightAck.code)
}

// -------------------------------------------------------------------

// StopPVPMatchReq

// -------------------------------------------------------------------

// StopPVPMatchAck

// int32 code = 1;
inline void StopPVPMatchAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StopPVPMatchAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StopPVPMatchAck::code() const {
  // @@protoc_insertion_point(field_get:msg.StopPVPMatchAck.code)
  return _internal_code();
}
inline void StopPVPMatchAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void StopPVPMatchAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.StopPVPMatchAck.code)
}

// -------------------------------------------------------------------

// StartFightNTF

// int32 code = 1;
inline void StartFightNTF::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::code() const {
  // @@protoc_insertion_point(field_get:msg.StartFightNTF.code)
  return _internal_code();
}
inline void StartFightNTF::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void StartFightNTF::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:msg.StartFightNTF.code)
}

// int32 fightUUID = 2;
inline void StartFightNTF::clear_fightuuid() {
  fightuuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::_internal_fightuuid() const {
  return fightuuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::fightuuid() const {
  // @@protoc_insertion_point(field_get:msg.StartFightNTF.fightUUID)
  return _internal_fightuuid();
}
inline void StartFightNTF::_internal_set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fightuuid_ = value;
}
inline void StartFightNTF::set_fightuuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fightuuid(value);
  // @@protoc_insertion_point(field_set:msg.StartFightNTF.fightUUID)
}

// string fightIP = 3;
inline void StartFightNTF::clear_fightip() {
  fightip_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StartFightNTF::fightip() const {
  // @@protoc_insertion_point(field_get:msg.StartFightNTF.fightIP)
  return _internal_fightip();
}
inline void StartFightNTF::set_fightip(const std::string& value) {
  _internal_set_fightip(value);
  // @@protoc_insertion_point(field_set:msg.StartFightNTF.fightIP)
}
inline std::string* StartFightNTF::mutable_fightip() {
  // @@protoc_insertion_point(field_mutable:msg.StartFightNTF.fightIP)
  return _internal_mutable_fightip();
}
inline const std::string& StartFightNTF::_internal_fightip() const {
  return fightip_.GetNoArena();
}
inline void StartFightNTF::_internal_set_fightip(const std::string& value) {
  
  fightip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StartFightNTF::set_fightip(std::string&& value) {
  
  fightip_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:msg.StartFightNTF.fightIP)
}
inline void StartFightNTF::set_fightip(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fightip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:msg.StartFightNTF.fightIP)
}
inline void StartFightNTF::set_fightip(const char* value, size_t size) {
  
  fightip_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:msg.StartFightNTF.fightIP)
}
inline std::string* StartFightNTF::_internal_mutable_fightip() {
  
  return fightip_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StartFightNTF::release_fightip() {
  // @@protoc_insertion_point(field_release:msg.StartFightNTF.fightIP)
  
  return fightip_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StartFightNTF::set_allocated_fightip(std::string* fightip) {
  if (fightip != nullptr) {
    
  } else {
    
  }
  fightip_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fightip);
  // @@protoc_insertion_point(field_set_allocated:msg.StartFightNTF.fightIP)
}

// int32 fightPort = 4;
inline void StartFightNTF::clear_fightport() {
  fightport_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::_internal_fightport() const {
  return fightport_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::fightport() const {
  // @@protoc_insertion_point(field_get:msg.StartFightNTF.fightPort)
  return _internal_fightport();
}
inline void StartFightNTF::_internal_set_fightport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fightport_ = value;
}
inline void StartFightNTF::set_fightport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fightport(value);
  // @@protoc_insertion_point(field_set:msg.StartFightNTF.fightPort)
}

// int32 netType = 5;
inline void StartFightNTF::clear_nettype() {
  nettype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::_internal_nettype() const {
  return nettype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StartFightNTF::nettype() const {
  // @@protoc_insertion_point(field_get:msg.StartFightNTF.netType)
  return _internal_nettype();
}
inline void StartFightNTF::_internal_set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nettype_ = value;
}
inline void StartFightNTF::set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nettype(value);
  // @@protoc_insertion_point(field_set:msg.StartFightNTF.netType)
}

// -------------------------------------------------------------------

// PushRoleData

// .msg.RoleSimpleInfo info = 1;
inline bool PushRoleData::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool PushRoleData::has_info() const {
  return _internal_has_info();
}
inline void PushRoleData::clear_info() {
  if (GetArenaNoVirtual() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::msg::RoleSimpleInfo& PushRoleData::_internal_info() const {
  const ::msg::RoleSimpleInfo* p = info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::msg::RoleSimpleInfo*>(
      &::msg::_RoleSimpleInfo_default_instance_);
}
inline const ::msg::RoleSimpleInfo& PushRoleData::info() const {
  // @@protoc_insertion_point(field_get:msg.PushRoleData.info)
  return _internal_info();
}
inline ::msg::RoleSimpleInfo* PushRoleData::release_info() {
  // @@protoc_insertion_point(field_release:msg.PushRoleData.info)
  
  ::msg::RoleSimpleInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::msg::RoleSimpleInfo* PushRoleData::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::msg::RoleSimpleInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  return info_;
}
inline ::msg::RoleSimpleInfo* PushRoleData::mutable_info() {
  // @@protoc_insertion_point(field_mutable:msg.PushRoleData.info)
  return _internal_mutable_info();
}
inline void PushRoleData::set_allocated_info(::msg::RoleSimpleInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:msg.PushRoleData.info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::msg::LoginReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::LoginAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::EnterGameReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::EnterGameAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::CreateRoleReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::CreateRoleAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::ModifyRoleDataReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::ModifyRoleDataAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::ExitGameNtf_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::StartPVEFightReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::StartPVEFightAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::StartPVPFightReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::StartPVPFightAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::StopPVPMatchReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::StopPVPMatchAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::StartFightNTF_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::msg::PushRoleData_MsgId> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_C2Game_2eproto
