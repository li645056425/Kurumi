// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_Server.proto

#ifndef PROTOBUF_Msg_5fServer_2eproto__INCLUDED
#define PROTOBUF_Msg_5fServer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace svr_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Msg_5fServer_2eproto();
void protobuf_AssignDesc_Msg_5fServer_2eproto();
void protobuf_ShutdownFile_Msg_5fServer_2eproto();

class CheckTokenReq;
class CheckTokenAck;
class TokenChangeNtf;
class FightRoleSpawnInfo;
class NewFightReq;
class NewFightAck;

// ===================================================================

class CheckTokenReq : public ::google::protobuf::MessageLite {
 public:
  CheckTokenReq();
  virtual ~CheckTokenReq();

  CheckTokenReq(const CheckTokenReq& from);

  inline CheckTokenReq& operator=(const CheckTokenReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CheckTokenReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckTokenReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CheckTokenReq* other);

  // implements Message ----------------------------------------------

  CheckTokenReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckTokenReq& from);
  void MergeFrom(const CheckTokenReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required int64 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // required uint32 session = 4;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 4;
  inline ::google::protobuf::uint32 session() const;
  inline void set_session(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:svr_msg.CheckTokenReq)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_session();
  inline void clear_has_session();

  ::std::string* account_;
  ::std::string* token_;
  ::google::protobuf::int64 pid_;
  ::google::protobuf::uint32 session_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fServer_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fServer_2eproto();

  void InitAsDefaultInstance();
  static CheckTokenReq* default_instance_;
};
// -------------------------------------------------------------------

class CheckTokenAck : public ::google::protobuf::MessageLite {
 public:
  CheckTokenAck();
  virtual ~CheckTokenAck();

  CheckTokenAck(const CheckTokenAck& from);

  inline CheckTokenAck& operator=(const CheckTokenAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CheckTokenAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckTokenAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CheckTokenAck* other);

  // implements Message ----------------------------------------------

  CheckTokenAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckTokenAck& from);
  void MergeFrom(const CheckTokenAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required int64 pid = 2;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 2;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // required int32 session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline ::google::protobuf::int32 session() const;
  inline void set_session(::google::protobuf::int32 value);

  // required string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:svr_msg.CheckTokenAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::int64 pid_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 session_;
  ::std::string* account_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fServer_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fServer_2eproto();

  void InitAsDefaultInstance();
  static CheckTokenAck* default_instance_;
};
// -------------------------------------------------------------------

class TokenChangeNtf : public ::google::protobuf::MessageLite {
 public:
  TokenChangeNtf();
  virtual ~TokenChangeNtf();

  TokenChangeNtf(const TokenChangeNtf& from);

  inline TokenChangeNtf& operator=(const TokenChangeNtf& from) {
    CopyFrom(from);
    return *this;
  }

  static const TokenChangeNtf& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TokenChangeNtf* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TokenChangeNtf* other);

  // implements Message ----------------------------------------------

  TokenChangeNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TokenChangeNtf& from);
  void MergeFrom(const TokenChangeNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:svr_msg.TokenChangeNtf)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_account();
  inline void clear_has_account();

  ::std::string* token_;
  ::std::string* account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fServer_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fServer_2eproto();

  void InitAsDefaultInstance();
  static TokenChangeNtf* default_instance_;
};
// -------------------------------------------------------------------

class FightRoleSpawnInfo : public ::google::protobuf::MessageLite {
 public:
  FightRoleSpawnInfo();
  virtual ~FightRoleSpawnInfo();

  FightRoleSpawnInfo(const FightRoleSpawnInfo& from);

  inline FightRoleSpawnInfo& operator=(const FightRoleSpawnInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FightRoleSpawnInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightRoleSpawnInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightRoleSpawnInfo* other);

  // implements Message ----------------------------------------------

  FightRoleSpawnInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightRoleSpawnInfo& from);
  void MergeFrom(const FightRoleSpawnInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // required int32 occ = 2;
  inline bool has_occ() const;
  inline void clear_occ();
  static const int kOccFieldNumber = 2;
  inline ::google::protobuf::int32 occ() const;
  inline void set_occ(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:svr_msg.FightRoleSpawnInfo)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_occ();
  inline void clear_has_occ();

  ::google::protobuf::int64 roleid_;
  ::google::protobuf::int32 occ_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fServer_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fServer_2eproto();

  void InitAsDefaultInstance();
  static FightRoleSpawnInfo* default_instance_;
};
// -------------------------------------------------------------------

class NewFightReq : public ::google::protobuf::MessageLite {
 public:
  NewFightReq();
  virtual ~NewFightReq();

  NewFightReq(const NewFightReq& from);

  inline NewFightReq& operator=(const NewFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const NewFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewFightReq* other);

  // implements Message ----------------------------------------------

  NewFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewFightReq& from);
  void MergeFrom(const NewFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mapId = 1;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 1;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // repeated .svr_msg.FightRoleSpawnInfo roles = 2;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 2;
  inline const ::svr_msg::FightRoleSpawnInfo& roles(int index) const;
  inline ::svr_msg::FightRoleSpawnInfo* mutable_roles(int index);
  inline ::svr_msg::FightRoleSpawnInfo* add_roles();
  inline const ::google::protobuf::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >&
      roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >*
      mutable_roles();

  // required int32 tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // required int32 fightType = 4;
  inline bool has_fighttype() const;
  inline void clear_fighttype();
  static const int kFightTypeFieldNumber = 4;
  inline ::google::protobuf::int32 fighttype() const;
  inline void set_fighttype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:svr_msg.NewFightReq)
 private:
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_fighttype();
  inline void clear_has_fighttype();

  ::google::protobuf::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo > roles_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::int32 tag_;
  ::google::protobuf::int32 fighttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fServer_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fServer_2eproto();

  void InitAsDefaultInstance();
  static NewFightReq* default_instance_;
};
// -------------------------------------------------------------------

class NewFightAck : public ::google::protobuf::MessageLite {
 public:
  NewFightAck();
  virtual ~NewFightAck();

  NewFightAck(const NewFightAck& from);

  inline NewFightAck& operator=(const NewFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const NewFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NewFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NewFightAck* other);

  // implements Message ----------------------------------------------

  NewFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NewFightAck& from);
  void MergeFrom(const NewFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required int32 uuid = 2;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 2;
  inline ::google::protobuf::int32 uuid() const;
  inline void set_uuid(::google::protobuf::int32 value);

  // required int32 tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // required int32 fightType = 4;
  inline bool has_fighttype() const;
  inline void clear_fighttype();
  static const int kFightTypeFieldNumber = 4;
  inline ::google::protobuf::int32 fighttype() const;
  inline void set_fighttype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:svr_msg.NewFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_fighttype();
  inline void clear_has_fighttype();

  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 uuid_;
  ::google::protobuf::int32 tag_;
  ::google::protobuf::int32 fighttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fServer_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fServer_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fServer_2eproto();

  void InitAsDefaultInstance();
  static NewFightAck* default_instance_;
};
// ===================================================================


// ===================================================================

// CheckTokenReq

// required string account = 1;
inline bool CheckTokenReq::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckTokenReq::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckTokenReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckTokenReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CheckTokenReq::account() const {
  return *account_;
}
inline void CheckTokenReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CheckTokenReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CheckTokenReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckTokenReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CheckTokenReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckTokenReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 2;
inline bool CheckTokenReq::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckTokenReq::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckTokenReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckTokenReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CheckTokenReq::token() const {
  return *token_;
}
inline void CheckTokenReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CheckTokenReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CheckTokenReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckTokenReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CheckTokenReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckTokenReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 pid = 3;
inline bool CheckTokenReq::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckTokenReq::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckTokenReq::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckTokenReq::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 CheckTokenReq::pid() const {
  return pid_;
}
inline void CheckTokenReq::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// required uint32 session = 4;
inline bool CheckTokenReq::has_session() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckTokenReq::set_has_session() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckTokenReq::clear_has_session() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckTokenReq::clear_session() {
  session_ = 0u;
  clear_has_session();
}
inline ::google::protobuf::uint32 CheckTokenReq::session() const {
  return session_;
}
inline void CheckTokenReq::set_session(::google::protobuf::uint32 value) {
  set_has_session();
  session_ = value;
}

// -------------------------------------------------------------------

// CheckTokenAck

// required int32 code = 1;
inline bool CheckTokenAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckTokenAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckTokenAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckTokenAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CheckTokenAck::code() const {
  return code_;
}
inline void CheckTokenAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required int64 pid = 2;
inline bool CheckTokenAck::has_pid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckTokenAck::set_has_pid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckTokenAck::clear_has_pid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckTokenAck::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 CheckTokenAck::pid() const {
  return pid_;
}
inline void CheckTokenAck::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// required int32 session = 3;
inline bool CheckTokenAck::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckTokenAck::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckTokenAck::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckTokenAck::clear_session() {
  session_ = 0;
  clear_has_session();
}
inline ::google::protobuf::int32 CheckTokenAck::session() const {
  return session_;
}
inline void CheckTokenAck::set_session(::google::protobuf::int32 value) {
  set_has_session();
  session_ = value;
}

// required string account = 4;
inline bool CheckTokenAck::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckTokenAck::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckTokenAck::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckTokenAck::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& CheckTokenAck::account() const {
  return *account_;
}
inline void CheckTokenAck::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CheckTokenAck::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void CheckTokenAck::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckTokenAck::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* CheckTokenAck::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckTokenAck::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 5;
inline bool CheckTokenAck::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckTokenAck::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckTokenAck::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckTokenAck::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CheckTokenAck::token() const {
  return *token_;
}
inline void CheckTokenAck::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CheckTokenAck::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CheckTokenAck::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckTokenAck::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CheckTokenAck::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckTokenAck::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TokenChangeNtf

// required string token = 1;
inline bool TokenChangeNtf::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TokenChangeNtf::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TokenChangeNtf::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TokenChangeNtf::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& TokenChangeNtf::token() const {
  return *token_;
}
inline void TokenChangeNtf::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TokenChangeNtf::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void TokenChangeNtf::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TokenChangeNtf::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* TokenChangeNtf::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TokenChangeNtf::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string account = 2;
inline bool TokenChangeNtf::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TokenChangeNtf::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TokenChangeNtf::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TokenChangeNtf::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& TokenChangeNtf::account() const {
  return *account_;
}
inline void TokenChangeNtf::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TokenChangeNtf::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void TokenChangeNtf::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TokenChangeNtf::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* TokenChangeNtf::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TokenChangeNtf::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FightRoleSpawnInfo

// required int64 roleId = 1;
inline bool FightRoleSpawnInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightRoleSpawnInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightRoleSpawnInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightRoleSpawnInfo::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 FightRoleSpawnInfo::roleid() const {
  return roleid_;
}
inline void FightRoleSpawnInfo::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// required int32 occ = 2;
inline bool FightRoleSpawnInfo::has_occ() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightRoleSpawnInfo::set_has_occ() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightRoleSpawnInfo::clear_has_occ() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightRoleSpawnInfo::clear_occ() {
  occ_ = 0;
  clear_has_occ();
}
inline ::google::protobuf::int32 FightRoleSpawnInfo::occ() const {
  return occ_;
}
inline void FightRoleSpawnInfo::set_occ(::google::protobuf::int32 value) {
  set_has_occ();
  occ_ = value;
}

// -------------------------------------------------------------------

// NewFightReq

// required int32 mapId = 1;
inline bool NewFightReq::has_mapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewFightReq::set_has_mapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewFightReq::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewFightReq::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 NewFightReq::mapid() const {
  return mapid_;
}
inline void NewFightReq::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// repeated .svr_msg.FightRoleSpawnInfo roles = 2;
inline int NewFightReq::roles_size() const {
  return roles_.size();
}
inline void NewFightReq::clear_roles() {
  roles_.Clear();
}
inline const ::svr_msg::FightRoleSpawnInfo& NewFightReq::roles(int index) const {
  return roles_.Get(index);
}
inline ::svr_msg::FightRoleSpawnInfo* NewFightReq::mutable_roles(int index) {
  return roles_.Mutable(index);
}
inline ::svr_msg::FightRoleSpawnInfo* NewFightReq::add_roles() {
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >&
NewFightReq::roles() const {
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >*
NewFightReq::mutable_roles() {
  return &roles_;
}

// required int32 tag = 3;
inline bool NewFightReq::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewFightReq::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewFightReq::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewFightReq::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 NewFightReq::tag() const {
  return tag_;
}
inline void NewFightReq::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// required int32 fightType = 4;
inline bool NewFightReq::has_fighttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewFightReq::set_has_fighttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewFightReq::clear_has_fighttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewFightReq::clear_fighttype() {
  fighttype_ = 0;
  clear_has_fighttype();
}
inline ::google::protobuf::int32 NewFightReq::fighttype() const {
  return fighttype_;
}
inline void NewFightReq::set_fighttype(::google::protobuf::int32 value) {
  set_has_fighttype();
  fighttype_ = value;
}

// -------------------------------------------------------------------

// NewFightAck

// required int32 code = 1;
inline bool NewFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 NewFightAck::code() const {
  return code_;
}
inline void NewFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required int32 uuid = 2;
inline bool NewFightAck::has_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewFightAck::set_has_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewFightAck::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewFightAck::clear_uuid() {
  uuid_ = 0;
  clear_has_uuid();
}
inline ::google::protobuf::int32 NewFightAck::uuid() const {
  return uuid_;
}
inline void NewFightAck::set_uuid(::google::protobuf::int32 value) {
  set_has_uuid();
  uuid_ = value;
}

// required int32 tag = 3;
inline bool NewFightAck::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewFightAck::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewFightAck::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewFightAck::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 NewFightAck::tag() const {
  return tag_;
}
inline void NewFightAck::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// required int32 fightType = 4;
inline bool NewFightAck::has_fighttype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewFightAck::set_has_fighttype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewFightAck::clear_has_fighttype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewFightAck::clear_fighttype() {
  fighttype_ = 0;
  clear_has_fighttype();
}
inline ::google::protobuf::int32 NewFightAck::fighttype() const {
  return fighttype_;
}
inline void NewFightAck::set_fighttype(::google::protobuf::int32 value) {
  set_has_fighttype();
  fighttype_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace svr_msg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Msg_5fServer_2eproto__INCLUDED
