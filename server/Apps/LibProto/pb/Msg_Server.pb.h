// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_Server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Msg_5fServer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Msg_5fServer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Msg_5fServer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Msg_5fServer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
namespace svr_msg {
class CheckTokenAck;
class CheckTokenAckDefaultTypeInternal;
extern CheckTokenAckDefaultTypeInternal _CheckTokenAck_default_instance_;
class CheckTokenReq;
class CheckTokenReqDefaultTypeInternal;
extern CheckTokenReqDefaultTypeInternal _CheckTokenReq_default_instance_;
class FightRoleSpawnInfo;
class FightRoleSpawnInfoDefaultTypeInternal;
extern FightRoleSpawnInfoDefaultTypeInternal _FightRoleSpawnInfo_default_instance_;
class NewFightAck;
class NewFightAckDefaultTypeInternal;
extern NewFightAckDefaultTypeInternal _NewFightAck_default_instance_;
class NewFightReq;
class NewFightReqDefaultTypeInternal;
extern NewFightReqDefaultTypeInternal _NewFightReq_default_instance_;
class TokenChangeNtf;
class TokenChangeNtfDefaultTypeInternal;
extern TokenChangeNtfDefaultTypeInternal _TokenChangeNtf_default_instance_;
}  // namespace svr_msg
PROTOBUF_NAMESPACE_OPEN
template<> ::svr_msg::CheckTokenAck* Arena::CreateMaybeMessage<::svr_msg::CheckTokenAck>(Arena*);
template<> ::svr_msg::CheckTokenReq* Arena::CreateMaybeMessage<::svr_msg::CheckTokenReq>(Arena*);
template<> ::svr_msg::FightRoleSpawnInfo* Arena::CreateMaybeMessage<::svr_msg::FightRoleSpawnInfo>(Arena*);
template<> ::svr_msg::NewFightAck* Arena::CreateMaybeMessage<::svr_msg::NewFightAck>(Arena*);
template<> ::svr_msg::NewFightReq* Arena::CreateMaybeMessage<::svr_msg::NewFightReq>(Arena*);
template<> ::svr_msg::TokenChangeNtf* Arena::CreateMaybeMessage<::svr_msg::TokenChangeNtf>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace svr_msg {

enum CheckTokenReq_MsgId : int {
  CheckTokenReq_MsgId_None = 0,
  CheckTokenReq_MsgId_Id = 1001,
  CheckTokenReq_MsgId_CheckTokenReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CheckTokenReq_MsgId_CheckTokenReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CheckTokenReq_MsgId_IsValid(int value);
constexpr CheckTokenReq_MsgId CheckTokenReq_MsgId_MsgId_MIN = CheckTokenReq_MsgId_None;
constexpr CheckTokenReq_MsgId CheckTokenReq_MsgId_MsgId_MAX = CheckTokenReq_MsgId_Id;
constexpr int CheckTokenReq_MsgId_MsgId_ARRAYSIZE = CheckTokenReq_MsgId_MsgId_MAX + 1;

const std::string& CheckTokenReq_MsgId_Name(CheckTokenReq_MsgId value);
template<typename T>
inline const std::string& CheckTokenReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckTokenReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckTokenReq_MsgId_Name.");
  return CheckTokenReq_MsgId_Name(static_cast<CheckTokenReq_MsgId>(enum_t_value));
}
bool CheckTokenReq_MsgId_Parse(
    const std::string& name, CheckTokenReq_MsgId* value);
enum CheckTokenAck_MsgId : int {
  CheckTokenAck_MsgId_None = 0,
  CheckTokenAck_MsgId_Id = 1002,
  CheckTokenAck_MsgId_CheckTokenAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CheckTokenAck_MsgId_CheckTokenAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CheckTokenAck_MsgId_IsValid(int value);
constexpr CheckTokenAck_MsgId CheckTokenAck_MsgId_MsgId_MIN = CheckTokenAck_MsgId_None;
constexpr CheckTokenAck_MsgId CheckTokenAck_MsgId_MsgId_MAX = CheckTokenAck_MsgId_Id;
constexpr int CheckTokenAck_MsgId_MsgId_ARRAYSIZE = CheckTokenAck_MsgId_MsgId_MAX + 1;

const std::string& CheckTokenAck_MsgId_Name(CheckTokenAck_MsgId value);
template<typename T>
inline const std::string& CheckTokenAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CheckTokenAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CheckTokenAck_MsgId_Name.");
  return CheckTokenAck_MsgId_Name(static_cast<CheckTokenAck_MsgId>(enum_t_value));
}
bool CheckTokenAck_MsgId_Parse(
    const std::string& name, CheckTokenAck_MsgId* value);
enum TokenChangeNtf_MsgId : int {
  TokenChangeNtf_MsgId_None = 0,
  TokenChangeNtf_MsgId_Id = 1002,
  TokenChangeNtf_MsgId_TokenChangeNtf_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TokenChangeNtf_MsgId_TokenChangeNtf_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TokenChangeNtf_MsgId_IsValid(int value);
constexpr TokenChangeNtf_MsgId TokenChangeNtf_MsgId_MsgId_MIN = TokenChangeNtf_MsgId_None;
constexpr TokenChangeNtf_MsgId TokenChangeNtf_MsgId_MsgId_MAX = TokenChangeNtf_MsgId_Id;
constexpr int TokenChangeNtf_MsgId_MsgId_ARRAYSIZE = TokenChangeNtf_MsgId_MsgId_MAX + 1;

const std::string& TokenChangeNtf_MsgId_Name(TokenChangeNtf_MsgId value);
template<typename T>
inline const std::string& TokenChangeNtf_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TokenChangeNtf_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TokenChangeNtf_MsgId_Name.");
  return TokenChangeNtf_MsgId_Name(static_cast<TokenChangeNtf_MsgId>(enum_t_value));
}
bool TokenChangeNtf_MsgId_Parse(
    const std::string& name, TokenChangeNtf_MsgId* value);
enum NewFightReq_MsgId : int {
  NewFightReq_MsgId_None = 0,
  NewFightReq_MsgId_Id = 2001,
  NewFightReq_MsgId_NewFightReq_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NewFightReq_MsgId_NewFightReq_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NewFightReq_MsgId_IsValid(int value);
constexpr NewFightReq_MsgId NewFightReq_MsgId_MsgId_MIN = NewFightReq_MsgId_None;
constexpr NewFightReq_MsgId NewFightReq_MsgId_MsgId_MAX = NewFightReq_MsgId_Id;
constexpr int NewFightReq_MsgId_MsgId_ARRAYSIZE = NewFightReq_MsgId_MsgId_MAX + 1;

const std::string& NewFightReq_MsgId_Name(NewFightReq_MsgId value);
template<typename T>
inline const std::string& NewFightReq_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NewFightReq_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NewFightReq_MsgId_Name.");
  return NewFightReq_MsgId_Name(static_cast<NewFightReq_MsgId>(enum_t_value));
}
bool NewFightReq_MsgId_Parse(
    const std::string& name, NewFightReq_MsgId* value);
enum NewFightAck_MsgId : int {
  NewFightAck_MsgId_None = 0,
  NewFightAck_MsgId_Id = 2002,
  NewFightAck_MsgId_NewFightAck_MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NewFightAck_MsgId_NewFightAck_MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NewFightAck_MsgId_IsValid(int value);
constexpr NewFightAck_MsgId NewFightAck_MsgId_MsgId_MIN = NewFightAck_MsgId_None;
constexpr NewFightAck_MsgId NewFightAck_MsgId_MsgId_MAX = NewFightAck_MsgId_Id;
constexpr int NewFightAck_MsgId_MsgId_ARRAYSIZE = NewFightAck_MsgId_MsgId_MAX + 1;

const std::string& NewFightAck_MsgId_Name(NewFightAck_MsgId value);
template<typename T>
inline const std::string& NewFightAck_MsgId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NewFightAck_MsgId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NewFightAck_MsgId_Name.");
  return NewFightAck_MsgId_Name(static_cast<NewFightAck_MsgId>(enum_t_value));
}
bool NewFightAck_MsgId_Parse(
    const std::string& name, NewFightAck_MsgId* value);
// ===================================================================

class CheckTokenReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:svr_msg.CheckTokenReq) */ {
 public:
  CheckTokenReq();
  virtual ~CheckTokenReq();

  CheckTokenReq(const CheckTokenReq& from);
  CheckTokenReq(CheckTokenReq&& from) noexcept
    : CheckTokenReq() {
    *this = ::std::move(from);
  }

  inline CheckTokenReq& operator=(const CheckTokenReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckTokenReq& operator=(CheckTokenReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CheckTokenReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckTokenReq* internal_default_instance() {
    return reinterpret_cast<const CheckTokenReq*>(
               &_CheckTokenReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CheckTokenReq& a, CheckTokenReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckTokenReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckTokenReq* New() const final {
    return CreateMaybeMessage<CheckTokenReq>(nullptr);
  }

  CheckTokenReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckTokenReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CheckTokenReq& from);
  void MergeFrom(const CheckTokenReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckTokenReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "svr_msg.CheckTokenReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CheckTokenReq_MsgId MsgId;
  static constexpr MsgId None =
    CheckTokenReq_MsgId_None;
  static constexpr MsgId Id =
    CheckTokenReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return CheckTokenReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    CheckTokenReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    CheckTokenReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    CheckTokenReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return CheckTokenReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return CheckTokenReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
    kTokenFieldNumber = 2,
    kPidFieldNumber = 3,
    kSessionFieldNumber = 4,
  };
  // string account = 1;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string token = 2;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 pid = 3;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // uint32 session = 4;
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::uint32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:svr_msg.CheckTokenReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 session_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Msg_5fServer_2eproto;
};
// -------------------------------------------------------------------

class CheckTokenAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:svr_msg.CheckTokenAck) */ {
 public:
  CheckTokenAck();
  virtual ~CheckTokenAck();

  CheckTokenAck(const CheckTokenAck& from);
  CheckTokenAck(CheckTokenAck&& from) noexcept
    : CheckTokenAck() {
    *this = ::std::move(from);
  }

  inline CheckTokenAck& operator=(const CheckTokenAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckTokenAck& operator=(CheckTokenAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CheckTokenAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckTokenAck* internal_default_instance() {
    return reinterpret_cast<const CheckTokenAck*>(
               &_CheckTokenAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CheckTokenAck& a, CheckTokenAck& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckTokenAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckTokenAck* New() const final {
    return CreateMaybeMessage<CheckTokenAck>(nullptr);
  }

  CheckTokenAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckTokenAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const CheckTokenAck& from);
  void MergeFrom(const CheckTokenAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CheckTokenAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "svr_msg.CheckTokenAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CheckTokenAck_MsgId MsgId;
  static constexpr MsgId None =
    CheckTokenAck_MsgId_None;
  static constexpr MsgId Id =
    CheckTokenAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return CheckTokenAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    CheckTokenAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    CheckTokenAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    CheckTokenAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return CheckTokenAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return CheckTokenAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 4,
    kTokenFieldNumber = 5,
    kPidFieldNumber = 2,
    kCodeFieldNumber = 1,
    kSessionFieldNumber = 3,
  };
  // string account = 4;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string token = 5;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 pid = 2;
  void clear_pid();
  ::PROTOBUF_NAMESPACE_ID::int64 pid() const;
  void set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_pid() const;
  void _internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 session = 3;
  void clear_session();
  ::PROTOBUF_NAMESPACE_ID::int32 session() const;
  void set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_session() const;
  void _internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:svr_msg.CheckTokenAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::int64 pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 session_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Msg_5fServer_2eproto;
};
// -------------------------------------------------------------------

class TokenChangeNtf :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:svr_msg.TokenChangeNtf) */ {
 public:
  TokenChangeNtf();
  virtual ~TokenChangeNtf();

  TokenChangeNtf(const TokenChangeNtf& from);
  TokenChangeNtf(TokenChangeNtf&& from) noexcept
    : TokenChangeNtf() {
    *this = ::std::move(from);
  }

  inline TokenChangeNtf& operator=(const TokenChangeNtf& from) {
    CopyFrom(from);
    return *this;
  }
  inline TokenChangeNtf& operator=(TokenChangeNtf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TokenChangeNtf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TokenChangeNtf* internal_default_instance() {
    return reinterpret_cast<const TokenChangeNtf*>(
               &_TokenChangeNtf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TokenChangeNtf& a, TokenChangeNtf& b) {
    a.Swap(&b);
  }
  inline void Swap(TokenChangeNtf* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TokenChangeNtf* New() const final {
    return CreateMaybeMessage<TokenChangeNtf>(nullptr);
  }

  TokenChangeNtf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TokenChangeNtf>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const TokenChangeNtf& from);
  void MergeFrom(const TokenChangeNtf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TokenChangeNtf* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "svr_msg.TokenChangeNtf";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TokenChangeNtf_MsgId MsgId;
  static constexpr MsgId None =
    TokenChangeNtf_MsgId_None;
  static constexpr MsgId Id =
    TokenChangeNtf_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return TokenChangeNtf_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    TokenChangeNtf_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    TokenChangeNtf_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    TokenChangeNtf_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return TokenChangeNtf_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return TokenChangeNtf_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kAccountFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  void set_token(const std::string& value);
  void set_token(std::string&& value);
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  std::string* mutable_token();
  std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string account = 2;
  void clear_account();
  const std::string& account() const;
  void set_account(const std::string& value);
  void set_account(std::string&& value);
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  std::string* mutable_account();
  std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // @@protoc_insertion_point(class_scope:svr_msg.TokenChangeNtf)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Msg_5fServer_2eproto;
};
// -------------------------------------------------------------------

class FightRoleSpawnInfo :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:svr_msg.FightRoleSpawnInfo) */ {
 public:
  FightRoleSpawnInfo();
  virtual ~FightRoleSpawnInfo();

  FightRoleSpawnInfo(const FightRoleSpawnInfo& from);
  FightRoleSpawnInfo(FightRoleSpawnInfo&& from) noexcept
    : FightRoleSpawnInfo() {
    *this = ::std::move(from);
  }

  inline FightRoleSpawnInfo& operator=(const FightRoleSpawnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FightRoleSpawnInfo& operator=(FightRoleSpawnInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const FightRoleSpawnInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FightRoleSpawnInfo* internal_default_instance() {
    return reinterpret_cast<const FightRoleSpawnInfo*>(
               &_FightRoleSpawnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FightRoleSpawnInfo& a, FightRoleSpawnInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FightRoleSpawnInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FightRoleSpawnInfo* New() const final {
    return CreateMaybeMessage<FightRoleSpawnInfo>(nullptr);
  }

  FightRoleSpawnInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FightRoleSpawnInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const FightRoleSpawnInfo& from);
  void MergeFrom(const FightRoleSpawnInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FightRoleSpawnInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "svr_msg.FightRoleSpawnInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleIdFieldNumber = 1,
    kOccFieldNumber = 2,
  };
  // int64 roleId = 1;
  void clear_roleid();
  ::PROTOBUF_NAMESPACE_ID::int64 roleid() const;
  void set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_roleid() const;
  void _internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 occ = 2;
  void clear_occ();
  ::PROTOBUF_NAMESPACE_ID::int32 occ() const;
  void set_occ(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_occ() const;
  void _internal_set_occ(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:svr_msg.FightRoleSpawnInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int64 roleid_;
  ::PROTOBUF_NAMESPACE_ID::int32 occ_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Msg_5fServer_2eproto;
};
// -------------------------------------------------------------------

class NewFightReq :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:svr_msg.NewFightReq) */ {
 public:
  NewFightReq();
  virtual ~NewFightReq();

  NewFightReq(const NewFightReq& from);
  NewFightReq(NewFightReq&& from) noexcept
    : NewFightReq() {
    *this = ::std::move(from);
  }

  inline NewFightReq& operator=(const NewFightReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewFightReq& operator=(NewFightReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NewFightReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewFightReq* internal_default_instance() {
    return reinterpret_cast<const NewFightReq*>(
               &_NewFightReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NewFightReq& a, NewFightReq& b) {
    a.Swap(&b);
  }
  inline void Swap(NewFightReq* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewFightReq* New() const final {
    return CreateMaybeMessage<NewFightReq>(nullptr);
  }

  NewFightReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewFightReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NewFightReq& from);
  void MergeFrom(const NewFightReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NewFightReq* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "svr_msg.NewFightReq";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NewFightReq_MsgId MsgId;
  static constexpr MsgId None =
    NewFightReq_MsgId_None;
  static constexpr MsgId Id =
    NewFightReq_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return NewFightReq_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    NewFightReq_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    NewFightReq_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    NewFightReq_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return NewFightReq_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return NewFightReq_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRolesFieldNumber = 2,
    kMapIdFieldNumber = 1,
    kTagFieldNumber = 3,
    kFightTypeFieldNumber = 4,
    kIsOfflineModeFieldNumber = 5,
  };
  // repeated .svr_msg.FightRoleSpawnInfo roles = 2;
  int roles_size() const;
  private:
  int _internal_roles_size() const;
  public:
  void clear_roles();
  ::svr_msg::FightRoleSpawnInfo* mutable_roles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >*
      mutable_roles();
  private:
  const ::svr_msg::FightRoleSpawnInfo& _internal_roles(int index) const;
  ::svr_msg::FightRoleSpawnInfo* _internal_add_roles();
  public:
  const ::svr_msg::FightRoleSpawnInfo& roles(int index) const;
  ::svr_msg::FightRoleSpawnInfo* add_roles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >&
      roles() const;

  // int32 mapId = 1;
  void clear_mapid();
  ::PROTOBUF_NAMESPACE_ID::int32 mapid() const;
  void set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_mapid() const;
  void _internal_set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 tag = 3;
  void clear_tag();
  ::PROTOBUF_NAMESPACE_ID::int32 tag() const;
  void set_tag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tag() const;
  void _internal_set_tag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 fightType = 4;
  void clear_fighttype();
  ::PROTOBUF_NAMESPACE_ID::int32 fighttype() const;
  void set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fighttype() const;
  void _internal_set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isOfflineMode = 5;
  void clear_isofflinemode();
  bool isofflinemode() const;
  void set_isofflinemode(bool value);
  private:
  bool _internal_isofflinemode() const;
  void _internal_set_isofflinemode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:svr_msg.NewFightReq)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo > roles_;
  ::PROTOBUF_NAMESPACE_ID::int32 mapid_;
  ::PROTOBUF_NAMESPACE_ID::int32 tag_;
  ::PROTOBUF_NAMESPACE_ID::int32 fighttype_;
  bool isofflinemode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Msg_5fServer_2eproto;
};
// -------------------------------------------------------------------

class NewFightAck :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:svr_msg.NewFightAck) */ {
 public:
  NewFightAck();
  virtual ~NewFightAck();

  NewFightAck(const NewFightAck& from);
  NewFightAck(NewFightAck&& from) noexcept
    : NewFightAck() {
    *this = ::std::move(from);
  }

  inline NewFightAck& operator=(const NewFightAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewFightAck& operator=(NewFightAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NewFightAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewFightAck* internal_default_instance() {
    return reinterpret_cast<const NewFightAck*>(
               &_NewFightAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NewFightAck& a, NewFightAck& b) {
    a.Swap(&b);
  }
  inline void Swap(NewFightAck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NewFightAck* New() const final {
    return CreateMaybeMessage<NewFightAck>(nullptr);
  }

  NewFightAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NewFightAck>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
    final;
  void CopyFrom(const NewFightAck& from);
  void MergeFrom(const NewFightAck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NewFightAck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "svr_msg.NewFightAck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NewFightAck_MsgId MsgId;
  static constexpr MsgId None =
    NewFightAck_MsgId_None;
  static constexpr MsgId Id =
    NewFightAck_MsgId_Id;
  static inline bool MsgId_IsValid(int value) {
    return NewFightAck_MsgId_IsValid(value);
  }
  static constexpr MsgId MsgId_MIN =
    NewFightAck_MsgId_MsgId_MIN;
  static constexpr MsgId MsgId_MAX =
    NewFightAck_MsgId_MsgId_MAX;
  static constexpr int MsgId_ARRAYSIZE =
    NewFightAck_MsgId_MsgId_ARRAYSIZE;
  template<typename T>
  static inline const std::string& MsgId_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MsgId>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MsgId_Name.");
    return NewFightAck_MsgId_Name(enum_t_value);
  }
  static inline bool MsgId_Parse(const std::string& name,
      MsgId* value) {
    return NewFightAck_MsgId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kUuidFieldNumber = 2,
    kTagFieldNumber = 3,
    kFightTypeFieldNumber = 4,
    kNetTypeFieldNumber = 5,
  };
  // int32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 uuid = 2;
  void clear_uuid();
  ::PROTOBUF_NAMESPACE_ID::int32 uuid() const;
  void set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_uuid() const;
  void _internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 tag = 3;
  void clear_tag();
  ::PROTOBUF_NAMESPACE_ID::int32 tag() const;
  void set_tag(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tag() const;
  void _internal_set_tag(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 fightType = 4;
  void clear_fighttype();
  ::PROTOBUF_NAMESPACE_ID::int32 fighttype() const;
  void set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_fighttype() const;
  void _internal_set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 netType = 5;
  void clear_nettype();
  ::PROTOBUF_NAMESPACE_ID::int32 nettype() const;
  void set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nettype() const;
  void _internal_set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:svr_msg.NewFightAck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  ::PROTOBUF_NAMESPACE_ID::int32 uuid_;
  ::PROTOBUF_NAMESPACE_ID::int32 tag_;
  ::PROTOBUF_NAMESPACE_ID::int32 fighttype_;
  ::PROTOBUF_NAMESPACE_ID::int32 nettype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Msg_5fServer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CheckTokenReq

// string account = 1;
inline void CheckTokenReq::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CheckTokenReq::account() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenReq.account)
  return _internal_account();
}
inline void CheckTokenReq::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenReq.account)
}
inline std::string* CheckTokenReq::mutable_account() {
  // @@protoc_insertion_point(field_mutable:svr_msg.CheckTokenReq.account)
  return _internal_mutable_account();
}
inline const std::string& CheckTokenReq::_internal_account() const {
  return account_.GetNoArena();
}
inline void CheckTokenReq::_internal_set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CheckTokenReq::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:svr_msg.CheckTokenReq.account)
}
inline void CheckTokenReq::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:svr_msg.CheckTokenReq.account)
}
inline void CheckTokenReq::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:svr_msg.CheckTokenReq.account)
}
inline std::string* CheckTokenReq::_internal_mutable_account() {
  
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckTokenReq::release_account() {
  // @@protoc_insertion_point(field_release:svr_msg.CheckTokenReq.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckTokenReq::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:svr_msg.CheckTokenReq.account)
}

// string token = 2;
inline void CheckTokenReq::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CheckTokenReq::token() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenReq.token)
  return _internal_token();
}
inline void CheckTokenReq::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenReq.token)
}
inline std::string* CheckTokenReq::mutable_token() {
  // @@protoc_insertion_point(field_mutable:svr_msg.CheckTokenReq.token)
  return _internal_mutable_token();
}
inline const std::string& CheckTokenReq::_internal_token() const {
  return token_.GetNoArena();
}
inline void CheckTokenReq::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CheckTokenReq::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:svr_msg.CheckTokenReq.token)
}
inline void CheckTokenReq::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:svr_msg.CheckTokenReq.token)
}
inline void CheckTokenReq::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:svr_msg.CheckTokenReq.token)
}
inline std::string* CheckTokenReq::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckTokenReq::release_token() {
  // @@protoc_insertion_point(field_release:svr_msg.CheckTokenReq.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckTokenReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:svr_msg.CheckTokenReq.token)
}

// int64 pid = 3;
inline void CheckTokenReq::clear_pid() {
  pid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CheckTokenReq::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CheckTokenReq::pid() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenReq.pid)
  return _internal_pid();
}
inline void CheckTokenReq::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void CheckTokenReq::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenReq.pid)
}

// uint32 session = 4;
inline void CheckTokenReq::clear_session() {
  session_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CheckTokenReq::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CheckTokenReq::session() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenReq.session)
  return _internal_session();
}
inline void CheckTokenReq::_internal_set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  session_ = value;
}
inline void CheckTokenReq::set_session(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenReq.session)
}

// -------------------------------------------------------------------

// CheckTokenAck

// int32 code = 1;
inline void CheckTokenAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CheckTokenAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CheckTokenAck::code() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenAck.code)
  return _internal_code();
}
inline void CheckTokenAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void CheckTokenAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenAck.code)
}

// int64 pid = 2;
inline void CheckTokenAck::clear_pid() {
  pid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CheckTokenAck::_internal_pid() const {
  return pid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CheckTokenAck::pid() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenAck.pid)
  return _internal_pid();
}
inline void CheckTokenAck::_internal_set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  pid_ = value;
}
inline void CheckTokenAck::set_pid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenAck.pid)
}

// int32 session = 3;
inline void CheckTokenAck::clear_session() {
  session_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CheckTokenAck::_internal_session() const {
  return session_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CheckTokenAck::session() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenAck.session)
  return _internal_session();
}
inline void CheckTokenAck::_internal_set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  session_ = value;
}
inline void CheckTokenAck::set_session(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_session(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenAck.session)
}

// string account = 4;
inline void CheckTokenAck::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CheckTokenAck::account() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenAck.account)
  return _internal_account();
}
inline void CheckTokenAck::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenAck.account)
}
inline std::string* CheckTokenAck::mutable_account() {
  // @@protoc_insertion_point(field_mutable:svr_msg.CheckTokenAck.account)
  return _internal_mutable_account();
}
inline const std::string& CheckTokenAck::_internal_account() const {
  return account_.GetNoArena();
}
inline void CheckTokenAck::_internal_set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CheckTokenAck::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:svr_msg.CheckTokenAck.account)
}
inline void CheckTokenAck::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:svr_msg.CheckTokenAck.account)
}
inline void CheckTokenAck::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:svr_msg.CheckTokenAck.account)
}
inline std::string* CheckTokenAck::_internal_mutable_account() {
  
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckTokenAck::release_account() {
  // @@protoc_insertion_point(field_release:svr_msg.CheckTokenAck.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckTokenAck::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:svr_msg.CheckTokenAck.account)
}

// string token = 5;
inline void CheckTokenAck::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CheckTokenAck::token() const {
  // @@protoc_insertion_point(field_get:svr_msg.CheckTokenAck.token)
  return _internal_token();
}
inline void CheckTokenAck::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:svr_msg.CheckTokenAck.token)
}
inline std::string* CheckTokenAck::mutable_token() {
  // @@protoc_insertion_point(field_mutable:svr_msg.CheckTokenAck.token)
  return _internal_mutable_token();
}
inline const std::string& CheckTokenAck::_internal_token() const {
  return token_.GetNoArena();
}
inline void CheckTokenAck::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CheckTokenAck::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:svr_msg.CheckTokenAck.token)
}
inline void CheckTokenAck::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:svr_msg.CheckTokenAck.token)
}
inline void CheckTokenAck::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:svr_msg.CheckTokenAck.token)
}
inline std::string* CheckTokenAck::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CheckTokenAck::release_token() {
  // @@protoc_insertion_point(field_release:svr_msg.CheckTokenAck.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CheckTokenAck::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:svr_msg.CheckTokenAck.token)
}

// -------------------------------------------------------------------

// TokenChangeNtf

// string token = 1;
inline void TokenChangeNtf::clear_token() {
  token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TokenChangeNtf::token() const {
  // @@protoc_insertion_point(field_get:svr_msg.TokenChangeNtf.token)
  return _internal_token();
}
inline void TokenChangeNtf::set_token(const std::string& value) {
  _internal_set_token(value);
  // @@protoc_insertion_point(field_set:svr_msg.TokenChangeNtf.token)
}
inline std::string* TokenChangeNtf::mutable_token() {
  // @@protoc_insertion_point(field_mutable:svr_msg.TokenChangeNtf.token)
  return _internal_mutable_token();
}
inline const std::string& TokenChangeNtf::_internal_token() const {
  return token_.GetNoArena();
}
inline void TokenChangeNtf::_internal_set_token(const std::string& value) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TokenChangeNtf::set_token(std::string&& value) {
  
  token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:svr_msg.TokenChangeNtf.token)
}
inline void TokenChangeNtf::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:svr_msg.TokenChangeNtf.token)
}
inline void TokenChangeNtf::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:svr_msg.TokenChangeNtf.token)
}
inline std::string* TokenChangeNtf::_internal_mutable_token() {
  
  return token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TokenChangeNtf::release_token() {
  // @@protoc_insertion_point(field_release:svr_msg.TokenChangeNtf.token)
  
  return token_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TokenChangeNtf::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:svr_msg.TokenChangeNtf.token)
}

// string account = 2;
inline void TokenChangeNtf::clear_account() {
  account_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TokenChangeNtf::account() const {
  // @@protoc_insertion_point(field_get:svr_msg.TokenChangeNtf.account)
  return _internal_account();
}
inline void TokenChangeNtf::set_account(const std::string& value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:svr_msg.TokenChangeNtf.account)
}
inline std::string* TokenChangeNtf::mutable_account() {
  // @@protoc_insertion_point(field_mutable:svr_msg.TokenChangeNtf.account)
  return _internal_mutable_account();
}
inline const std::string& TokenChangeNtf::_internal_account() const {
  return account_.GetNoArena();
}
inline void TokenChangeNtf::_internal_set_account(const std::string& value) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TokenChangeNtf::set_account(std::string&& value) {
  
  account_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:svr_msg.TokenChangeNtf.account)
}
inline void TokenChangeNtf::set_account(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:svr_msg.TokenChangeNtf.account)
}
inline void TokenChangeNtf::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:svr_msg.TokenChangeNtf.account)
}
inline std::string* TokenChangeNtf::_internal_mutable_account() {
  
  return account_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TokenChangeNtf::release_account() {
  // @@protoc_insertion_point(field_release:svr_msg.TokenChangeNtf.account)
  
  return account_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TokenChangeNtf::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:svr_msg.TokenChangeNtf.account)
}

// -------------------------------------------------------------------

// FightRoleSpawnInfo

// int64 roleId = 1;
inline void FightRoleSpawnInfo::clear_roleid() {
  roleid_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FightRoleSpawnInfo::_internal_roleid() const {
  return roleid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 FightRoleSpawnInfo::roleid() const {
  // @@protoc_insertion_point(field_get:svr_msg.FightRoleSpawnInfo.roleId)
  return _internal_roleid();
}
inline void FightRoleSpawnInfo::_internal_set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  roleid_ = value;
}
inline void FightRoleSpawnInfo::set_roleid(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_roleid(value);
  // @@protoc_insertion_point(field_set:svr_msg.FightRoleSpawnInfo.roleId)
}

// int32 occ = 2;
inline void FightRoleSpawnInfo::clear_occ() {
  occ_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightRoleSpawnInfo::_internal_occ() const {
  return occ_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FightRoleSpawnInfo::occ() const {
  // @@protoc_insertion_point(field_get:svr_msg.FightRoleSpawnInfo.occ)
  return _internal_occ();
}
inline void FightRoleSpawnInfo::_internal_set_occ(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  occ_ = value;
}
inline void FightRoleSpawnInfo::set_occ(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_occ(value);
  // @@protoc_insertion_point(field_set:svr_msg.FightRoleSpawnInfo.occ)
}

// -------------------------------------------------------------------

// NewFightReq

// int32 mapId = 1;
inline void NewFightReq::clear_mapid() {
  mapid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightReq::_internal_mapid() const {
  return mapid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightReq::mapid() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightReq.mapId)
  return _internal_mapid();
}
inline void NewFightReq::_internal_set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  mapid_ = value;
}
inline void NewFightReq::set_mapid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_mapid(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightReq.mapId)
}

// repeated .svr_msg.FightRoleSpawnInfo roles = 2;
inline int NewFightReq::_internal_roles_size() const {
  return roles_.size();
}
inline int NewFightReq::roles_size() const {
  return _internal_roles_size();
}
inline void NewFightReq::clear_roles() {
  roles_.Clear();
}
inline ::svr_msg::FightRoleSpawnInfo* NewFightReq::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:svr_msg.NewFightReq.roles)
  return roles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >*
NewFightReq::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:svr_msg.NewFightReq.roles)
  return &roles_;
}
inline const ::svr_msg::FightRoleSpawnInfo& NewFightReq::_internal_roles(int index) const {
  return roles_.Get(index);
}
inline const ::svr_msg::FightRoleSpawnInfo& NewFightReq::roles(int index) const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightReq.roles)
  return _internal_roles(index);
}
inline ::svr_msg::FightRoleSpawnInfo* NewFightReq::_internal_add_roles() {
  return roles_.Add();
}
inline ::svr_msg::FightRoleSpawnInfo* NewFightReq::add_roles() {
  // @@protoc_insertion_point(field_add:svr_msg.NewFightReq.roles)
  return _internal_add_roles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::svr_msg::FightRoleSpawnInfo >&
NewFightReq::roles() const {
  // @@protoc_insertion_point(field_list:svr_msg.NewFightReq.roles)
  return roles_;
}

// int32 tag = 3;
inline void NewFightReq::clear_tag() {
  tag_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightReq::_internal_tag() const {
  return tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightReq::tag() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightReq.tag)
  return _internal_tag();
}
inline void NewFightReq::_internal_set_tag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tag_ = value;
}
inline void NewFightReq::set_tag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightReq.tag)
}

// int32 fightType = 4;
inline void NewFightReq::clear_fighttype() {
  fighttype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightReq::_internal_fighttype() const {
  return fighttype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightReq::fighttype() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightReq.fightType)
  return _internal_fighttype();
}
inline void NewFightReq::_internal_set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fighttype_ = value;
}
inline void NewFightReq::set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fighttype(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightReq.fightType)
}

// bool isOfflineMode = 5;
inline void NewFightReq::clear_isofflinemode() {
  isofflinemode_ = false;
}
inline bool NewFightReq::_internal_isofflinemode() const {
  return isofflinemode_;
}
inline bool NewFightReq::isofflinemode() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightReq.isOfflineMode)
  return _internal_isofflinemode();
}
inline void NewFightReq::_internal_set_isofflinemode(bool value) {
  
  isofflinemode_ = value;
}
inline void NewFightReq::set_isofflinemode(bool value) {
  _internal_set_isofflinemode(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightReq.isOfflineMode)
}

// -------------------------------------------------------------------

// NewFightAck

// int32 code = 1;
inline void NewFightAck::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::code() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightAck.code)
  return _internal_code();
}
inline void NewFightAck::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void NewFightAck::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightAck.code)
}

// int32 uuid = 2;
inline void NewFightAck::clear_uuid() {
  uuid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::_internal_uuid() const {
  return uuid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::uuid() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightAck.uuid)
  return _internal_uuid();
}
inline void NewFightAck::_internal_set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  uuid_ = value;
}
inline void NewFightAck::set_uuid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_uuid(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightAck.uuid)
}

// int32 tag = 3;
inline void NewFightAck::clear_tag() {
  tag_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::_internal_tag() const {
  return tag_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::tag() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightAck.tag)
  return _internal_tag();
}
inline void NewFightAck::_internal_set_tag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tag_ = value;
}
inline void NewFightAck::set_tag(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tag(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightAck.tag)
}

// int32 fightType = 4;
inline void NewFightAck::clear_fighttype() {
  fighttype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::_internal_fighttype() const {
  return fighttype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::fighttype() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightAck.fightType)
  return _internal_fighttype();
}
inline void NewFightAck::_internal_set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  fighttype_ = value;
}
inline void NewFightAck::set_fighttype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_fighttype(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightAck.fightType)
}

// int32 netType = 5;
inline void NewFightAck::clear_nettype() {
  nettype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::_internal_nettype() const {
  return nettype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NewFightAck::nettype() const {
  // @@protoc_insertion_point(field_get:svr_msg.NewFightAck.netType)
  return _internal_nettype();
}
inline void NewFightAck::_internal_set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nettype_ = value;
}
inline void NewFightAck::set_nettype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nettype(value);
  // @@protoc_insertion_point(field_set:svr_msg.NewFightAck.netType)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace svr_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::svr_msg::CheckTokenReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::svr_msg::CheckTokenAck_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::svr_msg::TokenChangeNtf_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::svr_msg::NewFightReq_MsgId> : ::std::true_type {};
template <> struct is_proto_enum< ::svr_msg::NewFightAck_MsgId> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Msg_5fServer_2eproto
