// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_Game.proto

#ifndef PROTOBUF_Msg_5fGame_2eproto__INCLUDED
#define PROTOBUF_Msg_5fGame_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Msg_5fGame_2eproto();
void protobuf_AssignDesc_Msg_5fGame_2eproto();
void protobuf_ShutdownFile_Msg_5fGame_2eproto();

class Null;
class CodeAck;
class LoginGateAck;
class LoginReq;
class PlayerAccountInfo;
class RoleInfo;
class LoginAck;
class EnterGameReq;
class EnterGameAck;
class CreateRoleReq;
class CreateRoleAck;
class ExitGameNtf;
class PVEFightPlayerInfo;
class StartPVEFightReq;
class StartPVEFightAck;
class StartPVPFightReq;
class StartPVPFightAck;
class StartFightNTF;
class JoinFightReq;
class JoinFightAck;
class PlayerReadyNotify;
class PlayerExitFightNotify;
class RunNextFrameReq;
class RunNextFrameAck;
class ExitFightReq;
class ExitFightAck;

// ===================================================================

class Null : public ::google::protobuf::MessageLite {
 public:
  Null();
  virtual ~Null();

  Null(const Null& from);

  inline Null& operator=(const Null& from) {
    CopyFrom(from);
    return *this;
  }

  static const Null& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Null* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Null* other);

  // implements Message ----------------------------------------------

  Null* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Null& from);
  void MergeFrom(const Null& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.Null)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static Null* default_instance_;
};
// -------------------------------------------------------------------

class CodeAck : public ::google::protobuf::MessageLite {
 public:
  CodeAck();
  virtual ~CodeAck();

  CodeAck(const CodeAck& from);

  inline CodeAck& operator=(const CodeAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CodeAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CodeAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CodeAck* other);

  // implements Message ----------------------------------------------

  CodeAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CodeAck& from);
  void MergeFrom(const CodeAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.CodeAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static CodeAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginGateAck : public ::google::protobuf::MessageLite {
 public:
  LoginGateAck();
  virtual ~LoginGateAck();

  LoginGateAck(const LoginGateAck& from);

  inline LoginGateAck& operator=(const LoginGateAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginGateAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginGateAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginGateAck* other);

  // implements Message ----------------------------------------------

  LoginGateAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginGateAck& from);
  void MergeFrom(const LoginGateAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.LoginGateAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static LoginGateAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::MessageLite {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required int64 playerID = 3;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 3;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.LoginReq)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string* token_;
  ::std::string* account_;
  ::google::protobuf::int64 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAccountInfo : public ::google::protobuf::MessageLite {
 public:
  PlayerAccountInfo();
  virtual ~PlayerAccountInfo();

  PlayerAccountInfo(const PlayerAccountInfo& from);

  inline PlayerAccountInfo& operator=(const PlayerAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerAccountInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerAccountInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerAccountInfo* other);

  // implements Message ----------------------------------------------

  PlayerAccountInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerAccountInfo& from);
  void MergeFrom(const PlayerAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int64 arrRoleIds = 3;
  inline int arrroleids_size() const;
  inline void clear_arrroleids();
  static const int kArrRoleIdsFieldNumber = 3;
  inline ::google::protobuf::int64 arrroleids(int index) const;
  inline void set_arrroleids(int index, ::google::protobuf::int64 value);
  inline void add_arrroleids(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      arrroleids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_arrroleids();

  // @@protoc_insertion_point(class_scope:msg.PlayerAccountInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::int64 playerid_;
  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > arrroleids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoleInfo : public ::google::protobuf::MessageLite {
 public:
  RoleInfo();
  virtual ~RoleInfo();

  RoleInfo(const RoleInfo& from);

  inline RoleInfo& operator=(const RoleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoleInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoleInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoleInfo* other);

  // implements Message ----------------------------------------------

  RoleInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoleInfo& from);
  void MergeFrom(const RoleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // required int32 occupation = 4;
  inline bool has_occupation() const;
  inline void clear_occupation();
  static const int kOccupationFieldNumber = 4;
  inline ::google::protobuf::int32 occupation() const;
  inline void set_occupation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.RoleInfo)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_occupation();
  inline void clear_has_occupation();

  ::google::protobuf::int64 roleid_;
  ::std::string* name_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 occupation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static RoleInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginAck : public ::google::protobuf::MessageLite {
 public:
  LoginAck();
  virtual ~LoginAck();

  LoginAck(const LoginAck& from);

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginAck* other);

  // implements Message ----------------------------------------------

  LoginAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginAck& from);
  void MergeFrom(const LoginAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // repeated .msg.PlayerAccountInfo infos = 2;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 2;
  inline const ::msg::PlayerAccountInfo& infos(int index) const;
  inline ::msg::PlayerAccountInfo* mutable_infos(int index);
  inline ::msg::PlayerAccountInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:msg.LoginAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo > infos_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static LoginAck* default_instance_;
};
// -------------------------------------------------------------------

class EnterGameReq : public ::google::protobuf::MessageLite {
 public:
  EnterGameReq();
  virtual ~EnterGameReq();

  EnterGameReq(const EnterGameReq& from);

  inline EnterGameReq& operator=(const EnterGameReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGameReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGameReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGameReq* other);

  // implements Message ----------------------------------------------

  EnterGameReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGameReq& from);
  void MergeFrom(const EnterGameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required int64 playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // required int64 roleID = 3;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIDFieldNumber = 3;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.EnterGameReq)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::std::string* token_;
  ::google::protobuf::int64 playerid_;
  ::google::protobuf::int64 roleid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static EnterGameReq* default_instance_;
};
// -------------------------------------------------------------------

class EnterGameAck : public ::google::protobuf::MessageLite {
 public:
  EnterGameAck();
  virtual ~EnterGameAck();

  EnterGameAck(const EnterGameAck& from);

  inline EnterGameAck& operator=(const EnterGameAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGameAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGameAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGameAck* other);

  // implements Message ----------------------------------------------

  EnterGameAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGameAck& from);
  void MergeFrom(const EnterGameAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional .msg.RoleInfo roleinfo = 2;
  inline bool has_roleinfo() const;
  inline void clear_roleinfo();
  static const int kRoleinfoFieldNumber = 2;
  inline const ::msg::RoleInfo& roleinfo() const;
  inline ::msg::RoleInfo* mutable_roleinfo();
  inline ::msg::RoleInfo* release_roleinfo();
  inline void set_allocated_roleinfo(::msg::RoleInfo* roleinfo);

  // @@protoc_insertion_point(class_scope:msg.EnterGameAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roleinfo();
  inline void clear_has_roleinfo();

  ::msg::RoleInfo* roleinfo_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static EnterGameAck* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoleReq : public ::google::protobuf::MessageLite {
 public:
  CreateRoleReq();
  virtual ~CreateRoleReq();

  CreateRoleReq(const CreateRoleReq& from);

  inline CreateRoleReq& operator=(const CreateRoleReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateRoleReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateRoleReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateRoleReq* other);

  // implements Message ----------------------------------------------

  CreateRoleReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateRoleReq& from);
  void MergeFrom(const CreateRoleReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 occupation = 1;
  inline bool has_occupation() const;
  inline void clear_occupation();
  static const int kOccupationFieldNumber = 1;
  inline ::google::protobuf::int32 occupation() const;
  inline void set_occupation(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:msg.CreateRoleReq)
 private:
  inline void set_has_occupation();
  inline void clear_has_occupation();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::int32 occupation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static CreateRoleReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoleAck : public ::google::protobuf::MessageLite {
 public:
  CreateRoleAck();
  virtual ~CreateRoleAck();

  CreateRoleAck(const CreateRoleAck& from);

  inline CreateRoleAck& operator=(const CreateRoleAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateRoleAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateRoleAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateRoleAck* other);

  // implements Message ----------------------------------------------

  CreateRoleAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateRoleAck& from);
  void MergeFrom(const CreateRoleAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required int64 roleID = 2;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIDFieldNumber = 2;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.CreateRoleAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::google::protobuf::int64 roleid_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static CreateRoleAck* default_instance_;
};
// -------------------------------------------------------------------

class ExitGameNtf : public ::google::protobuf::MessageLite {
 public:
  ExitGameNtf();
  virtual ~ExitGameNtf();

  ExitGameNtf(const ExitGameNtf& from);

  inline ExitGameNtf& operator=(const ExitGameNtf& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExitGameNtf& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExitGameNtf* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExitGameNtf* other);

  // implements Message ----------------------------------------------

  ExitGameNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExitGameNtf& from);
  void MergeFrom(const ExitGameNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.ExitGameNtf)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static ExitGameNtf* default_instance_;
};
// -------------------------------------------------------------------

class PVEFightPlayerInfo : public ::google::protobuf::MessageLite {
 public:
  PVEFightPlayerInfo();
  virtual ~PVEFightPlayerInfo();

  PVEFightPlayerInfo(const PVEFightPlayerInfo& from);

  inline PVEFightPlayerInfo& operator=(const PVEFightPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PVEFightPlayerInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PVEFightPlayerInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PVEFightPlayerInfo* other);

  // implements Message ----------------------------------------------

  PVEFightPlayerInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PVEFightPlayerInfo& from);
  void MergeFrom(const PVEFightPlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.PVEFightPlayerInfo)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::int64 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PVEFightPlayerInfo* default_instance_;
};
// -------------------------------------------------------------------

class StartPVEFightReq : public ::google::protobuf::MessageLite {
 public:
  StartPVEFightReq();
  virtual ~StartPVEFightReq();

  StartPVEFightReq(const StartPVEFightReq& from);

  inline StartPVEFightReq& operator=(const StartPVEFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVEFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVEFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVEFightReq* other);

  // implements Message ----------------------------------------------

  StartPVEFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVEFightReq& from);
  void MergeFrom(const StartPVEFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 carbonId = 1;
  inline bool has_carbonid() const;
  inline void clear_carbonid();
  static const int kCarbonIdFieldNumber = 1;
  inline ::google::protobuf::int32 carbonid() const;
  inline void set_carbonid(::google::protobuf::int32 value);

  // repeated .msg.PVEFightPlayerInfo infos = 2;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 2;
  inline const ::msg::PVEFightPlayerInfo& infos(int index) const;
  inline ::msg::PVEFightPlayerInfo* mutable_infos(int index);
  inline ::msg::PVEFightPlayerInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PVEFightPlayerInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PVEFightPlayerInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:msg.StartPVEFightReq)
 private:
  inline void set_has_carbonid();
  inline void clear_has_carbonid();

  ::google::protobuf::RepeatedPtrField< ::msg::PVEFightPlayerInfo > infos_;
  ::google::protobuf::int32 carbonid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVEFightReq* default_instance_;
};
// -------------------------------------------------------------------

class StartPVEFightAck : public ::google::protobuf::MessageLite {
 public:
  StartPVEFightAck();
  virtual ~StartPVEFightAck();

  StartPVEFightAck(const StartPVEFightAck& from);

  inline StartPVEFightAck& operator=(const StartPVEFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVEFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVEFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVEFightAck* other);

  // implements Message ----------------------------------------------

  StartPVEFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVEFightAck& from);
  void MergeFrom(const StartPVEFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.StartPVEFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVEFightAck* default_instance_;
};
// -------------------------------------------------------------------

class StartPVPFightReq : public ::google::protobuf::MessageLite {
 public:
  StartPVPFightReq();
  virtual ~StartPVPFightReq();

  StartPVPFightReq(const StartPVPFightReq& from);

  inline StartPVPFightReq& operator=(const StartPVPFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVPFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVPFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVPFightReq* other);

  // implements Message ----------------------------------------------

  StartPVPFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVPFightReq& from);
  void MergeFrom(const StartPVPFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 foeId = 1;
  inline bool has_foeid() const;
  inline void clear_foeid();
  static const int kFoeIdFieldNumber = 1;
  inline ::google::protobuf::int64 foeid() const;
  inline void set_foeid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.StartPVPFightReq)
 private:
  inline void set_has_foeid();
  inline void clear_has_foeid();

  ::google::protobuf::int64 foeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVPFightReq* default_instance_;
};
// -------------------------------------------------------------------

class StartPVPFightAck : public ::google::protobuf::MessageLite {
 public:
  StartPVPFightAck();
  virtual ~StartPVPFightAck();

  StartPVPFightAck(const StartPVPFightAck& from);

  inline StartPVPFightAck& operator=(const StartPVPFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVPFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVPFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVPFightAck* other);

  // implements Message ----------------------------------------------

  StartPVPFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVPFightAck& from);
  void MergeFrom(const StartPVPFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.StartPVPFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVPFightAck* default_instance_;
};
// -------------------------------------------------------------------

class StartFightNTF : public ::google::protobuf::MessageLite {
 public:
  StartFightNTF();
  virtual ~StartFightNTF();

  StartFightNTF(const StartFightNTF& from);

  inline StartFightNTF& operator=(const StartFightNTF& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartFightNTF& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartFightNTF* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartFightNTF* other);

  // implements Message ----------------------------------------------

  StartFightNTF* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartFightNTF& from);
  void MergeFrom(const StartFightNTF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional int32 fightUUID = 2;
  inline bool has_fightuuid() const;
  inline void clear_fightuuid();
  static const int kFightUUIDFieldNumber = 2;
  inline ::google::protobuf::int32 fightuuid() const;
  inline void set_fightuuid(::google::protobuf::int32 value);

  // optional string fightIP = 3;
  inline bool has_fightip() const;
  inline void clear_fightip();
  static const int kFightIPFieldNumber = 3;
  inline const ::std::string& fightip() const;
  inline void set_fightip(const ::std::string& value);
  inline void set_fightip(const char* value);
  inline void set_fightip(const char* value, size_t size);
  inline ::std::string* mutable_fightip();
  inline ::std::string* release_fightip();
  inline void set_allocated_fightip(::std::string* fightip);

  // optional int32 fightPort = 4;
  inline bool has_fightport() const;
  inline void clear_fightport();
  static const int kFightPortFieldNumber = 4;
  inline ::google::protobuf::int32 fightport() const;
  inline void set_fightport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.StartFightNTF)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_fightuuid();
  inline void clear_has_fightuuid();
  inline void set_has_fightip();
  inline void clear_has_fightip();
  inline void set_has_fightport();
  inline void clear_has_fightport();

  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 fightuuid_;
  ::std::string* fightip_;
  ::google::protobuf::int32 fightport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartFightNTF* default_instance_;
};
// -------------------------------------------------------------------

class JoinFightReq : public ::google::protobuf::MessageLite {
 public:
  JoinFightReq();
  virtual ~JoinFightReq();

  JoinFightReq(const JoinFightReq& from);

  inline JoinFightReq& operator=(const JoinFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const JoinFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinFightReq* other);

  // implements Message ----------------------------------------------

  JoinFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinFightReq& from);
  void MergeFrom(const JoinFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 fightUUID = 1;
  inline bool has_fightuuid() const;
  inline void clear_fightuuid();
  static const int kFightUUIDFieldNumber = 1;
  inline ::google::protobuf::int32 fightuuid() const;
  inline void set_fightuuid(::google::protobuf::int32 value);

  // required int64 playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // required int32 frame = 3;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 3;
  inline ::google::protobuf::int32 frame() const;
  inline void set_frame(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.JoinFightReq)
 private:
  inline void set_has_fightuuid();
  inline void clear_has_fightuuid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_frame();
  inline void clear_has_frame();

  ::google::protobuf::int64 playerid_;
  ::google::protobuf::int32 fightuuid_;
  ::google::protobuf::int32 frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static JoinFightReq* default_instance_;
};
// -------------------------------------------------------------------

class JoinFightAck : public ::google::protobuf::MessageLite {
 public:
  JoinFightAck();
  virtual ~JoinFightAck();

  JoinFightAck(const JoinFightAck& from);

  inline JoinFightAck& operator=(const JoinFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const JoinFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinFightAck* other);

  // implements Message ----------------------------------------------

  JoinFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinFightAck& from);
  void MergeFrom(const JoinFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional int32 mapId = 2;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 2;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // optional uint32 randomSeed = 3;
  inline bool has_randomseed() const;
  inline void clear_randomseed();
  static const int kRandomSeedFieldNumber = 3;
  inline ::google::protobuf::uint32 randomseed() const;
  inline void set_randomseed(::google::protobuf::uint32 value);

  // optional uint32 uuidSeed = 4;
  inline bool has_uuidseed() const;
  inline void clear_uuidseed();
  static const int kUuidSeedFieldNumber = 4;
  inline ::google::protobuf::uint32 uuidseed() const;
  inline void set_uuidseed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:msg.JoinFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_randomseed();
  inline void clear_has_randomseed();
  inline void set_has_uuidseed();
  inline void clear_has_uuidseed();

  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::uint32 randomseed_;
  ::google::protobuf::uint32 uuidseed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static JoinFightAck* default_instance_;
};
// -------------------------------------------------------------------

class PlayerReadyNotify : public ::google::protobuf::MessageLite {
 public:
  PlayerReadyNotify();
  virtual ~PlayerReadyNotify();

  PlayerReadyNotify(const PlayerReadyNotify& from);

  inline PlayerReadyNotify& operator=(const PlayerReadyNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerReadyNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerReadyNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerReadyNotify* other);

  // implements Message ----------------------------------------------

  PlayerReadyNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerReadyNotify& from);
  void MergeFrom(const PlayerReadyNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.PlayerReadyNotify)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::int64 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerReadyNotify* default_instance_;
};
// -------------------------------------------------------------------

class PlayerExitFightNotify : public ::google::protobuf::MessageLite {
 public:
  PlayerExitFightNotify();
  virtual ~PlayerExitFightNotify();

  PlayerExitFightNotify(const PlayerExitFightNotify& from);

  inline PlayerExitFightNotify& operator=(const PlayerExitFightNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerExitFightNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerExitFightNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerExitFightNotify* other);

  // implements Message ----------------------------------------------

  PlayerExitFightNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerExitFightNotify& from);
  void MergeFrom(const PlayerExitFightNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.PlayerExitFightNotify)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::int64 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerExitFightNotify* default_instance_;
};
// -------------------------------------------------------------------

class RunNextFrameReq : public ::google::protobuf::MessageLite {
 public:
  RunNextFrameReq();
  virtual ~RunNextFrameReq();

  RunNextFrameReq(const RunNextFrameReq& from);

  inline RunNextFrameReq& operator=(const RunNextFrameReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RunNextFrameReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RunNextFrameReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RunNextFrameReq* other);

  // implements Message ----------------------------------------------

  RunNextFrameReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RunNextFrameReq& from);
  void MergeFrom(const RunNextFrameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 frame = 1;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 1;
  inline ::google::protobuf::uint32 frame() const;
  inline void set_frame(::google::protobuf::uint32 value);

  // repeated string input = 2;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::std::string& input(int index) const;
  inline ::std::string* mutable_input(int index);
  inline void set_input(int index, const ::std::string& value);
  inline void set_input(int index, const char* value);
  inline void set_input(int index, const char* value, size_t size);
  inline ::std::string* add_input();
  inline void add_input(const ::std::string& value);
  inline void add_input(const char* value);
  inline void add_input(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // @@protoc_insertion_point(class_scope:msg.RunNextFrameReq)
 private:
  inline void set_has_frame();
  inline void clear_has_frame();

  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::uint32 frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static RunNextFrameReq* default_instance_;
};
// -------------------------------------------------------------------

class RunNextFrameAck : public ::google::protobuf::MessageLite {
 public:
  RunNextFrameAck();
  virtual ~RunNextFrameAck();

  RunNextFrameAck(const RunNextFrameAck& from);

  inline RunNextFrameAck& operator=(const RunNextFrameAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const RunNextFrameAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RunNextFrameAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RunNextFrameAck* other);

  // implements Message ----------------------------------------------

  RunNextFrameAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RunNextFrameAck& from);
  void MergeFrom(const RunNextFrameAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 frame = 1;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 1;
  inline ::google::protobuf::uint32 frame() const;
  inline void set_frame(::google::protobuf::uint32 value);

  // repeated string inputs = 2;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 2;
  inline const ::std::string& inputs(int index) const;
  inline ::std::string* mutable_inputs(int index);
  inline void set_inputs(int index, const ::std::string& value);
  inline void set_inputs(int index, const char* value);
  inline void set_inputs(int index, const char* value, size_t size);
  inline ::std::string* add_inputs();
  inline void add_inputs(const ::std::string& value);
  inline void add_inputs(const char* value);
  inline void add_inputs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_inputs();

  // @@protoc_insertion_point(class_scope:msg.RunNextFrameAck)
 private:
  inline void set_has_frame();
  inline void clear_has_frame();

  ::google::protobuf::RepeatedPtrField< ::std::string> inputs_;
  ::google::protobuf::uint32 frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static RunNextFrameAck* default_instance_;
};
// -------------------------------------------------------------------

class ExitFightReq : public ::google::protobuf::MessageLite {
 public:
  ExitFightReq();
  virtual ~ExitFightReq();

  ExitFightReq(const ExitFightReq& from);

  inline ExitFightReq& operator=(const ExitFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExitFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExitFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExitFightReq* other);

  // implements Message ----------------------------------------------

  ExitFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExitFightReq& from);
  void MergeFrom(const ExitFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 fightUUID = 1;
  inline bool has_fightuuid() const;
  inline void clear_fightuuid();
  static const int kFightUUIDFieldNumber = 1;
  inline ::google::protobuf::int32 fightuuid() const;
  inline void set_fightuuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.ExitFightReq)
 private:
  inline void set_has_fightuuid();
  inline void clear_has_fightuuid();

  ::google::protobuf::int32 fightuuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static ExitFightReq* default_instance_;
};
// -------------------------------------------------------------------

class ExitFightAck : public ::google::protobuf::MessageLite {
 public:
  ExitFightAck();
  virtual ~ExitFightAck();

  ExitFightAck(const ExitFightAck& from);

  inline ExitFightAck& operator=(const ExitFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExitFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExitFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExitFightAck* other);

  // implements Message ----------------------------------------------

  ExitFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExitFightAck& from);
  void MergeFrom(const ExitFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.ExitFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static ExitFightAck* default_instance_;
};
// ===================================================================


// ===================================================================

// Null

// -------------------------------------------------------------------

// CodeAck

// required int32 code = 1;
inline bool CodeAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodeAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CodeAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CodeAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CodeAck::code() const {
  return code_;
}
inline void CodeAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// LoginGateAck

// required int32 code = 1;
inline bool LoginGateAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGateAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGateAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGateAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LoginGateAck::code() const {
  return code_;
}
inline void LoginGateAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// LoginReq

// required string token = 1;
inline bool LoginReq::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LoginReq::token() const {
  return *token_;
}
inline void LoginReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* LoginReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string account = 2;
inline bool LoginReq::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LoginReq::account() const {
  return *account_;
}
inline void LoginReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LoginReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 playerID = 3;
inline bool LoginReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 LoginReq::playerid() const {
  return playerid_;
}
inline void LoginReq::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// PlayerAccountInfo

// required int64 playerID = 1;
inline bool PlayerAccountInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAccountInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAccountInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAccountInfo::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 PlayerAccountInfo::playerid() const {
  return playerid_;
}
inline void PlayerAccountInfo::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// required string name = 2;
inline bool PlayerAccountInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAccountInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAccountInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAccountInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerAccountInfo::name() const {
  return *name_;
}
inline void PlayerAccountInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerAccountInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerAccountInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerAccountInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayerAccountInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerAccountInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int64 arrRoleIds = 3;
inline int PlayerAccountInfo::arrroleids_size() const {
  return arrroleids_.size();
}
inline void PlayerAccountInfo::clear_arrroleids() {
  arrroleids_.Clear();
}
inline ::google::protobuf::int64 PlayerAccountInfo::arrroleids(int index) const {
  return arrroleids_.Get(index);
}
inline void PlayerAccountInfo::set_arrroleids(int index, ::google::protobuf::int64 value) {
  arrroleids_.Set(index, value);
}
inline void PlayerAccountInfo::add_arrroleids(::google::protobuf::int64 value) {
  arrroleids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PlayerAccountInfo::arrroleids() const {
  return arrroleids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PlayerAccountInfo::mutable_arrroleids() {
  return &arrroleids_;
}

// -------------------------------------------------------------------

// RoleInfo

// required int64 roleId = 1;
inline bool RoleInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleInfo::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 RoleInfo::roleid() const {
  return roleid_;
}
inline void RoleInfo::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// required string name = 2;
inline bool RoleInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoleInfo::name() const {
  return *name_;
}
inline void RoleInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoleInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 lv = 3;
inline bool RoleInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 RoleInfo::lv() const {
  return lv_;
}
inline void RoleInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// required int32 occupation = 4;
inline bool RoleInfo::has_occupation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleInfo::set_has_occupation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleInfo::clear_has_occupation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleInfo::clear_occupation() {
  occupation_ = 0;
  clear_has_occupation();
}
inline ::google::protobuf::int32 RoleInfo::occupation() const {
  return occupation_;
}
inline void RoleInfo::set_occupation(::google::protobuf::int32 value) {
  set_has_occupation();
  occupation_ = value;
}

// -------------------------------------------------------------------

// LoginAck

// required int32 code = 1;
inline bool LoginAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LoginAck::code() const {
  return code_;
}
inline void LoginAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// repeated .msg.PlayerAccountInfo infos = 2;
inline int LoginAck::infos_size() const {
  return infos_.size();
}
inline void LoginAck::clear_infos() {
  infos_.Clear();
}
inline const ::msg::PlayerAccountInfo& LoginAck::infos(int index) const {
  return infos_.Get(index);
}
inline ::msg::PlayerAccountInfo* LoginAck::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::msg::PlayerAccountInfo* LoginAck::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >&
LoginAck::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >*
LoginAck::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// EnterGameReq

// required string token = 1;
inline bool EnterGameReq::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGameReq::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGameReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGameReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& EnterGameReq::token() const {
  return *token_;
}
inline void EnterGameReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void EnterGameReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void EnterGameReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterGameReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* EnterGameReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterGameReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 playerID = 2;
inline bool EnterGameReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterGameReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterGameReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterGameReq::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 EnterGameReq::playerid() const {
  return playerid_;
}
inline void EnterGameReq::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// required int64 roleID = 3;
inline bool EnterGameReq::has_roleid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterGameReq::set_has_roleid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterGameReq::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterGameReq::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 EnterGameReq::roleid() const {
  return roleid_;
}
inline void EnterGameReq::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// EnterGameAck

// required int32 code = 1;
inline bool EnterGameAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGameAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGameAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGameAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 EnterGameAck::code() const {
  return code_;
}
inline void EnterGameAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional .msg.RoleInfo roleinfo = 2;
inline bool EnterGameAck::has_roleinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterGameAck::set_has_roleinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterGameAck::clear_has_roleinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterGameAck::clear_roleinfo() {
  if (roleinfo_ != NULL) roleinfo_->::msg::RoleInfo::Clear();
  clear_has_roleinfo();
}
inline const ::msg::RoleInfo& EnterGameAck::roleinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return roleinfo_ != NULL ? *roleinfo_ : *default_instance().roleinfo_;
#else
  return roleinfo_ != NULL ? *roleinfo_ : *default_instance_->roleinfo_;
#endif
}
inline ::msg::RoleInfo* EnterGameAck::mutable_roleinfo() {
  set_has_roleinfo();
  if (roleinfo_ == NULL) roleinfo_ = new ::msg::RoleInfo;
  return roleinfo_;
}
inline ::msg::RoleInfo* EnterGameAck::release_roleinfo() {
  clear_has_roleinfo();
  ::msg::RoleInfo* temp = roleinfo_;
  roleinfo_ = NULL;
  return temp;
}
inline void EnterGameAck::set_allocated_roleinfo(::msg::RoleInfo* roleinfo) {
  delete roleinfo_;
  roleinfo_ = roleinfo;
  if (roleinfo) {
    set_has_roleinfo();
  } else {
    clear_has_roleinfo();
  }
}

// -------------------------------------------------------------------

// CreateRoleReq

// required int32 occupation = 1;
inline bool CreateRoleReq::has_occupation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleReq::set_has_occupation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleReq::clear_has_occupation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleReq::clear_occupation() {
  occupation_ = 0;
  clear_has_occupation();
}
inline ::google::protobuf::int32 CreateRoleReq::occupation() const {
  return occupation_;
}
inline void CreateRoleReq::set_occupation(::google::protobuf::int32 value) {
  set_has_occupation();
  occupation_ = value;
}

// required string name = 2;
inline bool CreateRoleReq::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoleReq::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoleReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoleReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateRoleReq::name() const {
  return *name_;
}
inline void CreateRoleReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoleReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoleReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoleReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateRoleReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoleReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateRoleAck

// required int32 code = 1;
inline bool CreateRoleAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CreateRoleAck::code() const {
  return code_;
}
inline void CreateRoleAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required int64 roleID = 2;
inline bool CreateRoleAck::has_roleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoleAck::set_has_roleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoleAck::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoleAck::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 CreateRoleAck::roleid() const {
  return roleid_;
}
inline void CreateRoleAck::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// ExitGameNtf

// required int32 code = 1;
inline bool ExitGameNtf::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitGameNtf::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitGameNtf::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitGameNtf::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ExitGameNtf::code() const {
  return code_;
}
inline void ExitGameNtf::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// PVEFightPlayerInfo

// required int64 pid = 1;
inline bool PVEFightPlayerInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVEFightPlayerInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVEFightPlayerInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVEFightPlayerInfo::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 PVEFightPlayerInfo::pid() const {
  return pid_;
}
inline void PVEFightPlayerInfo::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// -------------------------------------------------------------------

// StartPVEFightReq

// required int32 carbonId = 1;
inline bool StartPVEFightReq::has_carbonid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVEFightReq::set_has_carbonid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVEFightReq::clear_has_carbonid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVEFightReq::clear_carbonid() {
  carbonid_ = 0;
  clear_has_carbonid();
}
inline ::google::protobuf::int32 StartPVEFightReq::carbonid() const {
  return carbonid_;
}
inline void StartPVEFightReq::set_carbonid(::google::protobuf::int32 value) {
  set_has_carbonid();
  carbonid_ = value;
}

// repeated .msg.PVEFightPlayerInfo infos = 2;
inline int StartPVEFightReq::infos_size() const {
  return infos_.size();
}
inline void StartPVEFightReq::clear_infos() {
  infos_.Clear();
}
inline const ::msg::PVEFightPlayerInfo& StartPVEFightReq::infos(int index) const {
  return infos_.Get(index);
}
inline ::msg::PVEFightPlayerInfo* StartPVEFightReq::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::msg::PVEFightPlayerInfo* StartPVEFightReq::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PVEFightPlayerInfo >&
StartPVEFightReq::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PVEFightPlayerInfo >*
StartPVEFightReq::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// StartPVEFightAck

// required int32 code = 1;
inline bool StartPVEFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVEFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVEFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVEFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StartPVEFightAck::code() const {
  return code_;
}
inline void StartPVEFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// StartPVPFightReq

// required int64 foeId = 1;
inline bool StartPVPFightReq::has_foeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVPFightReq::set_has_foeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVPFightReq::clear_has_foeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVPFightReq::clear_foeid() {
  foeid_ = GOOGLE_LONGLONG(0);
  clear_has_foeid();
}
inline ::google::protobuf::int64 StartPVPFightReq::foeid() const {
  return foeid_;
}
inline void StartPVPFightReq::set_foeid(::google::protobuf::int64 value) {
  set_has_foeid();
  foeid_ = value;
}

// -------------------------------------------------------------------

// StartPVPFightAck

// required int32 code = 1;
inline bool StartPVPFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVPFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVPFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVPFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StartPVPFightAck::code() const {
  return code_;
}
inline void StartPVPFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// StartFightNTF

// required int32 code = 1;
inline bool StartFightNTF::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartFightNTF::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartFightNTF::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartFightNTF::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StartFightNTF::code() const {
  return code_;
}
inline void StartFightNTF::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional int32 fightUUID = 2;
inline bool StartFightNTF::has_fightuuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartFightNTF::set_has_fightuuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartFightNTF::clear_has_fightuuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartFightNTF::clear_fightuuid() {
  fightuuid_ = 0;
  clear_has_fightuuid();
}
inline ::google::protobuf::int32 StartFightNTF::fightuuid() const {
  return fightuuid_;
}
inline void StartFightNTF::set_fightuuid(::google::protobuf::int32 value) {
  set_has_fightuuid();
  fightuuid_ = value;
}

// optional string fightIP = 3;
inline bool StartFightNTF::has_fightip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartFightNTF::set_has_fightip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartFightNTF::clear_has_fightip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartFightNTF::clear_fightip() {
  if (fightip_ != &::google::protobuf::internal::kEmptyString) {
    fightip_->clear();
  }
  clear_has_fightip();
}
inline const ::std::string& StartFightNTF::fightip() const {
  return *fightip_;
}
inline void StartFightNTF::set_fightip(const ::std::string& value) {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  fightip_->assign(value);
}
inline void StartFightNTF::set_fightip(const char* value) {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  fightip_->assign(value);
}
inline void StartFightNTF::set_fightip(const char* value, size_t size) {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  fightip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartFightNTF::mutable_fightip() {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  return fightip_;
}
inline ::std::string* StartFightNTF::release_fightip() {
  clear_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fightip_;
    fightip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartFightNTF::set_allocated_fightip(::std::string* fightip) {
  if (fightip_ != &::google::protobuf::internal::kEmptyString) {
    delete fightip_;
  }
  if (fightip) {
    set_has_fightip();
    fightip_ = fightip;
  } else {
    clear_has_fightip();
    fightip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fightPort = 4;
inline bool StartFightNTF::has_fightport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartFightNTF::set_has_fightport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartFightNTF::clear_has_fightport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartFightNTF::clear_fightport() {
  fightport_ = 0;
  clear_has_fightport();
}
inline ::google::protobuf::int32 StartFightNTF::fightport() const {
  return fightport_;
}
inline void StartFightNTF::set_fightport(::google::protobuf::int32 value) {
  set_has_fightport();
  fightport_ = value;
}

// -------------------------------------------------------------------

// JoinFightReq

// required int32 fightUUID = 1;
inline bool JoinFightReq::has_fightuuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinFightReq::set_has_fightuuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinFightReq::clear_has_fightuuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinFightReq::clear_fightuuid() {
  fightuuid_ = 0;
  clear_has_fightuuid();
}
inline ::google::protobuf::int32 JoinFightReq::fightuuid() const {
  return fightuuid_;
}
inline void JoinFightReq::set_fightuuid(::google::protobuf::int32 value) {
  set_has_fightuuid();
  fightuuid_ = value;
}

// required int64 playerID = 2;
inline bool JoinFightReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinFightReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinFightReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinFightReq::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 JoinFightReq::playerid() const {
  return playerid_;
}
inline void JoinFightReq::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// required int32 frame = 3;
inline bool JoinFightReq::has_frame() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinFightReq::set_has_frame() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinFightReq::clear_has_frame() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinFightReq::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 JoinFightReq::frame() const {
  return frame_;
}
inline void JoinFightReq::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
}

// -------------------------------------------------------------------

// JoinFightAck

// required int32 code = 1;
inline bool JoinFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 JoinFightAck::code() const {
  return code_;
}
inline void JoinFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional int32 mapId = 2;
inline bool JoinFightAck::has_mapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinFightAck::set_has_mapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinFightAck::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinFightAck::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 JoinFightAck::mapid() const {
  return mapid_;
}
inline void JoinFightAck::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional uint32 randomSeed = 3;
inline bool JoinFightAck::has_randomseed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinFightAck::set_has_randomseed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinFightAck::clear_has_randomseed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinFightAck::clear_randomseed() {
  randomseed_ = 0u;
  clear_has_randomseed();
}
inline ::google::protobuf::uint32 JoinFightAck::randomseed() const {
  return randomseed_;
}
inline void JoinFightAck::set_randomseed(::google::protobuf::uint32 value) {
  set_has_randomseed();
  randomseed_ = value;
}

// optional uint32 uuidSeed = 4;
inline bool JoinFightAck::has_uuidseed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JoinFightAck::set_has_uuidseed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JoinFightAck::clear_has_uuidseed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JoinFightAck::clear_uuidseed() {
  uuidseed_ = 0u;
  clear_has_uuidseed();
}
inline ::google::protobuf::uint32 JoinFightAck::uuidseed() const {
  return uuidseed_;
}
inline void JoinFightAck::set_uuidseed(::google::protobuf::uint32 value) {
  set_has_uuidseed();
  uuidseed_ = value;
}

// -------------------------------------------------------------------

// PlayerReadyNotify

// required int64 pid = 1;
inline bool PlayerReadyNotify::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerReadyNotify::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerReadyNotify::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerReadyNotify::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 PlayerReadyNotify::pid() const {
  return pid_;
}
inline void PlayerReadyNotify::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// -------------------------------------------------------------------

// PlayerExitFightNotify

// required int64 pid = 1;
inline bool PlayerExitFightNotify::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerExitFightNotify::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerExitFightNotify::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerExitFightNotify::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 PlayerExitFightNotify::pid() const {
  return pid_;
}
inline void PlayerExitFightNotify::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// -------------------------------------------------------------------

// RunNextFrameReq

// required uint32 frame = 1;
inline bool RunNextFrameReq::has_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunNextFrameReq::set_has_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunNextFrameReq::clear_has_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunNextFrameReq::clear_frame() {
  frame_ = 0u;
  clear_has_frame();
}
inline ::google::protobuf::uint32 RunNextFrameReq::frame() const {
  return frame_;
}
inline void RunNextFrameReq::set_frame(::google::protobuf::uint32 value) {
  set_has_frame();
  frame_ = value;
}

// repeated string input = 2;
inline int RunNextFrameReq::input_size() const {
  return input_.size();
}
inline void RunNextFrameReq::clear_input() {
  input_.Clear();
}
inline const ::std::string& RunNextFrameReq::input(int index) const {
  return input_.Get(index);
}
inline ::std::string* RunNextFrameReq::mutable_input(int index) {
  return input_.Mutable(index);
}
inline void RunNextFrameReq::set_input(int index, const ::std::string& value) {
  input_.Mutable(index)->assign(value);
}
inline void RunNextFrameReq::set_input(int index, const char* value) {
  input_.Mutable(index)->assign(value);
}
inline void RunNextFrameReq::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunNextFrameReq::add_input() {
  return input_.Add();
}
inline void RunNextFrameReq::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
}
inline void RunNextFrameReq::add_input(const char* value) {
  input_.Add()->assign(value);
}
inline void RunNextFrameReq::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunNextFrameReq::input() const {
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunNextFrameReq::mutable_input() {
  return &input_;
}

// -------------------------------------------------------------------

// RunNextFrameAck

// required uint32 frame = 1;
inline bool RunNextFrameAck::has_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunNextFrameAck::set_has_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunNextFrameAck::clear_has_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunNextFrameAck::clear_frame() {
  frame_ = 0u;
  clear_has_frame();
}
inline ::google::protobuf::uint32 RunNextFrameAck::frame() const {
  return frame_;
}
inline void RunNextFrameAck::set_frame(::google::protobuf::uint32 value) {
  set_has_frame();
  frame_ = value;
}

// repeated string inputs = 2;
inline int RunNextFrameAck::inputs_size() const {
  return inputs_.size();
}
inline void RunNextFrameAck::clear_inputs() {
  inputs_.Clear();
}
inline const ::std::string& RunNextFrameAck::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::std::string* RunNextFrameAck::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline void RunNextFrameAck::set_inputs(int index, const ::std::string& value) {
  inputs_.Mutable(index)->assign(value);
}
inline void RunNextFrameAck::set_inputs(int index, const char* value) {
  inputs_.Mutable(index)->assign(value);
}
inline void RunNextFrameAck::set_inputs(int index, const char* value, size_t size) {
  inputs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RunNextFrameAck::add_inputs() {
  return inputs_.Add();
}
inline void RunNextFrameAck::add_inputs(const ::std::string& value) {
  inputs_.Add()->assign(value);
}
inline void RunNextFrameAck::add_inputs(const char* value) {
  inputs_.Add()->assign(value);
}
inline void RunNextFrameAck::add_inputs(const char* value, size_t size) {
  inputs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RunNextFrameAck::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RunNextFrameAck::mutable_inputs() {
  return &inputs_;
}

// -------------------------------------------------------------------

// ExitFightReq

// required int32 fightUUID = 1;
inline bool ExitFightReq::has_fightuuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitFightReq::set_has_fightuuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitFightReq::clear_has_fightuuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitFightReq::clear_fightuuid() {
  fightuuid_ = 0;
  clear_has_fightuuid();
}
inline ::google::protobuf::int32 ExitFightReq::fightuuid() const {
  return fightuuid_;
}
inline void ExitFightReq::set_fightuuid(::google::protobuf::int32 value) {
  set_has_fightuuid();
  fightuuid_ = value;
}

// -------------------------------------------------------------------

// ExitFightAck

// required int32 code = 1;
inline bool ExitFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ExitFightAck::code() const {
  return code_;
}
inline void ExitFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Msg_5fGame_2eproto__INCLUDED
