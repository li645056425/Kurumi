// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Msg_Game.proto

#ifndef PROTOBUF_Msg_5fGame_2eproto__INCLUDED
#define PROTOBUF_Msg_5fGame_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Msg_5fGame_2eproto();
void protobuf_AssignDesc_Msg_5fGame_2eproto();
void protobuf_ShutdownFile_Msg_5fGame_2eproto();

class Null;
class CodeAck;
class LoginGateAck;
class LoginReq;
class PlayerAccountInfo;
class RoleInfo;
class LoginAck;
class EnterGameReq;
class EnterGameAck;
class CreateRoleReq;
class CreateRoleAck;
class ExitGameNtf;
class PVEFightInfo;
class StartPVEFightReq;
class StartPVEFightAck;
class StartPVPFightReq;
class StartPVPFightAck;
class StartFightNTF;
class JoinFightReq;
class FightWorldInfo;
class JoinFightAck;
class PlayerLoadingReq;
class PlayerLoadingAck;
class PlayerReadyNotify;
class PlayerExitFightNotify;
class FrameInputData;
class PlayerFrameInput;
class RunNextFrameReq;
class RunNextFrameAck;
class PushFrameInput;
class PlayerRecords;
class ExitFightReq;
class ExitFightAck;
class Ping;
class Pong;
class PingInfo;
class PushPingInfo;

// ===================================================================

class Null : public ::google::protobuf::MessageLite {
 public:
  Null();
  virtual ~Null();

  Null(const Null& from);

  inline Null& operator=(const Null& from) {
    CopyFrom(from);
    return *this;
  }

  static const Null& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Null* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Null* other);

  // implements Message ----------------------------------------------

  Null* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Null& from);
  void MergeFrom(const Null& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:msg.Null)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static Null* default_instance_;
};
// -------------------------------------------------------------------

class CodeAck : public ::google::protobuf::MessageLite {
 public:
  CodeAck();
  virtual ~CodeAck();

  CodeAck(const CodeAck& from);

  inline CodeAck& operator=(const CodeAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CodeAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CodeAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CodeAck* other);

  // implements Message ----------------------------------------------

  CodeAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CodeAck& from);
  void MergeFrom(const CodeAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.CodeAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static CodeAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginGateAck : public ::google::protobuf::MessageLite {
 public:
  LoginGateAck();
  virtual ~LoginGateAck();

  LoginGateAck(const LoginGateAck& from);

  inline LoginGateAck& operator=(const LoginGateAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginGateAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginGateAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginGateAck* other);

  // implements Message ----------------------------------------------

  LoginGateAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginGateAck& from);
  void MergeFrom(const LoginGateAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.LoginGateAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static LoginGateAck* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::MessageLite {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required int64 playerID = 3;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 3;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.LoginReq)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::std::string* token_;
  ::std::string* account_;
  ::google::protobuf::int64 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAccountInfo : public ::google::protobuf::MessageLite {
 public:
  PlayerAccountInfo();
  virtual ~PlayerAccountInfo();

  PlayerAccountInfo(const PlayerAccountInfo& from);

  inline PlayerAccountInfo& operator=(const PlayerAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerAccountInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerAccountInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerAccountInfo* other);

  // implements Message ----------------------------------------------

  PlayerAccountInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerAccountInfo& from);
  void MergeFrom(const PlayerAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated int64 arrRoleIds = 3;
  inline int arrroleids_size() const;
  inline void clear_arrroleids();
  static const int kArrRoleIdsFieldNumber = 3;
  inline ::google::protobuf::int64 arrroleids(int index) const;
  inline void set_arrroleids(int index, ::google::protobuf::int64 value);
  inline void add_arrroleids(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      arrroleids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_arrroleids();

  // @@protoc_insertion_point(class_scope:msg.PlayerAccountInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::int64 playerid_;
  ::std::string* name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > arrroleids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoleInfo : public ::google::protobuf::MessageLite {
 public:
  RoleInfo();
  virtual ~RoleInfo();

  RoleInfo(const RoleInfo& from);

  inline RoleInfo& operator=(const RoleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoleInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoleInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoleInfo* other);

  // implements Message ----------------------------------------------

  RoleInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoleInfo& from);
  void MergeFrom(const RoleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 lv = 3;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 3;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // required int32 occupation = 4;
  inline bool has_occupation() const;
  inline void clear_occupation();
  static const int kOccupationFieldNumber = 4;
  inline ::google::protobuf::int32 occupation() const;
  inline void set_occupation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.RoleInfo)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_occupation();
  inline void clear_has_occupation();

  ::google::protobuf::int64 roleid_;
  ::std::string* name_;
  ::google::protobuf::int32 lv_;
  ::google::protobuf::int32 occupation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static RoleInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginAck : public ::google::protobuf::MessageLite {
 public:
  LoginAck();
  virtual ~LoginAck();

  LoginAck(const LoginAck& from);

  inline LoginAck& operator=(const LoginAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginAck* other);

  // implements Message ----------------------------------------------

  LoginAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginAck& from);
  void MergeFrom(const LoginAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // repeated .msg.PlayerAccountInfo infos = 2;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 2;
  inline const ::msg::PlayerAccountInfo& infos(int index) const;
  inline ::msg::PlayerAccountInfo* mutable_infos(int index);
  inline ::msg::PlayerAccountInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:msg.LoginAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo > infos_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static LoginAck* default_instance_;
};
// -------------------------------------------------------------------

class EnterGameReq : public ::google::protobuf::MessageLite {
 public:
  EnterGameReq();
  virtual ~EnterGameReq();

  EnterGameReq(const EnterGameReq& from);

  inline EnterGameReq& operator=(const EnterGameReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGameReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGameReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGameReq* other);

  // implements Message ----------------------------------------------

  EnterGameReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGameReq& from);
  void MergeFrom(const EnterGameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required int64 playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // required int64 roleID = 3;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIDFieldNumber = 3;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.EnterGameReq)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::std::string* token_;
  ::google::protobuf::int64 playerid_;
  ::google::protobuf::int64 roleid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static EnterGameReq* default_instance_;
};
// -------------------------------------------------------------------

class EnterGameAck : public ::google::protobuf::MessageLite {
 public:
  EnterGameAck();
  virtual ~EnterGameAck();

  EnterGameAck(const EnterGameAck& from);

  inline EnterGameAck& operator=(const EnterGameAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const EnterGameAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnterGameAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnterGameAck* other);

  // implements Message ----------------------------------------------

  EnterGameAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnterGameAck& from);
  void MergeFrom(const EnterGameAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional .msg.RoleInfo roleinfo = 2;
  inline bool has_roleinfo() const;
  inline void clear_roleinfo();
  static const int kRoleinfoFieldNumber = 2;
  inline const ::msg::RoleInfo& roleinfo() const;
  inline ::msg::RoleInfo* mutable_roleinfo();
  inline ::msg::RoleInfo* release_roleinfo();
  inline void set_allocated_roleinfo(::msg::RoleInfo* roleinfo);

  // @@protoc_insertion_point(class_scope:msg.EnterGameAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roleinfo();
  inline void clear_has_roleinfo();

  ::msg::RoleInfo* roleinfo_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static EnterGameAck* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoleReq : public ::google::protobuf::MessageLite {
 public:
  CreateRoleReq();
  virtual ~CreateRoleReq();

  CreateRoleReq(const CreateRoleReq& from);

  inline CreateRoleReq& operator=(const CreateRoleReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateRoleReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateRoleReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateRoleReq* other);

  // implements Message ----------------------------------------------

  CreateRoleReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateRoleReq& from);
  void MergeFrom(const CreateRoleReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 occupation = 1;
  inline bool has_occupation() const;
  inline void clear_occupation();
  static const int kOccupationFieldNumber = 1;
  inline ::google::protobuf::int32 occupation() const;
  inline void set_occupation(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:msg.CreateRoleReq)
 private:
  inline void set_has_occupation();
  inline void clear_has_occupation();
  inline void set_has_name();
  inline void clear_has_name();

  ::std::string* name_;
  ::google::protobuf::int32 occupation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static CreateRoleReq* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoleAck : public ::google::protobuf::MessageLite {
 public:
  CreateRoleAck();
  virtual ~CreateRoleAck();

  CreateRoleAck(const CreateRoleAck& from);

  inline CreateRoleAck& operator=(const CreateRoleAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const CreateRoleAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CreateRoleAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CreateRoleAck* other);

  // implements Message ----------------------------------------------

  CreateRoleAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CreateRoleAck& from);
  void MergeFrom(const CreateRoleAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required int64 roleID = 2;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIDFieldNumber = 2;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.CreateRoleAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::google::protobuf::int64 roleid_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static CreateRoleAck* default_instance_;
};
// -------------------------------------------------------------------

class ExitGameNtf : public ::google::protobuf::MessageLite {
 public:
  ExitGameNtf();
  virtual ~ExitGameNtf();

  ExitGameNtf(const ExitGameNtf& from);

  inline ExitGameNtf& operator=(const ExitGameNtf& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExitGameNtf& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExitGameNtf* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExitGameNtf* other);

  // implements Message ----------------------------------------------

  ExitGameNtf* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExitGameNtf& from);
  void MergeFrom(const ExitGameNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.ExitGameNtf)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static ExitGameNtf* default_instance_;
};
// -------------------------------------------------------------------

class PVEFightInfo : public ::google::protobuf::MessageLite {
 public:
  PVEFightInfo();
  virtual ~PVEFightInfo();

  PVEFightInfo(const PVEFightInfo& from);

  inline PVEFightInfo& operator=(const PVEFightInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PVEFightInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PVEFightInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PVEFightInfo* other);

  // implements Message ----------------------------------------------

  PVEFightInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PVEFightInfo& from);
  void MergeFrom(const PVEFightInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 roleId = 1;
  inline bool has_roleid() const;
  inline void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  inline ::google::protobuf::int64 roleid() const;
  inline void set_roleid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.PVEFightInfo)
 private:
  inline void set_has_roleid();
  inline void clear_has_roleid();

  ::google::protobuf::int64 roleid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PVEFightInfo* default_instance_;
};
// -------------------------------------------------------------------

class StartPVEFightReq : public ::google::protobuf::MessageLite {
 public:
  StartPVEFightReq();
  virtual ~StartPVEFightReq();

  StartPVEFightReq(const StartPVEFightReq& from);

  inline StartPVEFightReq& operator=(const StartPVEFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVEFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVEFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVEFightReq* other);

  // implements Message ----------------------------------------------

  StartPVEFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVEFightReq& from);
  void MergeFrom(const StartPVEFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 carbonId = 1;
  inline bool has_carbonid() const;
  inline void clear_carbonid();
  static const int kCarbonIdFieldNumber = 1;
  inline ::google::protobuf::int32 carbonid() const;
  inline void set_carbonid(::google::protobuf::int32 value);

  // repeated .msg.PVEFightInfo roles = 2;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 2;
  inline const ::msg::PVEFightInfo& roles(int index) const;
  inline ::msg::PVEFightInfo* mutable_roles(int index);
  inline ::msg::PVEFightInfo* add_roles();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PVEFightInfo >&
      roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PVEFightInfo >*
      mutable_roles();

  // @@protoc_insertion_point(class_scope:msg.StartPVEFightReq)
 private:
  inline void set_has_carbonid();
  inline void clear_has_carbonid();

  ::google::protobuf::RepeatedPtrField< ::msg::PVEFightInfo > roles_;
  ::google::protobuf::int32 carbonid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVEFightReq* default_instance_;
};
// -------------------------------------------------------------------

class StartPVEFightAck : public ::google::protobuf::MessageLite {
 public:
  StartPVEFightAck();
  virtual ~StartPVEFightAck();

  StartPVEFightAck(const StartPVEFightAck& from);

  inline StartPVEFightAck& operator=(const StartPVEFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVEFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVEFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVEFightAck* other);

  // implements Message ----------------------------------------------

  StartPVEFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVEFightAck& from);
  void MergeFrom(const StartPVEFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.StartPVEFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVEFightAck* default_instance_;
};
// -------------------------------------------------------------------

class StartPVPFightReq : public ::google::protobuf::MessageLite {
 public:
  StartPVPFightReq();
  virtual ~StartPVPFightReq();

  StartPVPFightReq(const StartPVPFightReq& from);

  inline StartPVPFightReq& operator=(const StartPVPFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVPFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVPFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVPFightReq* other);

  // implements Message ----------------------------------------------

  StartPVPFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVPFightReq& from);
  void MergeFrom(const StartPVPFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 foeId = 1;
  inline bool has_foeid() const;
  inline void clear_foeid();
  static const int kFoeIdFieldNumber = 1;
  inline ::google::protobuf::int64 foeid() const;
  inline void set_foeid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.StartPVPFightReq)
 private:
  inline void set_has_foeid();
  inline void clear_has_foeid();

  ::google::protobuf::int64 foeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVPFightReq* default_instance_;
};
// -------------------------------------------------------------------

class StartPVPFightAck : public ::google::protobuf::MessageLite {
 public:
  StartPVPFightAck();
  virtual ~StartPVPFightAck();

  StartPVPFightAck(const StartPVPFightAck& from);

  inline StartPVPFightAck& operator=(const StartPVPFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartPVPFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartPVPFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartPVPFightAck* other);

  // implements Message ----------------------------------------------

  StartPVPFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartPVPFightAck& from);
  void MergeFrom(const StartPVPFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.StartPVPFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartPVPFightAck* default_instance_;
};
// -------------------------------------------------------------------

class StartFightNTF : public ::google::protobuf::MessageLite {
 public:
  StartFightNTF();
  virtual ~StartFightNTF();

  StartFightNTF(const StartFightNTF& from);

  inline StartFightNTF& operator=(const StartFightNTF& from) {
    CopyFrom(from);
    return *this;
  }

  static const StartFightNTF& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartFightNTF* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartFightNTF* other);

  // implements Message ----------------------------------------------

  StartFightNTF* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartFightNTF& from);
  void MergeFrom(const StartFightNTF& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional int32 fightUUID = 2;
  inline bool has_fightuuid() const;
  inline void clear_fightuuid();
  static const int kFightUUIDFieldNumber = 2;
  inline ::google::protobuf::int32 fightuuid() const;
  inline void set_fightuuid(::google::protobuf::int32 value);

  // optional string fightIP = 3;
  inline bool has_fightip() const;
  inline void clear_fightip();
  static const int kFightIPFieldNumber = 3;
  inline const ::std::string& fightip() const;
  inline void set_fightip(const ::std::string& value);
  inline void set_fightip(const char* value);
  inline void set_fightip(const char* value, size_t size);
  inline ::std::string* mutable_fightip();
  inline ::std::string* release_fightip();
  inline void set_allocated_fightip(::std::string* fightip);

  // optional int32 fightPort = 4;
  inline bool has_fightport() const;
  inline void clear_fightport();
  static const int kFightPortFieldNumber = 4;
  inline ::google::protobuf::int32 fightport() const;
  inline void set_fightport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.StartFightNTF)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_fightuuid();
  inline void clear_has_fightuuid();
  inline void set_has_fightip();
  inline void clear_has_fightip();
  inline void set_has_fightport();
  inline void clear_has_fightport();

  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 fightuuid_;
  ::std::string* fightip_;
  ::google::protobuf::int32 fightport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static StartFightNTF* default_instance_;
};
// -------------------------------------------------------------------

class JoinFightReq : public ::google::protobuf::MessageLite {
 public:
  JoinFightReq();
  virtual ~JoinFightReq();

  JoinFightReq(const JoinFightReq& from);

  inline JoinFightReq& operator=(const JoinFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const JoinFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinFightReq* other);

  // implements Message ----------------------------------------------

  JoinFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinFightReq& from);
  void MergeFrom(const JoinFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 fightUUID = 1;
  inline bool has_fightuuid() const;
  inline void clear_fightuuid();
  static const int kFightUUIDFieldNumber = 1;
  inline ::google::protobuf::int32 fightuuid() const;
  inline void set_fightuuid(::google::protobuf::int32 value);

  // required int64 playerID = 2;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 2;
  inline ::google::protobuf::int64 playerid() const;
  inline void set_playerid(::google::protobuf::int64 value);

  // required int32 frame = 3;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 3;
  inline ::google::protobuf::int32 frame() const;
  inline void set_frame(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.JoinFightReq)
 private:
  inline void set_has_fightuuid();
  inline void clear_has_fightuuid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_frame();
  inline void clear_has_frame();

  ::google::protobuf::int64 playerid_;
  ::google::protobuf::int32 fightuuid_;
  ::google::protobuf::int32 frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static JoinFightReq* default_instance_;
};
// -------------------------------------------------------------------

class FightWorldInfo : public ::google::protobuf::MessageLite {
 public:
  FightWorldInfo();
  virtual ~FightWorldInfo();

  FightWorldInfo(const FightWorldInfo& from);

  inline FightWorldInfo& operator=(const FightWorldInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const FightWorldInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FightWorldInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FightWorldInfo* other);

  // implements Message ----------------------------------------------

  FightWorldInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FightWorldInfo& from);
  void MergeFrom(const FightWorldInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 frame = 1;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 1;
  inline ::google::protobuf::int32 frame() const;
  inline void set_frame(::google::protobuf::int32 value);

  // required int32 svr_status = 2;
  inline bool has_svr_status() const;
  inline void clear_svr_status();
  static const int kSvrStatusFieldNumber = 2;
  inline ::google::protobuf::int32 svr_status() const;
  inline void set_svr_status(::google::protobuf::int32 value);

  // required int32 mapId = 3;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 3;
  inline ::google::protobuf::int32 mapid() const;
  inline void set_mapid(::google::protobuf::int32 value);

  // required uint32 randomSeed = 4;
  inline bool has_randomseed() const;
  inline void clear_randomseed();
  static const int kRandomSeedFieldNumber = 4;
  inline ::google::protobuf::uint32 randomseed() const;
  inline void set_randomseed(::google::protobuf::uint32 value);

  // required uint32 uuidSeed = 5;
  inline bool has_uuidseed() const;
  inline void clear_uuidseed();
  static const int kUuidSeedFieldNumber = 5;
  inline ::google::protobuf::uint32 uuidseed() const;
  inline void set_uuidseed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:msg.FightWorldInfo)
 private:
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_svr_status();
  inline void clear_has_svr_status();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_randomseed();
  inline void clear_has_randomseed();
  inline void set_has_uuidseed();
  inline void clear_has_uuidseed();

  ::google::protobuf::int32 frame_;
  ::google::protobuf::int32 svr_status_;
  ::google::protobuf::int32 mapid_;
  ::google::protobuf::uint32 randomseed_;
  ::google::protobuf::uint32 uuidseed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static FightWorldInfo* default_instance_;
};
// -------------------------------------------------------------------

class JoinFightAck : public ::google::protobuf::MessageLite {
 public:
  JoinFightAck();
  virtual ~JoinFightAck();

  JoinFightAck(const JoinFightAck& from);

  inline JoinFightAck& operator=(const JoinFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const JoinFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const JoinFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(JoinFightAck* other);

  // implements Message ----------------------------------------------

  JoinFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const JoinFightAck& from);
  void MergeFrom(const JoinFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional .msg.FightWorldInfo worldInfo = 2;
  inline bool has_worldinfo() const;
  inline void clear_worldinfo();
  static const int kWorldInfoFieldNumber = 2;
  inline const ::msg::FightWorldInfo& worldinfo() const;
  inline ::msg::FightWorldInfo* mutable_worldinfo();
  inline ::msg::FightWorldInfo* release_worldinfo();
  inline void set_allocated_worldinfo(::msg::FightWorldInfo* worldinfo);

  // @@protoc_insertion_point(class_scope:msg.JoinFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_worldinfo();
  inline void clear_has_worldinfo();

  ::msg::FightWorldInfo* worldinfo_;
  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static JoinFightAck* default_instance_;
};
// -------------------------------------------------------------------

class PlayerLoadingReq : public ::google::protobuf::MessageLite {
 public:
  PlayerLoadingReq();
  virtual ~PlayerLoadingReq();

  PlayerLoadingReq(const PlayerLoadingReq& from);

  inline PlayerLoadingReq& operator=(const PlayerLoadingReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerLoadingReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerLoadingReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerLoadingReq* other);

  // implements Message ----------------------------------------------

  PlayerLoadingReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerLoadingReq& from);
  void MergeFrom(const PlayerLoadingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float percent = 1;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 1;
  inline float percent() const;
  inline void set_percent(float value);

  // required bool finish = 2;
  inline bool has_finish() const;
  inline void clear_finish();
  static const int kFinishFieldNumber = 2;
  inline bool finish() const;
  inline void set_finish(bool value);

  // @@protoc_insertion_point(class_scope:msg.PlayerLoadingReq)
 private:
  inline void set_has_percent();
  inline void clear_has_percent();
  inline void set_has_finish();
  inline void clear_has_finish();

  float percent_;
  bool finish_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerLoadingReq* default_instance_;
};
// -------------------------------------------------------------------

class PlayerLoadingAck : public ::google::protobuf::MessageLite {
 public:
  PlayerLoadingAck();
  virtual ~PlayerLoadingAck();

  PlayerLoadingAck(const PlayerLoadingAck& from);

  inline PlayerLoadingAck& operator=(const PlayerLoadingAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerLoadingAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerLoadingAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerLoadingAck* other);

  // implements Message ----------------------------------------------

  PlayerLoadingAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerLoadingAck& from);
  void MergeFrom(const PlayerLoadingAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 pid = 1;
  inline int pid_size() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid(int index) const;
  inline void set_pid(int index, ::google::protobuf::int64 value);
  inline void add_pid(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      pid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_pid();

  // repeated float percent = 2;
  inline int percent_size() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 2;
  inline float percent(int index) const;
  inline void set_percent(int index, float value);
  inline void add_percent(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      percent() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_percent();

  // required bool finish = 3;
  inline bool has_finish() const;
  inline void clear_finish();
  static const int kFinishFieldNumber = 3;
  inline bool finish() const;
  inline void set_finish(bool value);

  // @@protoc_insertion_point(class_scope:msg.PlayerLoadingAck)
 private:
  inline void set_has_finish();
  inline void clear_has_finish();

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > pid_;
  ::google::protobuf::RepeatedField< float > percent_;
  bool finish_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerLoadingAck* default_instance_;
};
// -------------------------------------------------------------------

class PlayerReadyNotify : public ::google::protobuf::MessageLite {
 public:
  PlayerReadyNotify();
  virtual ~PlayerReadyNotify();

  PlayerReadyNotify(const PlayerReadyNotify& from);

  inline PlayerReadyNotify& operator=(const PlayerReadyNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerReadyNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerReadyNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerReadyNotify* other);

  // implements Message ----------------------------------------------

  PlayerReadyNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerReadyNotify& from);
  void MergeFrom(const PlayerReadyNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.PlayerReadyNotify)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::int64 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerReadyNotify* default_instance_;
};
// -------------------------------------------------------------------

class PlayerExitFightNotify : public ::google::protobuf::MessageLite {
 public:
  PlayerExitFightNotify();
  virtual ~PlayerExitFightNotify();

  PlayerExitFightNotify(const PlayerExitFightNotify& from);

  inline PlayerExitFightNotify& operator=(const PlayerExitFightNotify& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerExitFightNotify& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerExitFightNotify* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerExitFightNotify* other);

  // implements Message ----------------------------------------------

  PlayerExitFightNotify* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerExitFightNotify& from);
  void MergeFrom(const PlayerExitFightNotify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:msg.PlayerExitFightNotify)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();

  ::google::protobuf::int64 pid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerExitFightNotify* default_instance_;
};
// -------------------------------------------------------------------

class FrameInputData : public ::google::protobuf::MessageLite {
 public:
  FrameInputData();
  virtual ~FrameInputData();

  FrameInputData(const FrameInputData& from);

  inline FrameInputData& operator=(const FrameInputData& from) {
    CopyFrom(from);
    return *this;
  }

  static const FrameInputData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FrameInputData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FrameInputData* other);

  // implements Message ----------------------------------------------

  FrameInputData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FrameInputData& from);
  void MergeFrom(const FrameInputData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 key_down = 1;
  inline bool has_key_down() const;
  inline void clear_key_down();
  static const int kKeyDownFieldNumber = 1;
  inline ::google::protobuf::uint32 key_down() const;
  inline void set_key_down(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:msg.FrameInputData)
 private:
  inline void set_has_key_down();
  inline void clear_has_key_down();

  ::google::protobuf::uint32 key_down_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static FrameInputData* default_instance_;
};
// -------------------------------------------------------------------

class PlayerFrameInput : public ::google::protobuf::MessageLite {
 public:
  PlayerFrameInput();
  virtual ~PlayerFrameInput();

  PlayerFrameInput(const PlayerFrameInput& from);

  inline PlayerFrameInput& operator=(const PlayerFrameInput& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerFrameInput& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerFrameInput* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerFrameInput* other);

  // implements Message ----------------------------------------------

  PlayerFrameInput* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerFrameInput& from);
  void MergeFrom(const PlayerFrameInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // required uint32 frame = 2;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 2;
  inline ::google::protobuf::uint32 frame() const;
  inline void set_frame(::google::protobuf::uint32 value);

  // required .msg.FrameInputData input = 3;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 3;
  inline const ::msg::FrameInputData& input() const;
  inline ::msg::FrameInputData* mutable_input();
  inline ::msg::FrameInputData* release_input();
  inline void set_allocated_input(::msg::FrameInputData* input);

  // @@protoc_insertion_point(class_scope:msg.PlayerFrameInput)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_input();
  inline void clear_has_input();

  ::google::protobuf::int64 pid_;
  ::msg::FrameInputData* input_;
  ::google::protobuf::uint32 frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerFrameInput* default_instance_;
};
// -------------------------------------------------------------------

class RunNextFrameReq : public ::google::protobuf::MessageLite {
 public:
  RunNextFrameReq();
  virtual ~RunNextFrameReq();

  RunNextFrameReq(const RunNextFrameReq& from);

  inline RunNextFrameReq& operator=(const RunNextFrameReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RunNextFrameReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RunNextFrameReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RunNextFrameReq* other);

  // implements Message ----------------------------------------------

  RunNextFrameReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RunNextFrameReq& from);
  void MergeFrom(const RunNextFrameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 frame = 1;
  inline bool has_frame() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 1;
  inline ::google::protobuf::uint32 frame() const;
  inline void set_frame(::google::protobuf::uint32 value);

  // required .msg.FrameInputData input = 2;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::msg::FrameInputData& input() const;
  inline ::msg::FrameInputData* mutable_input();
  inline ::msg::FrameInputData* release_input();
  inline void set_allocated_input(::msg::FrameInputData* input);

  // @@protoc_insertion_point(class_scope:msg.RunNextFrameReq)
 private:
  inline void set_has_frame();
  inline void clear_has_frame();
  inline void set_has_input();
  inline void clear_has_input();

  ::msg::FrameInputData* input_;
  ::google::protobuf::uint32 frame_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static RunNextFrameReq* default_instance_;
};
// -------------------------------------------------------------------

class RunNextFrameAck : public ::google::protobuf::MessageLite {
 public:
  RunNextFrameAck();
  virtual ~RunNextFrameAck();

  RunNextFrameAck(const RunNextFrameAck& from);

  inline RunNextFrameAck& operator=(const RunNextFrameAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const RunNextFrameAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RunNextFrameAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RunNextFrameAck* other);

  // implements Message ----------------------------------------------

  RunNextFrameAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RunNextFrameAck& from);
  void MergeFrom(const RunNextFrameAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nextFrame = 1;
  inline bool has_nextframe() const;
  inline void clear_nextframe();
  static const int kNextFrameFieldNumber = 1;
  inline ::google::protobuf::uint32 nextframe() const;
  inline void set_nextframe(::google::protobuf::uint32 value);

  // repeated .msg.PlayerFrameInput frames = 2;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 2;
  inline const ::msg::PlayerFrameInput& frames(int index) const;
  inline ::msg::PlayerFrameInput* mutable_frames(int index);
  inline ::msg::PlayerFrameInput* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >*
      mutable_frames();

  // @@protoc_insertion_point(class_scope:msg.RunNextFrameAck)
 private:
  inline void set_has_nextframe();
  inline void clear_has_nextframe();

  ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput > frames_;
  ::google::protobuf::uint32 nextframe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static RunNextFrameAck* default_instance_;
};
// -------------------------------------------------------------------

class PushFrameInput : public ::google::protobuf::MessageLite {
 public:
  PushFrameInput();
  virtual ~PushFrameInput();

  PushFrameInput(const PushFrameInput& from);

  inline PushFrameInput& operator=(const PushFrameInput& from) {
    CopyFrom(from);
    return *this;
  }

  static const PushFrameInput& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushFrameInput* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushFrameInput* other);

  // implements Message ----------------------------------------------

  PushFrameInput* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushFrameInput& from);
  void MergeFrom(const PushFrameInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 lastFrame = 1;
  inline bool has_lastframe() const;
  inline void clear_lastframe();
  static const int kLastFrameFieldNumber = 1;
  inline ::google::protobuf::uint32 lastframe() const;
  inline void set_lastframe(::google::protobuf::uint32 value);

  // repeated .msg.PlayerFrameInput frames = 2;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 2;
  inline const ::msg::PlayerFrameInput& frames(int index) const;
  inline ::msg::PlayerFrameInput* mutable_frames(int index);
  inline ::msg::PlayerFrameInput* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >*
      mutable_frames();

  // @@protoc_insertion_point(class_scope:msg.PushFrameInput)
 private:
  inline void set_has_lastframe();
  inline void clear_has_lastframe();

  ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput > frames_;
  ::google::protobuf::uint32 lastframe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PushFrameInput* default_instance_;
};
// -------------------------------------------------------------------

class PlayerRecords : public ::google::protobuf::MessageLite {
 public:
  PlayerRecords();
  virtual ~PlayerRecords();

  PlayerRecords(const PlayerRecords& from);

  inline PlayerRecords& operator=(const PlayerRecords& from) {
    CopyFrom(from);
    return *this;
  }

  static const PlayerRecords& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PlayerRecords* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PlayerRecords* other);

  // implements Message ----------------------------------------------

  PlayerRecords* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PlayerRecords& from);
  void MergeFrom(const PlayerRecords& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .msg.PlayerFrameInput frames = 1;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 1;
  inline const ::msg::PlayerFrameInput& frames(int index) const;
  inline ::msg::PlayerFrameInput* mutable_frames(int index);
  inline ::msg::PlayerFrameInput* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >*
      mutable_frames();

  // @@protoc_insertion_point(class_scope:msg.PlayerRecords)
 private:

  ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput > frames_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PlayerRecords* default_instance_;
};
// -------------------------------------------------------------------

class ExitFightReq : public ::google::protobuf::MessageLite {
 public:
  ExitFightReq();
  virtual ~ExitFightReq();

  ExitFightReq(const ExitFightReq& from);

  inline ExitFightReq& operator=(const ExitFightReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExitFightReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExitFightReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExitFightReq* other);

  // implements Message ----------------------------------------------

  ExitFightReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExitFightReq& from);
  void MergeFrom(const ExitFightReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 fightUUID = 1;
  inline bool has_fightuuid() const;
  inline void clear_fightuuid();
  static const int kFightUUIDFieldNumber = 1;
  inline ::google::protobuf::int32 fightuuid() const;
  inline void set_fightuuid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.ExitFightReq)
 private:
  inline void set_has_fightuuid();
  inline void clear_has_fightuuid();

  ::google::protobuf::int32 fightuuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static ExitFightReq* default_instance_;
};
// -------------------------------------------------------------------

class ExitFightAck : public ::google::protobuf::MessageLite {
 public:
  ExitFightAck();
  virtual ~ExitFightAck();

  ExitFightAck(const ExitFightAck& from);

  inline ExitFightAck& operator=(const ExitFightAck& from) {
    CopyFrom(from);
    return *this;
  }

  static const ExitFightAck& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExitFightAck* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExitFightAck* other);

  // implements Message ----------------------------------------------

  ExitFightAck* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExitFightAck& from);
  void MergeFrom(const ExitFightAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.ExitFightAck)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::int32 code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static ExitFightAck* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::MessageLite {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  static const Ping& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Ping* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:msg.Ping)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::MessageLite {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }

  static const Pong& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Pong* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Pong* other);

  // implements Message ----------------------------------------------

  Pong* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:msg.Pong)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::uint32 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static Pong* default_instance_;
};
// -------------------------------------------------------------------

class PingInfo : public ::google::protobuf::MessageLite {
 public:
  PingInfo();
  virtual ~PingInfo();

  PingInfo(const PingInfo& from);

  inline PingInfo& operator=(const PingInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PingInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PingInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PingInfo* other);

  // implements Message ----------------------------------------------

  PingInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PingInfo& from);
  void MergeFrom(const PingInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 pid = 1;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 1;
  inline ::google::protobuf::int64 pid() const;
  inline void set_pid(::google::protobuf::int64 value);

  // required int32 ping = 2;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 2;
  inline ::google::protobuf::int32 ping() const;
  inline void set_ping(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:msg.PingInfo)
 private:
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_ping();
  inline void clear_has_ping();

  ::google::protobuf::int64 pid_;
  ::google::protobuf::int32 ping_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PingInfo* default_instance_;
};
// -------------------------------------------------------------------

class PushPingInfo : public ::google::protobuf::MessageLite {
 public:
  PushPingInfo();
  virtual ~PushPingInfo();

  PushPingInfo(const PushPingInfo& from);

  inline PushPingInfo& operator=(const PushPingInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const PushPingInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushPingInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushPingInfo* other);

  // implements Message ----------------------------------------------

  PushPingInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushPingInfo& from);
  void MergeFrom(const PushPingInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .msg.PingInfo infos = 1;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 1;
  inline const ::msg::PingInfo& infos(int index) const;
  inline ::msg::PingInfo* mutable_infos(int index);
  inline ::msg::PingInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::msg::PingInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::msg::PingInfo >*
      mutable_infos();

  // @@protoc_insertion_point(class_scope:msg.PushPingInfo)
 private:

  ::google::protobuf::RepeatedPtrField< ::msg::PingInfo > infos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_Msg_5fGame_2eproto();
  #endif
  friend void protobuf_AssignDesc_Msg_5fGame_2eproto();
  friend void protobuf_ShutdownFile_Msg_5fGame_2eproto();

  void InitAsDefaultInstance();
  static PushPingInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// Null

// -------------------------------------------------------------------

// CodeAck

// required int32 code = 1;
inline bool CodeAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodeAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CodeAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CodeAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CodeAck::code() const {
  return code_;
}
inline void CodeAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// LoginGateAck

// required int32 code = 1;
inline bool LoginGateAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGateAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGateAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGateAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LoginGateAck::code() const {
  return code_;
}
inline void LoginGateAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// LoginReq

// required string token = 1;
inline bool LoginReq::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LoginReq::token() const {
  return *token_;
}
inline void LoginReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LoginReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* LoginReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string account = 2;
inline bool LoginReq::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LoginReq::account() const {
  return *account_;
}
inline void LoginReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LoginReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 playerID = 3;
inline bool LoginReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 LoginReq::playerid() const {
  return playerid_;
}
inline void LoginReq::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// PlayerAccountInfo

// required int64 playerID = 1;
inline bool PlayerAccountInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAccountInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAccountInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAccountInfo::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 PlayerAccountInfo::playerid() const {
  return playerid_;
}
inline void PlayerAccountInfo::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// required string name = 2;
inline bool PlayerAccountInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAccountInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAccountInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAccountInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayerAccountInfo::name() const {
  return *name_;
}
inline void PlayerAccountInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerAccountInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayerAccountInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayerAccountInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayerAccountInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayerAccountInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated int64 arrRoleIds = 3;
inline int PlayerAccountInfo::arrroleids_size() const {
  return arrroleids_.size();
}
inline void PlayerAccountInfo::clear_arrroleids() {
  arrroleids_.Clear();
}
inline ::google::protobuf::int64 PlayerAccountInfo::arrroleids(int index) const {
  return arrroleids_.Get(index);
}
inline void PlayerAccountInfo::set_arrroleids(int index, ::google::protobuf::int64 value) {
  arrroleids_.Set(index, value);
}
inline void PlayerAccountInfo::add_arrroleids(::google::protobuf::int64 value) {
  arrroleids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PlayerAccountInfo::arrroleids() const {
  return arrroleids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PlayerAccountInfo::mutable_arrroleids() {
  return &arrroleids_;
}

// -------------------------------------------------------------------

// RoleInfo

// required int64 roleId = 1;
inline bool RoleInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleInfo::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 RoleInfo::roleid() const {
  return roleid_;
}
inline void RoleInfo::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// required string name = 2;
inline bool RoleInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoleInfo::name() const {
  return *name_;
}
inline void RoleInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoleInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoleInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 lv = 3;
inline bool RoleInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 RoleInfo::lv() const {
  return lv_;
}
inline void RoleInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// required int32 occupation = 4;
inline bool RoleInfo::has_occupation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleInfo::set_has_occupation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleInfo::clear_has_occupation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleInfo::clear_occupation() {
  occupation_ = 0;
  clear_has_occupation();
}
inline ::google::protobuf::int32 RoleInfo::occupation() const {
  return occupation_;
}
inline void RoleInfo::set_occupation(::google::protobuf::int32 value) {
  set_has_occupation();
  occupation_ = value;
}

// -------------------------------------------------------------------

// LoginAck

// required int32 code = 1;
inline bool LoginAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LoginAck::code() const {
  return code_;
}
inline void LoginAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// repeated .msg.PlayerAccountInfo infos = 2;
inline int LoginAck::infos_size() const {
  return infos_.size();
}
inline void LoginAck::clear_infos() {
  infos_.Clear();
}
inline const ::msg::PlayerAccountInfo& LoginAck::infos(int index) const {
  return infos_.Get(index);
}
inline ::msg::PlayerAccountInfo* LoginAck::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::msg::PlayerAccountInfo* LoginAck::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >&
LoginAck::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerAccountInfo >*
LoginAck::mutable_infos() {
  return &infos_;
}

// -------------------------------------------------------------------

// EnterGameReq

// required string token = 1;
inline bool EnterGameReq::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGameReq::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGameReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGameReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& EnterGameReq::token() const {
  return *token_;
}
inline void EnterGameReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void EnterGameReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void EnterGameReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterGameReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* EnterGameReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterGameReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 playerID = 2;
inline bool EnterGameReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterGameReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterGameReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterGameReq::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 EnterGameReq::playerid() const {
  return playerid_;
}
inline void EnterGameReq::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// required int64 roleID = 3;
inline bool EnterGameReq::has_roleid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterGameReq::set_has_roleid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterGameReq::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterGameReq::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 EnterGameReq::roleid() const {
  return roleid_;
}
inline void EnterGameReq::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// EnterGameAck

// required int32 code = 1;
inline bool EnterGameAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterGameAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterGameAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterGameAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 EnterGameAck::code() const {
  return code_;
}
inline void EnterGameAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional .msg.RoleInfo roleinfo = 2;
inline bool EnterGameAck::has_roleinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterGameAck::set_has_roleinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterGameAck::clear_has_roleinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterGameAck::clear_roleinfo() {
  if (roleinfo_ != NULL) roleinfo_->::msg::RoleInfo::Clear();
  clear_has_roleinfo();
}
inline const ::msg::RoleInfo& EnterGameAck::roleinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return roleinfo_ != NULL ? *roleinfo_ : *default_instance().roleinfo_;
#else
  return roleinfo_ != NULL ? *roleinfo_ : *default_instance_->roleinfo_;
#endif
}
inline ::msg::RoleInfo* EnterGameAck::mutable_roleinfo() {
  set_has_roleinfo();
  if (roleinfo_ == NULL) roleinfo_ = new ::msg::RoleInfo;
  return roleinfo_;
}
inline ::msg::RoleInfo* EnterGameAck::release_roleinfo() {
  clear_has_roleinfo();
  ::msg::RoleInfo* temp = roleinfo_;
  roleinfo_ = NULL;
  return temp;
}
inline void EnterGameAck::set_allocated_roleinfo(::msg::RoleInfo* roleinfo) {
  delete roleinfo_;
  roleinfo_ = roleinfo;
  if (roleinfo) {
    set_has_roleinfo();
  } else {
    clear_has_roleinfo();
  }
}

// -------------------------------------------------------------------

// CreateRoleReq

// required int32 occupation = 1;
inline bool CreateRoleReq::has_occupation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleReq::set_has_occupation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleReq::clear_has_occupation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleReq::clear_occupation() {
  occupation_ = 0;
  clear_has_occupation();
}
inline ::google::protobuf::int32 CreateRoleReq::occupation() const {
  return occupation_;
}
inline void CreateRoleReq::set_occupation(::google::protobuf::int32 value) {
  set_has_occupation();
  occupation_ = value;
}

// required string name = 2;
inline bool CreateRoleReq::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoleReq::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoleReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoleReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CreateRoleReq::name() const {
  return *name_;
}
inline void CreateRoleReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoleReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CreateRoleReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoleReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CreateRoleReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoleReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateRoleAck

// required int32 code = 1;
inline bool CreateRoleAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 CreateRoleAck::code() const {
  return code_;
}
inline void CreateRoleAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required int64 roleID = 2;
inline bool CreateRoleAck::has_roleid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoleAck::set_has_roleid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoleAck::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoleAck::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 CreateRoleAck::roleid() const {
  return roleid_;
}
inline void CreateRoleAck::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// ExitGameNtf

// required int32 code = 1;
inline bool ExitGameNtf::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitGameNtf::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitGameNtf::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitGameNtf::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ExitGameNtf::code() const {
  return code_;
}
inline void ExitGameNtf::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// PVEFightInfo

// required int64 roleId = 1;
inline bool PVEFightInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PVEFightInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PVEFightInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PVEFightInfo::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 PVEFightInfo::roleid() const {
  return roleid_;
}
inline void PVEFightInfo::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
}

// -------------------------------------------------------------------

// StartPVEFightReq

// required int32 carbonId = 1;
inline bool StartPVEFightReq::has_carbonid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVEFightReq::set_has_carbonid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVEFightReq::clear_has_carbonid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVEFightReq::clear_carbonid() {
  carbonid_ = 0;
  clear_has_carbonid();
}
inline ::google::protobuf::int32 StartPVEFightReq::carbonid() const {
  return carbonid_;
}
inline void StartPVEFightReq::set_carbonid(::google::protobuf::int32 value) {
  set_has_carbonid();
  carbonid_ = value;
}

// repeated .msg.PVEFightInfo roles = 2;
inline int StartPVEFightReq::roles_size() const {
  return roles_.size();
}
inline void StartPVEFightReq::clear_roles() {
  roles_.Clear();
}
inline const ::msg::PVEFightInfo& StartPVEFightReq::roles(int index) const {
  return roles_.Get(index);
}
inline ::msg::PVEFightInfo* StartPVEFightReq::mutable_roles(int index) {
  return roles_.Mutable(index);
}
inline ::msg::PVEFightInfo* StartPVEFightReq::add_roles() {
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PVEFightInfo >&
StartPVEFightReq::roles() const {
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PVEFightInfo >*
StartPVEFightReq::mutable_roles() {
  return &roles_;
}

// -------------------------------------------------------------------

// StartPVEFightAck

// required int32 code = 1;
inline bool StartPVEFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVEFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVEFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVEFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StartPVEFightAck::code() const {
  return code_;
}
inline void StartPVEFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// StartPVPFightReq

// required int64 foeId = 1;
inline bool StartPVPFightReq::has_foeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVPFightReq::set_has_foeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVPFightReq::clear_has_foeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVPFightReq::clear_foeid() {
  foeid_ = GOOGLE_LONGLONG(0);
  clear_has_foeid();
}
inline ::google::protobuf::int64 StartPVPFightReq::foeid() const {
  return foeid_;
}
inline void StartPVPFightReq::set_foeid(::google::protobuf::int64 value) {
  set_has_foeid();
  foeid_ = value;
}

// -------------------------------------------------------------------

// StartPVPFightAck

// required int32 code = 1;
inline bool StartPVPFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartPVPFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartPVPFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartPVPFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StartPVPFightAck::code() const {
  return code_;
}
inline void StartPVPFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// StartFightNTF

// required int32 code = 1;
inline bool StartFightNTF::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StartFightNTF::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StartFightNTF::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StartFightNTF::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 StartFightNTF::code() const {
  return code_;
}
inline void StartFightNTF::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional int32 fightUUID = 2;
inline bool StartFightNTF::has_fightuuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StartFightNTF::set_has_fightuuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StartFightNTF::clear_has_fightuuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StartFightNTF::clear_fightuuid() {
  fightuuid_ = 0;
  clear_has_fightuuid();
}
inline ::google::protobuf::int32 StartFightNTF::fightuuid() const {
  return fightuuid_;
}
inline void StartFightNTF::set_fightuuid(::google::protobuf::int32 value) {
  set_has_fightuuid();
  fightuuid_ = value;
}

// optional string fightIP = 3;
inline bool StartFightNTF::has_fightip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StartFightNTF::set_has_fightip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StartFightNTF::clear_has_fightip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StartFightNTF::clear_fightip() {
  if (fightip_ != &::google::protobuf::internal::kEmptyString) {
    fightip_->clear();
  }
  clear_has_fightip();
}
inline const ::std::string& StartFightNTF::fightip() const {
  return *fightip_;
}
inline void StartFightNTF::set_fightip(const ::std::string& value) {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  fightip_->assign(value);
}
inline void StartFightNTF::set_fightip(const char* value) {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  fightip_->assign(value);
}
inline void StartFightNTF::set_fightip(const char* value, size_t size) {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  fightip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StartFightNTF::mutable_fightip() {
  set_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    fightip_ = new ::std::string;
  }
  return fightip_;
}
inline ::std::string* StartFightNTF::release_fightip() {
  clear_has_fightip();
  if (fightip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fightip_;
    fightip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StartFightNTF::set_allocated_fightip(::std::string* fightip) {
  if (fightip_ != &::google::protobuf::internal::kEmptyString) {
    delete fightip_;
  }
  if (fightip) {
    set_has_fightip();
    fightip_ = fightip;
  } else {
    clear_has_fightip();
    fightip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fightPort = 4;
inline bool StartFightNTF::has_fightport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StartFightNTF::set_has_fightport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StartFightNTF::clear_has_fightport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StartFightNTF::clear_fightport() {
  fightport_ = 0;
  clear_has_fightport();
}
inline ::google::protobuf::int32 StartFightNTF::fightport() const {
  return fightport_;
}
inline void StartFightNTF::set_fightport(::google::protobuf::int32 value) {
  set_has_fightport();
  fightport_ = value;
}

// -------------------------------------------------------------------

// JoinFightReq

// required int32 fightUUID = 1;
inline bool JoinFightReq::has_fightuuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinFightReq::set_has_fightuuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinFightReq::clear_has_fightuuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinFightReq::clear_fightuuid() {
  fightuuid_ = 0;
  clear_has_fightuuid();
}
inline ::google::protobuf::int32 JoinFightReq::fightuuid() const {
  return fightuuid_;
}
inline void JoinFightReq::set_fightuuid(::google::protobuf::int32 value) {
  set_has_fightuuid();
  fightuuid_ = value;
}

// required int64 playerID = 2;
inline bool JoinFightReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinFightReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinFightReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinFightReq::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 JoinFightReq::playerid() const {
  return playerid_;
}
inline void JoinFightReq::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
}

// required int32 frame = 3;
inline bool JoinFightReq::has_frame() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JoinFightReq::set_has_frame() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JoinFightReq::clear_has_frame() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JoinFightReq::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 JoinFightReq::frame() const {
  return frame_;
}
inline void JoinFightReq::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
}

// -------------------------------------------------------------------

// FightWorldInfo

// required int32 frame = 1;
inline bool FightWorldInfo::has_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FightWorldInfo::set_has_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FightWorldInfo::clear_has_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FightWorldInfo::clear_frame() {
  frame_ = 0;
  clear_has_frame();
}
inline ::google::protobuf::int32 FightWorldInfo::frame() const {
  return frame_;
}
inline void FightWorldInfo::set_frame(::google::protobuf::int32 value) {
  set_has_frame();
  frame_ = value;
}

// required int32 svr_status = 2;
inline bool FightWorldInfo::has_svr_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FightWorldInfo::set_has_svr_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FightWorldInfo::clear_has_svr_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FightWorldInfo::clear_svr_status() {
  svr_status_ = 0;
  clear_has_svr_status();
}
inline ::google::protobuf::int32 FightWorldInfo::svr_status() const {
  return svr_status_;
}
inline void FightWorldInfo::set_svr_status(::google::protobuf::int32 value) {
  set_has_svr_status();
  svr_status_ = value;
}

// required int32 mapId = 3;
inline bool FightWorldInfo::has_mapid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FightWorldInfo::set_has_mapid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FightWorldInfo::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FightWorldInfo::clear_mapid() {
  mapid_ = 0;
  clear_has_mapid();
}
inline ::google::protobuf::int32 FightWorldInfo::mapid() const {
  return mapid_;
}
inline void FightWorldInfo::set_mapid(::google::protobuf::int32 value) {
  set_has_mapid();
  mapid_ = value;
}

// required uint32 randomSeed = 4;
inline bool FightWorldInfo::has_randomseed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FightWorldInfo::set_has_randomseed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FightWorldInfo::clear_has_randomseed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FightWorldInfo::clear_randomseed() {
  randomseed_ = 0u;
  clear_has_randomseed();
}
inline ::google::protobuf::uint32 FightWorldInfo::randomseed() const {
  return randomseed_;
}
inline void FightWorldInfo::set_randomseed(::google::protobuf::uint32 value) {
  set_has_randomseed();
  randomseed_ = value;
}

// required uint32 uuidSeed = 5;
inline bool FightWorldInfo::has_uuidseed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FightWorldInfo::set_has_uuidseed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FightWorldInfo::clear_has_uuidseed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FightWorldInfo::clear_uuidseed() {
  uuidseed_ = 0u;
  clear_has_uuidseed();
}
inline ::google::protobuf::uint32 FightWorldInfo::uuidseed() const {
  return uuidseed_;
}
inline void FightWorldInfo::set_uuidseed(::google::protobuf::uint32 value) {
  set_has_uuidseed();
  uuidseed_ = value;
}

// -------------------------------------------------------------------

// JoinFightAck

// required int32 code = 1;
inline bool JoinFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 JoinFightAck::code() const {
  return code_;
}
inline void JoinFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// optional .msg.FightWorldInfo worldInfo = 2;
inline bool JoinFightAck::has_worldinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JoinFightAck::set_has_worldinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JoinFightAck::clear_has_worldinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JoinFightAck::clear_worldinfo() {
  if (worldinfo_ != NULL) worldinfo_->::msg::FightWorldInfo::Clear();
  clear_has_worldinfo();
}
inline const ::msg::FightWorldInfo& JoinFightAck::worldinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return worldinfo_ != NULL ? *worldinfo_ : *default_instance().worldinfo_;
#else
  return worldinfo_ != NULL ? *worldinfo_ : *default_instance_->worldinfo_;
#endif
}
inline ::msg::FightWorldInfo* JoinFightAck::mutable_worldinfo() {
  set_has_worldinfo();
  if (worldinfo_ == NULL) worldinfo_ = new ::msg::FightWorldInfo;
  return worldinfo_;
}
inline ::msg::FightWorldInfo* JoinFightAck::release_worldinfo() {
  clear_has_worldinfo();
  ::msg::FightWorldInfo* temp = worldinfo_;
  worldinfo_ = NULL;
  return temp;
}
inline void JoinFightAck::set_allocated_worldinfo(::msg::FightWorldInfo* worldinfo) {
  delete worldinfo_;
  worldinfo_ = worldinfo;
  if (worldinfo) {
    set_has_worldinfo();
  } else {
    clear_has_worldinfo();
  }
}

// -------------------------------------------------------------------

// PlayerLoadingReq

// required float percent = 1;
inline bool PlayerLoadingReq::has_percent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerLoadingReq::set_has_percent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerLoadingReq::clear_has_percent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerLoadingReq::clear_percent() {
  percent_ = 0;
  clear_has_percent();
}
inline float PlayerLoadingReq::percent() const {
  return percent_;
}
inline void PlayerLoadingReq::set_percent(float value) {
  set_has_percent();
  percent_ = value;
}

// required bool finish = 2;
inline bool PlayerLoadingReq::has_finish() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerLoadingReq::set_has_finish() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerLoadingReq::clear_has_finish() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerLoadingReq::clear_finish() {
  finish_ = false;
  clear_has_finish();
}
inline bool PlayerLoadingReq::finish() const {
  return finish_;
}
inline void PlayerLoadingReq::set_finish(bool value) {
  set_has_finish();
  finish_ = value;
}

// -------------------------------------------------------------------

// PlayerLoadingAck

// repeated int64 pid = 1;
inline int PlayerLoadingAck::pid_size() const {
  return pid_.size();
}
inline void PlayerLoadingAck::clear_pid() {
  pid_.Clear();
}
inline ::google::protobuf::int64 PlayerLoadingAck::pid(int index) const {
  return pid_.Get(index);
}
inline void PlayerLoadingAck::set_pid(int index, ::google::protobuf::int64 value) {
  pid_.Set(index, value);
}
inline void PlayerLoadingAck::add_pid(::google::protobuf::int64 value) {
  pid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PlayerLoadingAck::pid() const {
  return pid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PlayerLoadingAck::mutable_pid() {
  return &pid_;
}

// repeated float percent = 2;
inline int PlayerLoadingAck::percent_size() const {
  return percent_.size();
}
inline void PlayerLoadingAck::clear_percent() {
  percent_.Clear();
}
inline float PlayerLoadingAck::percent(int index) const {
  return percent_.Get(index);
}
inline void PlayerLoadingAck::set_percent(int index, float value) {
  percent_.Set(index, value);
}
inline void PlayerLoadingAck::add_percent(float value) {
  percent_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
PlayerLoadingAck::percent() const {
  return percent_;
}
inline ::google::protobuf::RepeatedField< float >*
PlayerLoadingAck::mutable_percent() {
  return &percent_;
}

// required bool finish = 3;
inline bool PlayerLoadingAck::has_finish() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerLoadingAck::set_has_finish() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerLoadingAck::clear_has_finish() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerLoadingAck::clear_finish() {
  finish_ = false;
  clear_has_finish();
}
inline bool PlayerLoadingAck::finish() const {
  return finish_;
}
inline void PlayerLoadingAck::set_finish(bool value) {
  set_has_finish();
  finish_ = value;
}

// -------------------------------------------------------------------

// PlayerReadyNotify

// required int64 pid = 1;
inline bool PlayerReadyNotify::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerReadyNotify::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerReadyNotify::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerReadyNotify::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 PlayerReadyNotify::pid() const {
  return pid_;
}
inline void PlayerReadyNotify::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// -------------------------------------------------------------------

// PlayerExitFightNotify

// required int64 pid = 1;
inline bool PlayerExitFightNotify::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerExitFightNotify::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerExitFightNotify::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerExitFightNotify::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 PlayerExitFightNotify::pid() const {
  return pid_;
}
inline void PlayerExitFightNotify::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// -------------------------------------------------------------------

// FrameInputData

// required uint32 key_down = 1;
inline bool FrameInputData::has_key_down() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrameInputData::set_has_key_down() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrameInputData::clear_has_key_down() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrameInputData::clear_key_down() {
  key_down_ = 0u;
  clear_has_key_down();
}
inline ::google::protobuf::uint32 FrameInputData::key_down() const {
  return key_down_;
}
inline void FrameInputData::set_key_down(::google::protobuf::uint32 value) {
  set_has_key_down();
  key_down_ = value;
}

// -------------------------------------------------------------------

// PlayerFrameInput

// required int64 pid = 1;
inline bool PlayerFrameInput::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerFrameInput::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerFrameInput::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerFrameInput::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 PlayerFrameInput::pid() const {
  return pid_;
}
inline void PlayerFrameInput::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// required uint32 frame = 2;
inline bool PlayerFrameInput::has_frame() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerFrameInput::set_has_frame() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerFrameInput::clear_has_frame() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerFrameInput::clear_frame() {
  frame_ = 0u;
  clear_has_frame();
}
inline ::google::protobuf::uint32 PlayerFrameInput::frame() const {
  return frame_;
}
inline void PlayerFrameInput::set_frame(::google::protobuf::uint32 value) {
  set_has_frame();
  frame_ = value;
}

// required .msg.FrameInputData input = 3;
inline bool PlayerFrameInput::has_input() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerFrameInput::set_has_input() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerFrameInput::clear_has_input() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerFrameInput::clear_input() {
  if (input_ != NULL) input_->::msg::FrameInputData::Clear();
  clear_has_input();
}
inline const ::msg::FrameInputData& PlayerFrameInput::input() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return input_ != NULL ? *input_ : *default_instance().input_;
#else
  return input_ != NULL ? *input_ : *default_instance_->input_;
#endif
}
inline ::msg::FrameInputData* PlayerFrameInput::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::msg::FrameInputData;
  return input_;
}
inline ::msg::FrameInputData* PlayerFrameInput::release_input() {
  clear_has_input();
  ::msg::FrameInputData* temp = input_;
  input_ = NULL;
  return temp;
}
inline void PlayerFrameInput::set_allocated_input(::msg::FrameInputData* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
}

// -------------------------------------------------------------------

// RunNextFrameReq

// required uint32 frame = 1;
inline bool RunNextFrameReq::has_frame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunNextFrameReq::set_has_frame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunNextFrameReq::clear_has_frame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunNextFrameReq::clear_frame() {
  frame_ = 0u;
  clear_has_frame();
}
inline ::google::protobuf::uint32 RunNextFrameReq::frame() const {
  return frame_;
}
inline void RunNextFrameReq::set_frame(::google::protobuf::uint32 value) {
  set_has_frame();
  frame_ = value;
}

// required .msg.FrameInputData input = 2;
inline bool RunNextFrameReq::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunNextFrameReq::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunNextFrameReq::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunNextFrameReq::clear_input() {
  if (input_ != NULL) input_->::msg::FrameInputData::Clear();
  clear_has_input();
}
inline const ::msg::FrameInputData& RunNextFrameReq::input() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return input_ != NULL ? *input_ : *default_instance().input_;
#else
  return input_ != NULL ? *input_ : *default_instance_->input_;
#endif
}
inline ::msg::FrameInputData* RunNextFrameReq::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::msg::FrameInputData;
  return input_;
}
inline ::msg::FrameInputData* RunNextFrameReq::release_input() {
  clear_has_input();
  ::msg::FrameInputData* temp = input_;
  input_ = NULL;
  return temp;
}
inline void RunNextFrameReq::set_allocated_input(::msg::FrameInputData* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
}

// -------------------------------------------------------------------

// RunNextFrameAck

// required uint32 nextFrame = 1;
inline bool RunNextFrameAck::has_nextframe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunNextFrameAck::set_has_nextframe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunNextFrameAck::clear_has_nextframe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunNextFrameAck::clear_nextframe() {
  nextframe_ = 0u;
  clear_has_nextframe();
}
inline ::google::protobuf::uint32 RunNextFrameAck::nextframe() const {
  return nextframe_;
}
inline void RunNextFrameAck::set_nextframe(::google::protobuf::uint32 value) {
  set_has_nextframe();
  nextframe_ = value;
}

// repeated .msg.PlayerFrameInput frames = 2;
inline int RunNextFrameAck::frames_size() const {
  return frames_.size();
}
inline void RunNextFrameAck::clear_frames() {
  frames_.Clear();
}
inline const ::msg::PlayerFrameInput& RunNextFrameAck::frames(int index) const {
  return frames_.Get(index);
}
inline ::msg::PlayerFrameInput* RunNextFrameAck::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::msg::PlayerFrameInput* RunNextFrameAck::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >&
RunNextFrameAck::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >*
RunNextFrameAck::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// PushFrameInput

// required uint32 lastFrame = 1;
inline bool PushFrameInput::has_lastframe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushFrameInput::set_has_lastframe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushFrameInput::clear_has_lastframe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushFrameInput::clear_lastframe() {
  lastframe_ = 0u;
  clear_has_lastframe();
}
inline ::google::protobuf::uint32 PushFrameInput::lastframe() const {
  return lastframe_;
}
inline void PushFrameInput::set_lastframe(::google::protobuf::uint32 value) {
  set_has_lastframe();
  lastframe_ = value;
}

// repeated .msg.PlayerFrameInput frames = 2;
inline int PushFrameInput::frames_size() const {
  return frames_.size();
}
inline void PushFrameInput::clear_frames() {
  frames_.Clear();
}
inline const ::msg::PlayerFrameInput& PushFrameInput::frames(int index) const {
  return frames_.Get(index);
}
inline ::msg::PlayerFrameInput* PushFrameInput::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::msg::PlayerFrameInput* PushFrameInput::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >&
PushFrameInput::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >*
PushFrameInput::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// PlayerRecords

// repeated .msg.PlayerFrameInput frames = 1;
inline int PlayerRecords::frames_size() const {
  return frames_.size();
}
inline void PlayerRecords::clear_frames() {
  frames_.Clear();
}
inline const ::msg::PlayerFrameInput& PlayerRecords::frames(int index) const {
  return frames_.Get(index);
}
inline ::msg::PlayerFrameInput* PlayerRecords::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::msg::PlayerFrameInput* PlayerRecords::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >&
PlayerRecords::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PlayerFrameInput >*
PlayerRecords::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// ExitFightReq

// required int32 fightUUID = 1;
inline bool ExitFightReq::has_fightuuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitFightReq::set_has_fightuuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitFightReq::clear_has_fightuuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitFightReq::clear_fightuuid() {
  fightuuid_ = 0;
  clear_has_fightuuid();
}
inline ::google::protobuf::int32 ExitFightReq::fightuuid() const {
  return fightuuid_;
}
inline void ExitFightReq::set_fightuuid(::google::protobuf::int32 value) {
  set_has_fightuuid();
  fightuuid_ = value;
}

// -------------------------------------------------------------------

// ExitFightAck

// required int32 code = 1;
inline bool ExitFightAck::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExitFightAck::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExitFightAck::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExitFightAck::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ExitFightAck::code() const {
  return code_;
}
inline void ExitFightAck::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// -------------------------------------------------------------------

// Ping

// required uint32 timestamp = 1;
inline bool Ping::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 Ping::timestamp() const {
  return timestamp_;
}
inline void Ping::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Pong

// required uint32 timestamp = 1;
inline bool Pong::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pong::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pong::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pong::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 Pong::timestamp() const {
  return timestamp_;
}
inline void Pong::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// PingInfo

// required int64 pid = 1;
inline bool PingInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingInfo::clear_pid() {
  pid_ = GOOGLE_LONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::int64 PingInfo::pid() const {
  return pid_;
}
inline void PingInfo::set_pid(::google::protobuf::int64 value) {
  set_has_pid();
  pid_ = value;
}

// required int32 ping = 2;
inline bool PingInfo::has_ping() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingInfo::set_has_ping() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingInfo::clear_has_ping() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingInfo::clear_ping() {
  ping_ = 0;
  clear_has_ping();
}
inline ::google::protobuf::int32 PingInfo::ping() const {
  return ping_;
}
inline void PingInfo::set_ping(::google::protobuf::int32 value) {
  set_has_ping();
  ping_ = value;
}

// -------------------------------------------------------------------

// PushPingInfo

// repeated .msg.PingInfo infos = 1;
inline int PushPingInfo::infos_size() const {
  return infos_.size();
}
inline void PushPingInfo::clear_infos() {
  infos_.Clear();
}
inline const ::msg::PingInfo& PushPingInfo::infos(int index) const {
  return infos_.Get(index);
}
inline ::msg::PingInfo* PushPingInfo::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::msg::PingInfo* PushPingInfo::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::msg::PingInfo >&
PushPingInfo::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::msg::PingInfo >*
PushPingInfo::mutable_infos() {
  return &infos_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace msg

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Msg_5fGame_2eproto__INCLUDED
